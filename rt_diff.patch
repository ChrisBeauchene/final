diff --git a/../../nrt/nautilus/.DS_Store b/../../nrt/nautilus/.DS_Store
new file mode 100755
index 0000000..e0d9c9e
Binary files /dev/null and b/../../nrt/nautilus/.DS_Store differ
diff --git a/../../nrt/nautilus/.config b/../../nrt/nautilus/.config
new file mode 100644
index 0000000..ca6d3c8
--- /dev/null
+++ b/../../nrt/nautilus/.config
@@ -0,0 +1,93 @@
+#
+# Automatically generated make config: don't edit
+#Nautilus: 
+# Fri Jun 10 14:02:58 2016
+#
+
+#
+# Platform/Arch Options
+#
+NAUT_CONFIG_X86_64_HOST=y
+# NAUT_CONFIG_XEON_PHI is not set
+# NAUT_CONFIG_HVM_HRT is not set
+NAUT_CONFIG_MAX_CPUS=256
+NAUT_CONFIG_MAX_IOAPICS=16
+# NAUT_CONFIG_PALACIOS is not set
+
+#
+# Nautilus AeroKernel Build Config
+#
+NAUT_CONFIG_USE_NAUT_BUILTINS=y
+NAUT_CONFIG_CXX_SUPPORT=y
+NAUT_CONFIG_TOOLCHAIN_ROOT=""
+
+#
+# Interface Options
+#
+NAUT_CONFIG_THREAD_EXIT_KEYCODE=196
+
+#
+# Nautilus AeroKernel Configuration
+#
+# NAUT_CONFIG_USE_TICKETLOCKS is not set
+NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR=y
+NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR_ALL=y
+
+#
+# AeroKernel Performance Optimizations
+#
+NAUT_CONFIG_FPU_SAVE=y
+# NAUT_CONFIG_KICK_SCHEDULE is not set
+# NAUT_CONFIG_HALT_WHILE_IDLE is not set
+# NAUT_CONFIG_THREAD_OPTIMIZE is not set
+# NAUT_CONFIG_USE_IDLE_THREADS is not set
+NAUT_CONFIG_USE_RT_SCHEDULER=y
+
+#
+# Debugging
+#
+NAUT_CONFIG_DEBUG_INFO=y
+NAUT_CONFIG_DEBUG_PRINTS=y
+# NAUT_CONFIG_ENABLE_ASSERTS is not set
+# NAUT_CONFIG_PROFILE is not set
+# NAUT_CONFIG_SILENCE_UNDEF_ERR is not set
+# NAUT_CONFIG_ENABLE_STACK_CHECK is not set
+# NAUT_CONFIG_DEBUG_PAGING is not set
+# NAUT_CONFIG_DEBUG_BOOTMEM is not set
+# NAUT_CONFIG_DEBUG_BUDDY is not set
+# NAUT_CONFIG_DEBUG_KMEM is not set
+# NAUT_CONFIG_DEBUG_FPU is not set
+# NAUT_CONFIG_DEBUG_SMP is not set
+# NAUT_CONFIG_DEBUG_SFI is not set
+# NAUT_CONFIG_DEBUG_CXX is not set
+NAUT_CONFIG_DEBUG_THREADS=y
+NAUT_CONFIG_RT_DEBUG=y
+NAUT_CONFIG_DEBUG_RT_SCHEDULER=y
+NAUT_CONFIG_DEBUG_RT_THREADS=y
+# NAUT_CONFIG_DEBUG_SYNCH is not set
+# NAUT_CONFIG_DEBUG_BARRIER is not set
+# NAUT_CONFIG_DEBUG_NUMA is not set
+# NAUT_CONFIG_DEBUG_VIRTUAL_CONSOLE is not set
+
+#
+# Parallel Runtime Integration
+#
+# NAUT_CONFIG_LEGION_RT is not set
+# NAUT_CONFIG_NDPC_RT is not set
+# NAUT_CONFIG_NESL_RT is not set
+NAUT_CONFIG_NO_RT=y
+
+#
+# Device options
+#
+NAUT_CONFIG_SERIAL_REDIRECT=y
+NAUT_CONFIG_SERIAL_PORT=1
+NAUT_CONFIG_DEBUG_APIC=y
+# NAUT_CONFIG_DEBUG_IOAPIC is not set
+# NAUT_CONFIG_DEBUG_PCI is not set
+# NAUT_CONFIG_DEBUG_KBD is not set
+# NAUT_CONFIG_DEBUG_TIMERS is not set
+# NAUT_CONFIG_DEBUG_PIT is not set
+# NAUT_CONFIG_HPET is not set
+NAUT_CONFIG_HZ=10
+# NAUT_CONFIG_VIRTIO_PCI is not set
diff --git a/../../nrt/nautilus/.config.old b/../../nrt/nautilus/.config.old
new file mode 100644
index 0000000..0ad3678
--- /dev/null
+++ b/../../nrt/nautilus/.config.old
@@ -0,0 +1,93 @@
+#
+# Automatically generated make config: don't edit
+#Nautilus: 
+# Fri Jun 10 13:57:12 2016
+#
+
+#
+# Platform/Arch Options
+#
+NAUT_CONFIG_X86_64_HOST=y
+# NAUT_CONFIG_XEON_PHI is not set
+# NAUT_CONFIG_HVM_HRT is not set
+NAUT_CONFIG_MAX_CPUS=256
+NAUT_CONFIG_MAX_IOAPICS=16
+# NAUT_CONFIG_PALACIOS is not set
+
+#
+# Nautilus AeroKernel Build Config
+#
+NAUT_CONFIG_USE_NAUT_BUILTINS=y
+NAUT_CONFIG_CXX_SUPPORT=y
+NAUT_CONFIG_TOOLCHAIN_ROOT=""
+
+#
+# Interface Options
+#
+NAUT_CONFIG_THREAD_EXIT_KEYCODE=196
+
+#
+# Nautilus AeroKernel Configuration
+#
+# NAUT_CONFIG_USE_TICKETLOCKS is not set
+NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR=y
+NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR_ALL=y
+
+#
+# AeroKernel Performance Optimizations
+#
+NAUT_CONFIG_FPU_SAVE=y
+# NAUT_CONFIG_KICK_SCHEDULE is not set
+# NAUT_CONFIG_HALT_WHILE_IDLE is not set
+# NAUT_CONFIG_THREAD_OPTIMIZE is not set
+# NAUT_CONFIG_USE_IDLE_THREADS is not set
+NAUT_CONFIG_USE_RT_SCHEDULER=y
+
+#
+# Debugging
+#
+NAUT_CONFIG_DEBUG_INFO=y
+NAUT_CONFIG_DEBUG_PRINTS=y
+# NAUT_CONFIG_ENABLE_ASSERTS is not set
+# NAUT_CONFIG_PROFILE is not set
+# NAUT_CONFIG_SILENCE_UNDEF_ERR is not set
+# NAUT_CONFIG_ENABLE_STACK_CHECK is not set
+# NAUT_CONFIG_DEBUG_PAGING is not set
+# NAUT_CONFIG_DEBUG_BOOTMEM is not set
+# NAUT_CONFIG_DEBUG_BUDDY is not set
+# NAUT_CONFIG_DEBUG_KMEM is not set
+# NAUT_CONFIG_DEBUG_FPU is not set
+# NAUT_CONFIG_DEBUG_SMP is not set
+# NAUT_CONFIG_DEBUG_SFI is not set
+# NAUT_CONFIG_DEBUG_CXX is not set
+NAUT_CONFIG_DEBUG_THREADS=y
+NAUT_CONFIG_RT_DEBUG=y
+NAUT_CONFIG_DEBUG_RT_SCHEDULER=y
+NAUT_CONFIG_DEBUG_RT_THREADS=y
+# NAUT_CONFIG_DEBUG_SYNCH is not set
+# NAUT_CONFIG_DEBUG_BARRIER is not set
+# NAUT_CONFIG_DEBUG_NUMA is not set
+# NAUT_CONFIG_DEBUG_VIRTUAL_CONSOLE is not set
+
+#
+# Parallel Runtime Integration
+#
+# NAUT_CONFIG_LEGION_RT is not set
+# NAUT_CONFIG_NDPC_RT is not set
+# NAUT_CONFIG_NESL_RT is not set
+NAUT_CONFIG_NO_RT=y
+
+#
+# Device options
+#
+NAUT_CONFIG_SERIAL_REDIRECT=y
+NAUT_CONFIG_SERIAL_PORT=1
+NAUT_CONFIG_DEBUG_APIC=y
+# NAUT_CONFIG_DEBUG_IOAPIC is not set
+# NAUT_CONFIG_DEBUG_PCI is not set
+# NAUT_CONFIG_DEBUG_KBD is not set
+# NAUT_CONFIG_DEBUG_TIMERS is not set
+# NAUT_CONFIG_DEBUG_PIT is not set
+# NAUT_CONFIG_HPET is not set
+NAUT_CONFIG_HZ=10
+# NAUT_CONFIG_VIRTIO_PCI is not set
diff --git a/./.git/HEAD b/./.git/HEAD
deleted file mode 100644
index cb089cd..0000000
--- a/./.git/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-ref: refs/heads/master
diff --git a/./.git/config b/./.git/config
deleted file mode 100644
index bf5b8e4..0000000
--- a/./.git/config
+++ /dev/null
@@ -1,11 +0,0 @@
-[core]
-	repositoryformatversion = 0
-	filemode = true
-	bare = false
-	logallrefupdates = true
-[remote "origin"]
-	url = https://bitbucket.org/kchale/nautilus
-	fetch = +refs/heads/*:refs/remotes/origin/*
-[branch "master"]
-	remote = origin
-	merge = refs/heads/master
diff --git a/./.git/description b/./.git/description
deleted file mode 100644
index 498b267..0000000
--- a/./.git/description
+++ /dev/null
@@ -1 +0,0 @@
-Unnamed repository; edit this file 'description' to name the repository.
diff --git a/./.git/hooks/applypatch-msg.sample b/./.git/hooks/applypatch-msg.sample
deleted file mode 100755
index 8b2a2fe..0000000
--- a/./.git/hooks/applypatch-msg.sample
+++ /dev/null
@@ -1,15 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message taken by
-# applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.  The hook is
-# allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "applypatch-msg".
-
-. git-sh-setup
-test -x "$GIT_DIR/hooks/commit-msg" &&
-	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
-:
diff --git a/./.git/hooks/commit-msg.sample b/./.git/hooks/commit-msg.sample
deleted file mode 100755
index b58d118..0000000
--- a/./.git/hooks/commit-msg.sample
+++ /dev/null
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message.
-# Called by "git commit" with one argument, the name of the file
-# that has the commit message.  The hook should exit with non-zero
-# status after issuing an appropriate message if it wants to stop the
-# commit.  The hook is allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "commit-msg".
-
-# Uncomment the below to add a Signed-off-by line to the message.
-# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
-# hook is more suited to it.
-#
-# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
-
-# This example catches duplicate Signed-off-by lines.
-
-test "" = "$(grep '^Signed-off-by: ' "$1" |
-	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
-	echo >&2 Duplicate Signed-off-by lines.
-	exit 1
-}
diff --git a/./.git/hooks/post-update.sample b/./.git/hooks/post-update.sample
deleted file mode 100755
index ec17ec1..0000000
--- a/./.git/hooks/post-update.sample
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare a packed repository for use over
-# dumb transports.
-#
-# To enable this hook, rename this file to "post-update".
-
-exec git update-server-info
diff --git a/./.git/hooks/pre-applypatch.sample b/./.git/hooks/pre-applypatch.sample
deleted file mode 100755
index b1f187c..0000000
--- a/./.git/hooks/pre-applypatch.sample
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed
-# by applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-applypatch".
-
-. git-sh-setup
-test -x "$GIT_DIR/hooks/pre-commit" &&
-	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
-:
diff --git a/./.git/hooks/pre-commit.sample b/./.git/hooks/pre-commit.sample
deleted file mode 100755
index 68d62d5..0000000
--- a/./.git/hooks/pre-commit.sample
+++ /dev/null
@@ -1,49 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git commit" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message if
-# it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-commit".
-
-if git rev-parse --verify HEAD >/dev/null 2>&1
-then
-	against=HEAD
-else
-	# Initial commit: diff against an empty tree object
-	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
-fi
-
-# If you want to allow non-ASCII filenames set this variable to true.
-allownonascii=$(git config --bool hooks.allownonascii)
-
-# Redirect output to stderr.
-exec 1>&2
-
-# Cross platform projects tend to avoid non-ASCII filenames; prevent
-# them from being added to the repository. We exploit the fact that the
-# printable range starts at the space character and ends with tilde.
-if [ "$allownonascii" != "true" ] &&
-	# Note that the use of brackets around a tr range is ok here, (it's
-	# even required, for portability to Solaris 10's /usr/bin/tr), since
-	# the square bracket bytes happen to fall in the designated range.
-	test $(git diff --cached --name-only --diff-filter=A -z $against |
-	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
-then
-	cat <<\EOF
-Error: Attempt to add a non-ASCII file name.
-
-This can cause problems if you want to work with people on other platforms.
-
-To be portable it is advisable to rename the file.
-
-If you know what you are doing you can disable this check using:
-
-  git config hooks.allownonascii true
-EOF
-	exit 1
-fi
-
-# If there are whitespace errors, print the offending file names and fail.
-exec git diff-index --check --cached $against --
diff --git a/./.git/hooks/pre-push.sample b/./.git/hooks/pre-push.sample
deleted file mode 100755
index 1f3bceb..0000000
--- a/./.git/hooks/pre-push.sample
+++ /dev/null
@@ -1,54 +0,0 @@
-#!/bin/sh
-
-# An example hook script to verify what is about to be pushed.  Called by "git
-# push" after it has checked the remote status, but before anything has been
-# pushed.  If this script exits with a non-zero status nothing will be pushed.
-#
-# This hook is called with the following parameters:
-#
-# $1 -- Name of the remote to which the push is being done
-# $2 -- URL to which the push is being done
-#
-# If pushing without using a named remote those arguments will be equal.
-#
-# Information about the commits which are being pushed is supplied as lines to
-# the standard input in the form:
-#
-#   <local ref> <local sha1> <remote ref> <remote sha1>
-#
-# This sample shows how to prevent push of commits where the log message starts
-# with "WIP" (work in progress).
-
-remote="$1"
-url="$2"
-
-z40=0000000000000000000000000000000000000000
-
-IFS=' '
-while read local_ref local_sha remote_ref remote_sha
-do
-	if [ "$local_sha" = $z40 ]
-	then
-		# Handle delete
-		:
-	else
-		if [ "$remote_sha" = $z40 ]
-		then
-			# New branch, examine all commits
-			range="$local_sha"
-		else
-			# Update to existing branch, examine new commits
-			range="$remote_sha..$local_sha"
-		fi
-
-		# Check for WIP commit
-		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
-		if [ -n "$commit" ]
-		then
-			echo "Found WIP commit in $local_ref, not pushing"
-			exit 1
-		fi
-	fi
-done
-
-exit 0
diff --git a/./.git/hooks/pre-rebase.sample b/./.git/hooks/pre-rebase.sample
deleted file mode 100755
index 33730ca..0000000
--- a/./.git/hooks/pre-rebase.sample
+++ /dev/null
@@ -1,169 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2006, 2008 Junio C Hamano
-#
-# The "pre-rebase" hook is run just before "git rebase" starts doing
-# its job, and can prevent the command from running by exiting with
-# non-zero status.
-#
-# The hook is called with the following parameters:
-#
-# $1 -- the upstream the series was forked from.
-# $2 -- the branch being rebased (or empty when rebasing the current branch).
-#
-# This sample shows how to prevent topic branches that are already
-# merged to 'next' branch from getting rebased, because allowing it
-# would result in rebasing already published history.
-
-publish=next
-basebranch="$1"
-if test "$#" = 2
-then
-	topic="refs/heads/$2"
-else
-	topic=`git symbolic-ref HEAD` ||
-	exit 0 ;# we do not interrupt rebasing detached HEAD
-fi
-
-case "$topic" in
-refs/heads/??/*)
-	;;
-*)
-	exit 0 ;# we do not interrupt others.
-	;;
-esac
-
-# Now we are dealing with a topic branch being rebased
-# on top of master.  Is it OK to rebase it?
-
-# Does the topic really exist?
-git show-ref -q "$topic" || {
-	echo >&2 "No such branch $topic"
-	exit 1
-}
-
-# Is topic fully merged to master?
-not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
-if test -z "$not_in_master"
-then
-	echo >&2 "$topic is fully merged to master; better remove it."
-	exit 1 ;# we could allow it, but there is no point.
-fi
-
-# Is topic ever merged to next?  If so you should not be rebasing it.
-only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
-only_next_2=`git rev-list ^master           ${publish} | sort`
-if test "$only_next_1" = "$only_next_2"
-then
-	not_in_topic=`git rev-list "^$topic" master`
-	if test -z "$not_in_topic"
-	then
-		echo >&2 "$topic is already up-to-date with master"
-		exit 1 ;# we could allow it, but there is no point.
-	else
-		exit 0
-	fi
-else
-	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
-	/usr/bin/perl -e '
-		my $topic = $ARGV[0];
-		my $msg = "* $topic has commits already merged to public branch:\n";
-		my (%not_in_next) = map {
-			/^([0-9a-f]+) /;
-			($1 => 1);
-		} split(/\n/, $ARGV[1]);
-		for my $elem (map {
-				/^([0-9a-f]+) (.*)$/;
-				[$1 => $2];
-			} split(/\n/, $ARGV[2])) {
-			if (!exists $not_in_next{$elem->[0]}) {
-				if ($msg) {
-					print STDERR $msg;
-					undef $msg;
-				}
-				print STDERR " $elem->[1]\n";
-			}
-		}
-	' "$topic" "$not_in_next" "$not_in_master"
-	exit 1
-fi
-
-<<\DOC_END
-
-This sample hook safeguards topic branches that have been
-published from being rewound.
-
-The workflow assumed here is:
-
- * Once a topic branch forks from "master", "master" is never
-   merged into it again (either directly or indirectly).
-
- * Once a topic branch is fully cooked and merged into "master",
-   it is deleted.  If you need to build on top of it to correct
-   earlier mistakes, a new topic branch is created by forking at
-   the tip of the "master".  This is not strictly necessary, but
-   it makes it easier to keep your history simple.
-
- * Whenever you need to test or publish your changes to topic
-   branches, merge them into "next" branch.
-
-The script, being an example, hardcodes the publish branch name
-to be "next", but it is trivial to make it configurable via
-$GIT_DIR/config mechanism.
-
-With this workflow, you would want to know:
-
-(1) ... if a topic branch has ever been merged to "next".  Young
-    topic branches can have stupid mistakes you would rather
-    clean up before publishing, and things that have not been
-    merged into other branches can be easily rebased without
-    affecting other people.  But once it is published, you would
-    not want to rewind it.
-
-(2) ... if a topic branch has been fully merged to "master".
-    Then you can delete it.  More importantly, you should not
-    build on top of it -- other people may already want to
-    change things related to the topic as patches against your
-    "master", so if you need further changes, it is better to
-    fork the topic (perhaps with the same name) afresh from the
-    tip of "master".
-
-Let's look at this example:
-
-		   o---o---o---o---o---o---o---o---o---o "next"
-		  /       /           /           /
-		 /   a---a---b A     /           /
-		/   /               /           /
-	       /   /   c---c---c---c B         /
-	      /   /   /             \         /
-	     /   /   /   b---b C     \       /
-	    /   /   /   /             \     /
-    ---o---o---o---o---o---o---o---o---o---o---o "master"
-
-
-A, B and C are topic branches.
-
- * A has one fix since it was merged up to "next".
-
- * B has finished.  It has been fully merged up to "master" and "next",
-   and is ready to be deleted.
-
- * C has not merged to "next" at all.
-
-We would want to allow C to be rebased, refuse A, and encourage
-B to be deleted.
-
-To compute (1):
-
-	git rev-list ^master ^topic next
-	git rev-list ^master        next
-
-	if these match, topic has not merged in next at all.
-
-To compute (2):
-
-	git rev-list master..topic
-
-	if this is empty, it is fully merged to "master".
-
-DOC_END
diff --git a/./.git/hooks/prepare-commit-msg.sample b/./.git/hooks/prepare-commit-msg.sample
deleted file mode 100755
index f093a02..0000000
--- a/./.git/hooks/prepare-commit-msg.sample
+++ /dev/null
@@ -1,36 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare the commit log message.
-# Called by "git commit" with the name of the file that has the
-# commit message, followed by the description of the commit
-# message's source.  The hook's purpose is to edit the commit
-# message file.  If the hook fails with a non-zero status,
-# the commit is aborted.
-#
-# To enable this hook, rename this file to "prepare-commit-msg".
-
-# This hook includes three examples.  The first comments out the
-# "Conflicts:" part of a merge commit.
-#
-# The second includes the output of "git diff --name-status -r"
-# into the message, just before the "git status" output.  It is
-# commented because it doesn't cope with --amend or with squashed
-# commits.
-#
-# The third example adds a Signed-off-by line to the message, that can
-# still be edited.  This is rarely a good idea.
-
-case "$2,$3" in
-  merge,)
-    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
-
-# ,|template,)
-#   /usr/bin/perl -i.bak -pe '
-#      print "\n" . `git diff --cached --name-status -r`
-#	 if /^#/ && $first++ == 0' "$1" ;;
-
-  *) ;;
-esac
-
-# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff --git a/./.git/hooks/update.sample b/./.git/hooks/update.sample
deleted file mode 100755
index d847583..0000000
--- a/./.git/hooks/update.sample
+++ /dev/null
@@ -1,128 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to blocks unannotated tags from entering.
-# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
-#
-# To enable this hook, rename this file to "update".
-#
-# Config
-# ------
-# hooks.allowunannotated
-#   This boolean sets whether unannotated tags will be allowed into the
-#   repository.  By default they won't be.
-# hooks.allowdeletetag
-#   This boolean sets whether deleting tags will be allowed in the
-#   repository.  By default they won't be.
-# hooks.allowmodifytag
-#   This boolean sets whether a tag may be modified after creation. By default
-#   it won't be.
-# hooks.allowdeletebranch
-#   This boolean sets whether deleting branches will be allowed in the
-#   repository.  By default they won't be.
-# hooks.denycreatebranch
-#   This boolean sets whether remotely creating branches will be denied
-#   in the repository.  By default this is allowed.
-#
-
-# --- Command line
-refname="$1"
-oldrev="$2"
-newrev="$3"
-
-# --- Safety check
-if [ -z "$GIT_DIR" ]; then
-	echo "Don't run this script from the command line." >&2
-	echo " (if you want, you could supply GIT_DIR then run" >&2
-	echo "  $0 <ref> <oldrev> <newrev>)" >&2
-	exit 1
-fi
-
-if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
-	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
-	exit 1
-fi
-
-# --- Config
-allowunannotated=$(git config --bool hooks.allowunannotated)
-allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
-denycreatebranch=$(git config --bool hooks.denycreatebranch)
-allowdeletetag=$(git config --bool hooks.allowdeletetag)
-allowmodifytag=$(git config --bool hooks.allowmodifytag)
-
-# check for no description
-projectdesc=$(sed -e '1q' "$GIT_DIR/description")
-case "$projectdesc" in
-"Unnamed repository"* | "")
-	echo "*** Project description file hasn't been set" >&2
-	exit 1
-	;;
-esac
-
-# --- Check types
-# if $newrev is 0000...0000, it's a commit to delete a ref.
-zero="0000000000000000000000000000000000000000"
-if [ "$newrev" = "$zero" ]; then
-	newrev_type=delete
-else
-	newrev_type=$(git cat-file -t $newrev)
-fi
-
-case "$refname","$newrev_type" in
-	refs/tags/*,commit)
-		# un-annotated tag
-		short_refname=${refname##refs/tags/}
-		if [ "$allowunannotated" != "true" ]; then
-			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
-			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,delete)
-		# delete tag
-		if [ "$allowdeletetag" != "true" ]; then
-			echo "*** Deleting a tag is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,tag)
-		# annotated tag
-		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
-		then
-			echo "*** Tag '$refname' already exists." >&2
-			echo "*** Modifying a tag is not allowed in this repository." >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,commit)
-		# branch
-		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
-			echo "*** Creating a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,delete)
-		# delete branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/remotes/*,commit)
-		# tracking branch
-		;;
-	refs/remotes/*,delete)
-		# delete tracking branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	*)
-		# Anything else (is there anything else?)
-		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
-		exit 1
-		;;
-esac
-
-# --- Finished
-exit 0
diff --git a/./.git/index b/./.git/index
deleted file mode 100644
index 6b9968a..0000000
Binary files a/./.git/index and /dev/null differ
diff --git a/./.git/info/exclude b/./.git/info/exclude
deleted file mode 100644
index a5196d1..0000000
--- a/./.git/info/exclude
+++ /dev/null
@@ -1,6 +0,0 @@
-# git ls-files --others --exclude-from=.git/info/exclude
-# Lines that start with '#' are comments.
-# For a project mostly in C, the following would be a good set of
-# exclude patterns (uncomment them if you want to use them):
-# *.[oa]
-# *~
diff --git a/./.git/logs/HEAD b/./.git/logs/HEAD
deleted file mode 100644
index 7b0736e..0000000
--- a/./.git/logs/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 b512503d27acf20ae65b5c95571e472014fbdf7b ChrisBeauchene <christopherbeauchene2016@u.northwestern.edu> 1465587652 -0500	clone: from https://bitbucket.org/kchale/nautilus
diff --git a/./.git/logs/refs/heads/master b/./.git/logs/refs/heads/master
deleted file mode 100644
index 7b0736e..0000000
--- a/./.git/logs/refs/heads/master
+++ /dev/null
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 b512503d27acf20ae65b5c95571e472014fbdf7b ChrisBeauchene <christopherbeauchene2016@u.northwestern.edu> 1465587652 -0500	clone: from https://bitbucket.org/kchale/nautilus
diff --git a/./.git/logs/refs/remotes/origin/HEAD b/./.git/logs/refs/remotes/origin/HEAD
deleted file mode 100644
index 7b0736e..0000000
--- a/./.git/logs/refs/remotes/origin/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 b512503d27acf20ae65b5c95571e472014fbdf7b ChrisBeauchene <christopherbeauchene2016@u.northwestern.edu> 1465587652 -0500	clone: from https://bitbucket.org/kchale/nautilus
diff --git a/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.idx b/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.idx
deleted file mode 100644
index bb29d79..0000000
Binary files a/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.idx and /dev/null differ
diff --git a/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.pack b/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.pack
deleted file mode 100644
index e6baac6..0000000
Binary files a/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.pack and /dev/null differ
diff --git a/./.git/packed-refs b/./.git/packed-refs
deleted file mode 100644
index aab9e22..0000000
--- a/./.git/packed-refs
+++ /dev/null
@@ -1,2 +0,0 @@
-# pack-refs with: peeled fully-peeled 
-b512503d27acf20ae65b5c95571e472014fbdf7b refs/remotes/origin/master
diff --git a/./.git/refs/heads/master b/./.git/refs/heads/master
deleted file mode 100644
index abae1b4..0000000
--- a/./.git/refs/heads/master
+++ /dev/null
@@ -1 +0,0 @@
-b512503d27acf20ae65b5c95571e472014fbdf7b
diff --git a/./.git/refs/remotes/origin/HEAD b/./.git/refs/remotes/origin/HEAD
deleted file mode 100644
index 6efe28f..0000000
--- a/./.git/refs/remotes/origin/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-ref: refs/remotes/origin/master
diff --git a/./.gitignore b/../../nrt/nautilus/.gitignore
old mode 100644
new mode 100755
diff --git a/./Kconfig b/../../nrt/nautilus/Kconfig
old mode 100644
new mode 100755
index 50bdaea..3c136d3
--- a/./Kconfig
+++ b/../../nrt/nautilus/Kconfig
@@ -213,6 +213,13 @@ menu "AeroKernel Performance Optimizations"
             Enables idle threads to start in addition to the main boot threads. 
             Usually not needed.
 
+    config USE_RT_SCHEDULER
+    bool "Use real-time scheduler."
+    default n
+    help
+        Enables the use of the real-time scheduler.
+        Disables apic periodic timer and uses a oneshot timer to call the scheduler at various intervals.
+
 
 endmenu
     
@@ -332,6 +339,27 @@ menu Debugging
       help
         Turn on debug prints for the scheduler/threads
 
+    config RT_DEBUG
+    bool "Enable real-time debugging"
+    depends on USE_RT_SCHEDULER
+    default n
+    help
+        Compiles the Nautilus kernl with real-time debugging prints
+
+    config DEBUG_RT_SCHEDULER
+    bool "Debug Real-Time Scheduler"
+    depends on RT_DEBUG
+    default n
+    help
+        Turn on debug prints for real-time scheduler code
+
+    config DEBUG_RT_THREADS
+    bool "Debug Real-Time Threads"
+    depends on RT_DEBUG
+    default n
+    help
+        Turn on debug prints for real-time thread code
+
     config DEBUG_SYNCH
       bool "Debug Synchronization"
       depends on DEBUG_PRINTS
@@ -431,3 +459,5 @@ endmenu
 
 source "src/dev/Kconfig"
 
+
+
diff --git a/./LICENSE.txt b/../../nrt/nautilus/LICENSE.txt
old mode 100644
new mode 100755
diff --git a/./Makefile b/../../nrt/nautilus/Makefile
old mode 100644
new mode 100755
diff --git a/./Makefile.x86_64 b/../../nrt/nautilus/Makefile.x86_64
old mode 100644
new mode 100755
diff --git a/./README.md b/../../nrt/nautilus/README.md
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/include/.DS_Store b/../../nrt/nautilus/include/.DS_Store
new file mode 100755
index 0000000..00e67e6
Binary files /dev/null and b/../../nrt/nautilus/include/.DS_Store differ
diff --git a/./include/acpi/acexcep.h b/../../nrt/nautilus/include/acpi/acexcep.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/acnames.h b/../../nrt/nautilus/include/acpi/acnames.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/acoutput.h b/../../nrt/nautilus/include/acpi/acoutput.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/acpi.h b/../../nrt/nautilus/include/acpi/acpi.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/acpiosxf.h b/../../nrt/nautilus/include/acpi/acpiosxf.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/acpixf.h b/../../nrt/nautilus/include/acpi/acpixf.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/acrestyp.h b/../../nrt/nautilus/include/acpi/acrestyp.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/actbl.h b/../../nrt/nautilus/include/acpi/actbl.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/actbl1.h b/../../nrt/nautilus/include/acpi/actbl1.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/actbl2.h b/../../nrt/nautilus/include/acpi/actbl2.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/actypes.h b/../../nrt/nautilus/include/acpi/actypes.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/platform/acenv.h b/../../nrt/nautilus/include/acpi/platform/acenv.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/platform/acgcc.h b/../../nrt/nautilus/include/acpi/platform/acgcc.h
old mode 100644
new mode 100755
diff --git a/./include/acpi/platform/acnautilus.h b/../../nrt/nautilus/include/acpi/platform/acnautilus.h
old mode 100644
new mode 100755
diff --git a/./include/arch/hrt/hrt.h b/../../nrt/nautilus/include/arch/hrt/hrt.h
old mode 100644
new mode 100755
diff --git a/./include/arch/hrt/init.h b/../../nrt/nautilus/include/arch/hrt/init.h
old mode 100644
new mode 100755
diff --git a/./include/arch/hrt/main.h b/../../nrt/nautilus/include/arch/hrt/main.h
old mode 100644
new mode 100755
diff --git a/./include/arch/k1om/init.h b/../../nrt/nautilus/include/arch/k1om/init.h
old mode 100644
new mode 100755
diff --git a/./include/arch/k1om/k1omsfi.h b/../../nrt/nautilus/include/arch/k1om/k1omsfi.h
old mode 100644
new mode 100755
diff --git a/./include/arch/k1om/main.h b/../../nrt/nautilus/include/arch/k1om/main.h
old mode 100644
new mode 100755
diff --git a/./include/arch/k1om/xeon_phi.h b/../../nrt/nautilus/include/arch/k1om/xeon_phi.h
old mode 100644
new mode 100755
diff --git a/./include/arch/x64/init.h b/../../nrt/nautilus/include/arch/x64/init.h
old mode 100644
new mode 100755
diff --git a/./include/arch/x64/main.h b/../../nrt/nautilus/include/arch/x64/main.h
old mode 100644
new mode 100755
diff --git a/./include/asm/bitops.h b/../../nrt/nautilus/include/asm/bitops.h
old mode 100644
new mode 100755
diff --git a/./include/asm/lowlevel.h b/../../nrt/nautilus/include/asm/lowlevel.h
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/include/autoconf.h b/../../nrt/nautilus/include/autoconf.h
new file mode 100644
index 0000000..656b8b4
--- /dev/null
+++ b/../../nrt/nautilus/include/autoconf.h
@@ -0,0 +1,94 @@
+/*
+ * Automatically generated C config: don't edit
+ * Nautilus version: 
+ * Fri Jun 10 14:02:58 2016
+ */
+#define AUTOCONF_INCLUDED
+
+/*
+ * Platform/Arch Options
+ */
+#define NAUT_CONFIG_X86_64_HOST 1
+#undef NAUT_CONFIG_XEON_PHI
+#undef NAUT_CONFIG_HVM_HRT
+#define NAUT_CONFIG_MAX_CPUS 256
+#define NAUT_CONFIG_MAX_IOAPICS 16
+#undef NAUT_CONFIG_PALACIOS
+
+/*
+ * Nautilus AeroKernel Build Config
+ */
+#define NAUT_CONFIG_USE_NAUT_BUILTINS 1
+#define NAUT_CONFIG_CXX_SUPPORT 1
+#define NAUT_CONFIG_TOOLCHAIN_ROOT ""
+
+/*
+ * Interface Options
+ */
+#define NAUT_CONFIG_THREAD_EXIT_KEYCODE 196
+
+/*
+ * Nautilus AeroKernel Configuration
+ */
+#undef NAUT_CONFIG_USE_TICKETLOCKS
+#define NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR 1
+#define NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR_ALL 1
+
+/*
+ * AeroKernel Performance Optimizations
+ */
+#define NAUT_CONFIG_FPU_SAVE 1
+#undef NAUT_CONFIG_KICK_SCHEDULE
+#undef NAUT_CONFIG_HALT_WHILE_IDLE
+#undef NAUT_CONFIG_THREAD_OPTIMIZE
+#undef NAUT_CONFIG_USE_IDLE_THREADS
+#define NAUT_CONFIG_USE_RT_SCHEDULER 1
+
+/*
+ * Debugging
+ */
+#define NAUT_CONFIG_DEBUG_INFO 1
+#define NAUT_CONFIG_DEBUG_PRINTS 1
+#undef NAUT_CONFIG_ENABLE_ASSERTS
+#undef NAUT_CONFIG_PROFILE
+#undef NAUT_CONFIG_SILENCE_UNDEF_ERR
+#undef NAUT_CONFIG_ENABLE_STACK_CHECK
+#undef NAUT_CONFIG_DEBUG_PAGING
+#undef NAUT_CONFIG_DEBUG_BOOTMEM
+#undef NAUT_CONFIG_DEBUG_BUDDY
+#undef NAUT_CONFIG_DEBUG_KMEM
+#undef NAUT_CONFIG_DEBUG_FPU
+#undef NAUT_CONFIG_DEBUG_SMP
+#undef NAUT_CONFIG_DEBUG_SFI
+#undef NAUT_CONFIG_DEBUG_CXX
+#define NAUT_CONFIG_DEBUG_THREADS 1
+#define NAUT_CONFIG_RT_DEBUG 1
+#define NAUT_CONFIG_DEBUG_RT_SCHEDULER 1
+#define NAUT_CONFIG_DEBUG_RT_THREADS 1
+#undef NAUT_CONFIG_DEBUG_SYNCH
+#undef NAUT_CONFIG_DEBUG_BARRIER
+#undef NAUT_CONFIG_DEBUG_NUMA
+#undef NAUT_CONFIG_DEBUG_VIRTUAL_CONSOLE
+
+/*
+ * Parallel Runtime Integration
+ */
+#undef NAUT_CONFIG_LEGION_RT
+#undef NAUT_CONFIG_NDPC_RT
+#undef NAUT_CONFIG_NESL_RT
+#define NAUT_CONFIG_NO_RT 1
+
+/*
+ * Device options
+ */
+#define NAUT_CONFIG_SERIAL_REDIRECT 1
+#define NAUT_CONFIG_SERIAL_PORT 1
+#define NAUT_CONFIG_DEBUG_APIC 1
+#undef NAUT_CONFIG_DEBUG_IOAPIC
+#undef NAUT_CONFIG_DEBUG_PCI
+#undef NAUT_CONFIG_DEBUG_KBD
+#undef NAUT_CONFIG_DEBUG_TIMERS
+#undef NAUT_CONFIG_DEBUG_PIT
+#undef NAUT_CONFIG_HPET
+#define NAUT_CONFIG_HZ 10
+#undef NAUT_CONFIG_VIRTIO_PCI
diff --git a/../../nrt/nautilus/include/config/MARKER b/../../nrt/nautilus/include/config/MARKER
new file mode 100755
index 0000000..e69de29
diff --git a/../../nrt/nautilus/include/config/cxx/support.h b/../../nrt/nautilus/include/config/cxx/support.h
new file mode 100755
index 0000000..5764e41
--- /dev/null
+++ b/../../nrt/nautilus/include/config/cxx/support.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_CXX_SUPPORT 1
diff --git a/../../nrt/nautilus/include/config/debug/apic.h b/../../nrt/nautilus/include/config/debug/apic.h
new file mode 100755
index 0000000..6c9af72
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/apic.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_DEBUG_APIC 1
diff --git a/../../nrt/nautilus/include/config/debug/barrier.h b/../../nrt/nautilus/include/config/debug/barrier.h
new file mode 100755
index 0000000..df18039
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/barrier.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_BARRIER
diff --git a/../../nrt/nautilus/include/config/debug/bootmem.h b/../../nrt/nautilus/include/config/debug/bootmem.h
new file mode 100755
index 0000000..7e534d0
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/bootmem.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_BOOTMEM
diff --git a/../../nrt/nautilus/include/config/debug/buddy.h b/../../nrt/nautilus/include/config/debug/buddy.h
new file mode 100755
index 0000000..cd02529
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/buddy.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_BUDDY
diff --git a/../../nrt/nautilus/include/config/debug/cxx.h b/../../nrt/nautilus/include/config/debug/cxx.h
new file mode 100755
index 0000000..9b8a1a0
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/cxx.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_CXX
diff --git a/../../nrt/nautilus/include/config/debug/fpu.h b/../../nrt/nautilus/include/config/debug/fpu.h
new file mode 100755
index 0000000..501de9c
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/fpu.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_FPU
diff --git a/../../nrt/nautilus/include/config/debug/info.h b/../../nrt/nautilus/include/config/debug/info.h
new file mode 100755
index 0000000..692d822
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/info.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_DEBUG_INFO 1
diff --git a/../../nrt/nautilus/include/config/debug/ioapic.h b/../../nrt/nautilus/include/config/debug/ioapic.h
new file mode 100755
index 0000000..f2ee5d4
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/ioapic.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_IOAPIC
diff --git a/../../nrt/nautilus/include/config/debug/kbd.h b/../../nrt/nautilus/include/config/debug/kbd.h
new file mode 100755
index 0000000..52ea805
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/kbd.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_KBD
diff --git a/../../nrt/nautilus/include/config/debug/kmem.h b/../../nrt/nautilus/include/config/debug/kmem.h
new file mode 100755
index 0000000..574a48c
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/kmem.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_KMEM
diff --git a/../../nrt/nautilus/include/config/debug/numa.h b/../../nrt/nautilus/include/config/debug/numa.h
new file mode 100755
index 0000000..fffcecd
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/numa.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_NUMA
diff --git a/../../nrt/nautilus/include/config/debug/paging.h b/../../nrt/nautilus/include/config/debug/paging.h
new file mode 100755
index 0000000..5b5b1bf
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/paging.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_PAGING
diff --git a/../../nrt/nautilus/include/config/debug/pci.h b/../../nrt/nautilus/include/config/debug/pci.h
new file mode 100755
index 0000000..fccd313
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/pci.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_PCI
diff --git a/../../nrt/nautilus/include/config/debug/pit.h b/../../nrt/nautilus/include/config/debug/pit.h
new file mode 100755
index 0000000..1df573d
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/pit.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_PIT
diff --git a/../../nrt/nautilus/include/config/debug/prints.h b/../../nrt/nautilus/include/config/debug/prints.h
new file mode 100755
index 0000000..78fe9d5
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/prints.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_DEBUG_PRINTS 1
diff --git a/../../nrt/nautilus/include/config/debug/rt/scheduler.h b/../../nrt/nautilus/include/config/debug/rt/scheduler.h
new file mode 100755
index 0000000..b16dfd1
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/rt/scheduler.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_DEBUG_RT_SCHEDULER 1
diff --git a/../../nrt/nautilus/include/config/debug/rt/threads.h b/../../nrt/nautilus/include/config/debug/rt/threads.h
new file mode 100755
index 0000000..360b1a7
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/rt/threads.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_DEBUG_RT_THREADS 1
diff --git a/../../nrt/nautilus/include/config/debug/sfi.h b/../../nrt/nautilus/include/config/debug/sfi.h
new file mode 100755
index 0000000..474b985
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/sfi.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_SFI
diff --git a/../../nrt/nautilus/include/config/debug/smp.h b/../../nrt/nautilus/include/config/debug/smp.h
new file mode 100755
index 0000000..1ebd356
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/smp.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_SMP
diff --git a/../../nrt/nautilus/include/config/debug/synch.h b/../../nrt/nautilus/include/config/debug/synch.h
new file mode 100755
index 0000000..825f374
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/synch.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_SYNCH
diff --git a/../../nrt/nautilus/include/config/debug/threads.h b/../../nrt/nautilus/include/config/debug/threads.h
new file mode 100755
index 0000000..0343541
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/threads.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_DEBUG_THREADS 1
diff --git a/../../nrt/nautilus/include/config/debug/timers.h b/../../nrt/nautilus/include/config/debug/timers.h
new file mode 100755
index 0000000..7aca192
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/timers.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_TIMERS
diff --git a/../../nrt/nautilus/include/config/debug/virtual/console.h b/../../nrt/nautilus/include/config/debug/virtual/console.h
new file mode 100755
index 0000000..d5c9cc9
--- /dev/null
+++ b/../../nrt/nautilus/include/config/debug/virtual/console.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_DEBUG_VIRTUAL_CONSOLE
diff --git a/../../nrt/nautilus/include/config/enable/asserts.h b/../../nrt/nautilus/include/config/enable/asserts.h
new file mode 100755
index 0000000..6f10f30
--- /dev/null
+++ b/../../nrt/nautilus/include/config/enable/asserts.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_ENABLE_ASSERTS
diff --git a/../../nrt/nautilus/include/config/enable/stack/check.h b/../../nrt/nautilus/include/config/enable/stack/check.h
new file mode 100755
index 0000000..713dafb
--- /dev/null
+++ b/../../nrt/nautilus/include/config/enable/stack/check.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_ENABLE_STACK_CHECK
diff --git a/../../nrt/nautilus/include/config/fpu/save.h b/../../nrt/nautilus/include/config/fpu/save.h
new file mode 100755
index 0000000..6728556
--- /dev/null
+++ b/../../nrt/nautilus/include/config/fpu/save.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_FPU_SAVE 1
diff --git a/../../nrt/nautilus/include/config/halt/while/idle.h b/../../nrt/nautilus/include/config/halt/while/idle.h
new file mode 100755
index 0000000..0415b63
--- /dev/null
+++ b/../../nrt/nautilus/include/config/halt/while/idle.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_HALT_WHILE_IDLE
diff --git a/../../nrt/nautilus/include/config/hpet.h b/../../nrt/nautilus/include/config/hpet.h
new file mode 100755
index 0000000..ef70aaf
--- /dev/null
+++ b/../../nrt/nautilus/include/config/hpet.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_HPET
diff --git a/../../nrt/nautilus/include/config/hvm/hrt.h b/../../nrt/nautilus/include/config/hvm/hrt.h
new file mode 100755
index 0000000..ef047ea
--- /dev/null
+++ b/../../nrt/nautilus/include/config/hvm/hrt.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_HVM_HRT
diff --git a/../../nrt/nautilus/include/config/hz.h b/../../nrt/nautilus/include/config/hz.h
new file mode 100755
index 0000000..0e8bd4c
--- /dev/null
+++ b/../../nrt/nautilus/include/config/hz.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_HZ 10
diff --git a/../../nrt/nautilus/include/config/kick/schedule.h b/../../nrt/nautilus/include/config/kick/schedule.h
new file mode 100755
index 0000000..7f218da
--- /dev/null
+++ b/../../nrt/nautilus/include/config/kick/schedule.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_KICK_SCHEDULE
diff --git a/../../nrt/nautilus/include/config/legion/rt.h b/../../nrt/nautilus/include/config/legion/rt.h
new file mode 100755
index 0000000..ee6c70d
--- /dev/null
+++ b/../../nrt/nautilus/include/config/legion/rt.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_LEGION_RT
diff --git a/../../nrt/nautilus/include/config/max/cpus.h b/../../nrt/nautilus/include/config/max/cpus.h
new file mode 100755
index 0000000..43a1619
--- /dev/null
+++ b/../../nrt/nautilus/include/config/max/cpus.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_MAX_CPUS 256
diff --git a/../../nrt/nautilus/include/config/max/ioapics.h b/../../nrt/nautilus/include/config/max/ioapics.h
new file mode 100755
index 0000000..805949f
--- /dev/null
+++ b/../../nrt/nautilus/include/config/max/ioapics.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_MAX_IOAPICS 16
diff --git a/../../nrt/nautilus/include/config/ndpc/rt.h b/../../nrt/nautilus/include/config/ndpc/rt.h
new file mode 100755
index 0000000..20e74e1
--- /dev/null
+++ b/../../nrt/nautilus/include/config/ndpc/rt.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_NDPC_RT
diff --git a/../../nrt/nautilus/include/config/nesl/rt.h b/../../nrt/nautilus/include/config/nesl/rt.h
new file mode 100755
index 0000000..9c7a383
--- /dev/null
+++ b/../../nrt/nautilus/include/config/nesl/rt.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_NESL_RT
diff --git a/../../nrt/nautilus/include/config/no/rt.h b/../../nrt/nautilus/include/config/no/rt.h
new file mode 100755
index 0000000..c7b6351
--- /dev/null
+++ b/../../nrt/nautilus/include/config/no/rt.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_NO_RT 1
diff --git a/../../nrt/nautilus/include/config/palacios.h b/../../nrt/nautilus/include/config/palacios.h
new file mode 100755
index 0000000..f8ecccf
--- /dev/null
+++ b/../../nrt/nautilus/include/config/palacios.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_PALACIOS
diff --git a/../../nrt/nautilus/include/config/profile.h b/../../nrt/nautilus/include/config/profile.h
new file mode 100755
index 0000000..8393920
--- /dev/null
+++ b/../../nrt/nautilus/include/config/profile.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_PROFILE
diff --git a/../../nrt/nautilus/include/config/rt/debug.h b/../../nrt/nautilus/include/config/rt/debug.h
new file mode 100755
index 0000000..1b9e7bf
--- /dev/null
+++ b/../../nrt/nautilus/include/config/rt/debug.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_RT_DEBUG 1
diff --git a/../../nrt/nautilus/include/config/serial/port.h b/../../nrt/nautilus/include/config/serial/port.h
new file mode 100755
index 0000000..9fdd4fb
--- /dev/null
+++ b/../../nrt/nautilus/include/config/serial/port.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_SERIAL_PORT 1
diff --git a/../../nrt/nautilus/include/config/serial/redirect.h b/../../nrt/nautilus/include/config/serial/redirect.h
new file mode 100755
index 0000000..911f3c5
--- /dev/null
+++ b/../../nrt/nautilus/include/config/serial/redirect.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_SERIAL_REDIRECT 1
diff --git a/../../nrt/nautilus/include/config/silence/undef/err.h b/../../nrt/nautilus/include/config/silence/undef/err.h
new file mode 100755
index 0000000..bcae6cc
--- /dev/null
+++ b/../../nrt/nautilus/include/config/silence/undef/err.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_SILENCE_UNDEF_ERR
diff --git a/../../nrt/nautilus/include/config/thread/exit/keycode.h b/../../nrt/nautilus/include/config/thread/exit/keycode.h
new file mode 100755
index 0000000..094e82e
--- /dev/null
+++ b/../../nrt/nautilus/include/config/thread/exit/keycode.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_THREAD_EXIT_KEYCODE 196
diff --git a/../../nrt/nautilus/include/config/thread/optimize.h b/../../nrt/nautilus/include/config/thread/optimize.h
new file mode 100755
index 0000000..6602fd6
--- /dev/null
+++ b/../../nrt/nautilus/include/config/thread/optimize.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_THREAD_OPTIMIZE
diff --git a/../../nrt/nautilus/include/config/toolchain/root.h b/../../nrt/nautilus/include/config/toolchain/root.h
new file mode 100755
index 0000000..7f1af81
--- /dev/null
+++ b/../../nrt/nautilus/include/config/toolchain/root.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_TOOLCHAIN_ROOT ""
diff --git a/../../nrt/nautilus/include/config/use/idle/threads.h b/../../nrt/nautilus/include/config/use/idle/threads.h
new file mode 100755
index 0000000..80206cf
--- /dev/null
+++ b/../../nrt/nautilus/include/config/use/idle/threads.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_USE_IDLE_THREADS
diff --git a/../../nrt/nautilus/include/config/use/naut/builtins.h b/../../nrt/nautilus/include/config/use/naut/builtins.h
new file mode 100755
index 0000000..8c7e355
--- /dev/null
+++ b/../../nrt/nautilus/include/config/use/naut/builtins.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_USE_NAUT_BUILTINS 1
diff --git a/../../nrt/nautilus/include/config/use/rt/scheduler.h b/../../nrt/nautilus/include/config/use/rt/scheduler.h
new file mode 100755
index 0000000..d18df1f
--- /dev/null
+++ b/../../nrt/nautilus/include/config/use/rt/scheduler.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_USE_RT_SCHEDULER 1
diff --git a/../../nrt/nautilus/include/config/use/ticketlocks.h b/../../nrt/nautilus/include/config/use/ticketlocks.h
new file mode 100755
index 0000000..6ee82ca
--- /dev/null
+++ b/../../nrt/nautilus/include/config/use/ticketlocks.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_USE_TICKETLOCKS
diff --git a/../../nrt/nautilus/include/config/virtio/pci.h b/../../nrt/nautilus/include/config/virtio/pci.h
new file mode 100755
index 0000000..616a2d0
--- /dev/null
+++ b/../../nrt/nautilus/include/config/virtio/pci.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_VIRTIO_PCI
diff --git a/../../nrt/nautilus/include/config/virtual/console/serial/mirror/all.h b/../../nrt/nautilus/include/config/virtual/console/serial/mirror/all.h
new file mode 100755
index 0000000..ba3d482
--- /dev/null
+++ b/../../nrt/nautilus/include/config/virtual/console/serial/mirror/all.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR_ALL 1
diff --git a/../../nrt/nautilus/include/config/virtual/console/serial/mirror.h b/../../nrt/nautilus/include/config/virtual/console/serial/mirror.h
new file mode 100755
index 0000000..b315fc2
--- /dev/null
+++ b/../../nrt/nautilus/include/config/virtual/console/serial/mirror.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR 1
diff --git a/../../nrt/nautilus/include/config/x86/64/host.h b/../../nrt/nautilus/include/config/x86/64/host.h
new file mode 100755
index 0000000..462e354
--- /dev/null
+++ b/../../nrt/nautilus/include/config/x86/64/host.h
@@ -0,0 +1 @@
+#define NAUT_CONFIG_X86_64_HOST 1
diff --git a/../../nrt/nautilus/include/config/xeon/phi.h b/../../nrt/nautilus/include/config/xeon/phi.h
new file mode 100755
index 0000000..a54b92e
--- /dev/null
+++ b/../../nrt/nautilus/include/config/xeon/phi.h
@@ -0,0 +1 @@
+#undef NAUT_CONFIG_XEON_PHI
diff --git a/./include/dev/apic.h b/../../nrt/nautilus/include/dev/apic.h
old mode 100644
new mode 100755
index e38db5b..9d61d0b
--- a/./include/dev/apic.h
+++ b/../../nrt/nautilus/include/dev/apic.h
@@ -196,6 +196,8 @@ struct apic_dev {
     uint_t   id;
     uint64_t spur_int_cnt;
     uint64_t err_int_cnt;
+    uint64_t scale;
+    uint64_t frequency;
 };
 
 
@@ -207,6 +209,10 @@ apic_write (struct apic_dev * apic,
 {
     *((volatile uint32_t *)(apic->base_addr + reg)) = val;
 }
+    
+inline void apic_oneshot_write(struct apic_dev *apic, uint64_t time);
+
+void calibrate_apic(struct apic_dev *apic);
 
 
 static inline uint32_t
diff --git a/./include/dev/hpet.h b/../../nrt/nautilus/include/dev/hpet.h
old mode 100644
new mode 100755
diff --git a/./include/dev/i8254.h b/../../nrt/nautilus/include/dev/i8254.h
old mode 100644
new mode 100755
diff --git a/./include/dev/ioapic.h b/../../nrt/nautilus/include/dev/ioapic.h
old mode 100644
new mode 100755
diff --git a/./include/dev/kbd.h b/../../nrt/nautilus/include/dev/kbd.h
old mode 100644
new mode 100755
diff --git a/./include/dev/pci.h b/../../nrt/nautilus/include/dev/pci.h
old mode 100644
new mode 100755
diff --git a/./include/dev/serial.h b/../../nrt/nautilus/include/dev/serial.h
old mode 100644
new mode 100755
diff --git a/./include/dev/timer.h b/../../nrt/nautilus/include/dev/timer.h
old mode 100644
new mode 100755
diff --git a/./include/dev/vga.h b/../../nrt/nautilus/include/dev/vga.h
old mode 100644
new mode 100755
diff --git a/./include/dev/virtio_pci.h b/../../nrt/nautilus/include/dev/virtio_pci.h
old mode 100644
new mode 100755
diff --git a/./include/lib/bitmap.h b/../../nrt/nautilus/include/lib/bitmap.h
old mode 100644
new mode 100755
diff --git a/./include/lib/bitops.h b/../../nrt/nautilus/include/lib/bitops.h
old mode 100644
new mode 100755
diff --git a/./include/lib/linux_bitops.h b/../../nrt/nautilus/include/lib/linux_bitops.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/acpi-x86_64.h b/../../nrt/nautilus/include/nautilus/acpi-x86_64.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/acpi.h b/../../nrt/nautilus/include/nautilus/acpi.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/atomic.h b/../../nrt/nautilus/include/nautilus/atomic.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/backtrace.h b/../../nrt/nautilus/include/nautilus/backtrace.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/barrier.h b/../../nrt/nautilus/include/nautilus/barrier.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/bits.h b/../../nrt/nautilus/include/nautilus/bits.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/buddy.h b/../../nrt/nautilus/include/nautilus/buddy.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/bug.h b/../../nrt/nautilus/include/nautilus/bug.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/condvar.h b/../../nrt/nautilus/include/nautilus/condvar.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/cpu.h b/../../nrt/nautilus/include/nautilus/cpu.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/cpuid.h b/../../nrt/nautilus/include/nautilus/cpuid.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/cxxglue.h b/../../nrt/nautilus/include/nautilus/cxxglue.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/doprnt.h b/../../nrt/nautilus/include/nautilus/doprnt.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/errno.h b/../../nrt/nautilus/include/nautilus/errno.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/fmtout.h b/../../nrt/nautilus/include/nautilus/fmtout.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/fpu.h b/../../nrt/nautilus/include/nautilus/fpu.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/gdt.h b/../../nrt/nautilus/include/nautilus/gdt.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/hashtable.h b/../../nrt/nautilus/include/nautilus/hashtable.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/idle.h b/../../nrt/nautilus/include/nautilus/idle.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/idt.h b/../../nrt/nautilus/include/nautilus/idt.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/instrument.h b/../../nrt/nautilus/include/nautilus/instrument.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/intrinsics.h b/../../nrt/nautilus/include/nautilus/intrinsics.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/irq.h b/../../nrt/nautilus/include/nautilus/irq.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/libccompat.h b/../../nrt/nautilus/include/nautilus/libccompat.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/limits.h b/../../nrt/nautilus/include/nautilus/limits.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/list.h b/../../nrt/nautilus/include/nautilus/list.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/macros.h b/../../nrt/nautilus/include/nautilus/macros.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/math.h b/../../nrt/nautilus/include/nautilus/math.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/mb_utils.h b/../../nrt/nautilus/include/nautilus/mb_utils.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/mcslock.h b/../../nrt/nautilus/include/nautilus/mcslock.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/mm.h b/../../nrt/nautilus/include/nautilus/mm.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/msr.h b/../../nrt/nautilus/include/nautilus/msr.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/multiboot2.h b/../../nrt/nautilus/include/nautilus/multiboot2.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/mwait.h b/../../nrt/nautilus/include/nautilus/mwait.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/naut_assert.h b/../../nrt/nautilus/include/nautilus/naut_assert.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/naut_string.h b/../../nrt/nautilus/include/nautilus/naut_string.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/naut_types.h b/../../nrt/nautilus/include/nautilus/naut_types.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/nautilus.h b/../../nrt/nautilus/include/nautilus/nautilus.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/nemo.h b/../../nrt/nautilus/include/nautilus/nemo.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/numa.h b/../../nrt/nautilus/include/nautilus/numa.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/paging.h b/../../nrt/nautilus/include/nautilus/paging.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/percpu.h b/../../nrt/nautilus/include/nautilus/percpu.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/pmc.h b/../../nrt/nautilus/include/nautilus/pmc.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/printk.h b/../../nrt/nautilus/include/nautilus/printk.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/queue.h b/../../nrt/nautilus/include/nautilus/queue.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/random.h b/../../nrt/nautilus/include/nautilus/random.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/rbtree.h b/../../nrt/nautilus/include/nautilus/rbtree.h
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/include/nautilus/rt_scheduler.h b/../../nrt/nautilus/include/nautilus/rt_scheduler.h
new file mode 100755
index 0000000..96cceab
--- /dev/null
+++ b/../../nrt/nautilus/include/nautilus/rt_scheduler.h
@@ -0,0 +1,128 @@
+//
+//  rt_scheduler.h
+//  rt_scheduler_test
+//
+//  Created by Chris Beauchene on 2/15/16.
+//  Copyright  2016 EECS 395/495 Kernel Development. All rights reserved.
+//
+
+#ifndef rt_scheduler_h
+#define rt_scheduler_h
+
+#include <nautilus/thread.h>
+
+struct periodic_constraints {
+    uint64_t period, slice;
+};
+
+struct sporadic_constraints {
+    uint64_t work;
+};
+
+struct aperiodic_constraints {
+    uint64_t priority;
+};
+
+typedef union rt_constraints {
+    struct periodic_constraints     periodic;
+    struct sporadic_constraints     sporadic;
+    struct aperiodic_constraints    aperiodic;
+} rt_constraints;
+
+typedef enum { APERIODIC = 0, SPORADIC = 1, PERIODIC = 2} rt_type;
+typedef enum { RUNNABLE_QUEUE = 0, PENDING_QUEUE = 1, APERIODIC_QUEUE = 2} queue_type;
+typedef enum { ARRIVED = 0, ADMITTED = 1, TOBO_REMOVED = 2, REMOVED = 3, SLEEPING = 4, DENIED = 5} rt_status;
+
+struct rt_thread;
+
+typedef struct rt_node {
+    struct rt_thread *thread;
+    struct rt_node *next;
+    struct rt_node *prev;
+} rt_node;
+
+typedef struct rt_list {
+    rt_node *head;
+    rt_node *tail;
+} rt_list;
+
+typedef struct rt_thread {
+    rt_type type;
+    queue_type q_type;
+    rt_status status;
+    rt_constraints *constraints;
+    uint64_t start_time; 
+    uint64_t run_time;
+    uint64_t deadline;
+    uint64_t exit_time;
+    struct nk_thread *thread;
+
+    rt_list *holding;
+    rt_list *waiting;
+
+    struct rt_thread *parent;
+    rt_list *children;
+
+} rt_thread;
+
+rt_thread* rt_thread_init(int type,
+                          rt_constraints *constraints,
+                          uint64_t deadline,
+                          struct nk_thread *thread
+                          );
+
+typedef struct rt_queue {
+    queue_type type;
+    uint64_t size;
+    rt_thread *threads[0];
+} rt_queue ;
+
+typedef struct tsc_info {
+    uint64_t set_time;
+    uint64_t start_time;
+    uint64_t end_time;
+    uint64_t elapsed_time;
+    uint64_t error;
+} tsc_info;
+
+typedef struct rt_scheduler {
+    rt_queue *runnable;
+    rt_queue *pending;
+    rt_queue *aperiodic;
+
+    rt_list *sleeping;
+    rt_list *arrival;
+    rt_list *exited;
+
+    rt_thread *main_thread;
+    uint64_t run_time;
+    tsc_info *tsc;
+} rt_scheduler;
+
+rt_scheduler* rt_scheduler_init(rt_thread *main_thread);
+struct nk_thread* rt_need_resched();
+void rt_start(uint64_t sched_slice_time, uint64_t sched_period);
+
+void enqueue_thread(rt_queue *queue, rt_thread *thread);
+rt_thread* dequeue_thread(rt_queue *queue);
+
+void rt_thread_dump(rt_thread *thread);
+
+uint64_t cur_time();
+
+
+int rt_admit(rt_scheduler *scheduler, rt_thread *thread);
+void wait_on(rt_thread *A, rt_thread *B);
+void wake_up(rt_thread *A, rt_thread *B);
+void wake_up_all(rt_thread *A);
+void list_enqueue(rt_list *l, rt_thread *t);
+
+rt_thread* list_dequeue(rt_list *l);
+rt_thread* list_remove(rt_list *l, rt_thread *t);
+rt_thread* remove_thread(rt_thread *thread);
+void rt_thread_exit(rt_thread *thread);
+int rt_list_empty(rt_list *l);
+
+
+
+#endif /* rt_scheduler_h */
diff --git a/./include/nautilus/rwlock.h b/../../nrt/nautilus/include/nautilus/rwlock.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/sfi.h b/../../nrt/nautilus/include/nautilus/sfi.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/shutdown.h b/../../nrt/nautilus/include/nautilus/shutdown.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/smp.h b/../../nrt/nautilus/include/nautilus/smp.h
old mode 100644
new mode 100755
index 9b06fb6..659202f
--- a/./include/nautilus/smp.h
+++ b/../../nrt/nautilus/include/nautilus/smp.h
@@ -50,6 +50,11 @@ struct nk_cpu_coords;
 
 struct nk_queue;
 struct nk_thread;
+    
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+    struct rt_scheduler;
+    typedef struct rt_scheduler rt_scheduler;
+#endif
 
 //typedef struct nk_queue nk_thread_queue_t;
 //typedef struct nk_thread nk_thread_t;
@@ -109,6 +114,11 @@ struct cpu {
 #ifdef NAUT_CONFIG_PROFILE
     struct nk_instr_data * instr_data;
 #endif
+    
+    
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+    rt_scheduler *rt_sched;
+#endif
 };
 
 
diff --git a/./include/nautilus/spinlock.h b/../../nrt/nautilus/include/nautilus/spinlock.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/thread.h b/../../nrt/nautilus/include/nautilus/thread.h
old mode 100644
new mode 100755
index df30d75..e6f42e2
--- a/./include/nautilus/thread.h
+++ b/../../nrt/nautilus/include/nautilus/thread.h
@@ -1,17 +1,17 @@
-/* 
+/*
  * This file is part of the Nautilus AeroKernel developed
- * by the Hobbes and V3VEE Projects with funding from the 
- * United States National  Science Foundation and the Department of Energy.  
+ * by the Hobbes and V3VEE Projects with funding from the
+ * United States National  Science Foundation and the Department of Energy.
  *
  * The V3VEE Project is a joint project between Northwestern University
  * and the University of New Mexico.  The Hobbes Project is a collaboration
- * led by Sandia National Laboratories that includes several national 
+ * led by Sandia National Laboratories that includes several national
  * laboratories and universities. You can find out more at:
  * http://www.v3vee.org  and
  * http://xtack.sandia.gov/hobbes
  *
  * Copyright (c) 2015, Kyle C. Hale <kh@u.northwestern.edu>
- * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org> 
+ * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org>
  *                     The Hobbes Project <http://xstack.sandia.gov/hobbes>
  * All rights reserved.
  *
@@ -26,228 +26,265 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
-
+    
 #ifndef __ASSEMBLER__
-
+    
 #include <nautilus/spinlock.h>
 #include <nautilus/queue.h>
 #include <nautilus/intrinsics.h>
-
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+#include <nautilus/rt_scheduler.h>
+#endif
+    
 #define CPU_ANY       -1
-
-/* common thread stack sizes */
+    
+    /* common thread stack sizes */
 #define TSTACK_DEFAULT 0  // will be 4K
 #define TSTACK_4KB     0x001000
 #define TSTACK_1MB     0x100000
 #define TSTACK_2MB     0x200000
-
-/******** EXTERNAL INTERFACE **********/
-
-// opaque pointer given to users
-typedef void* nk_thread_id_t;
-typedef void (*nk_thread_fun_t)(void * input, void ** output);
-typedef uint64_t nk_stack_size_t;
-
-
-int
-nk_thread_create (nk_thread_fun_t fun, 
-                 void * input,
-                 void ** output,
-                 uint8_t is_detached,
-                 nk_stack_size_t stack_size,
-                 nk_thread_id_t * tid,
-                 int cpu);
-
-int
-nk_thread_run(nk_thread_id_t tid);
-
-int
-nk_thread_start (nk_thread_fun_t fun, 
-                 void * input,
-                 void ** output,
-                 uint8_t is_detached,
-                 nk_stack_size_t stack_size,
-                 nk_thread_id_t * tid,
-                 int cpu);
-
-extern nk_thread_id_t nk_thread_fork(void);
-
-void nk_set_thread_fork_output(void * result);
-void nk_yield(void);
-void nk_thread_exit(void * retval);
-void nk_thread_destroy(nk_thread_id_t t); /* like thread_kill */
-void nk_wait(nk_thread_id_t t);
-
-void nk_wake_waiters(void);
-int nk_join(nk_thread_id_t t, void ** retval);
-int nk_join_all_children(int (*)(void*));
-
+    
+    /******** EXTERNAL INTERFACE **********/
+    
+    // opaque pointer given to users
+    typedef void* nk_thread_id_t;
+    typedef void (*nk_thread_fun_t)(void * input, void ** output);
+    typedef uint64_t nk_stack_size_t;
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+    typedef struct rt_thread rt_thread;
+    typedef struct rt_scheduler rt_scheduler;
+    typedef union rt_constraints rt_constraints;
+#endif
+    int
+    nk_thread_create (nk_thread_fun_t fun,
+                      void * input,
+                      void ** output,
+                      uint8_t is_detached,
+                      nk_stack_size_t stack_size,
+                      nk_thread_id_t * tid,
+                      int cpu);
+    
+    int
+    nk_thread_run(nk_thread_id_t tid);
+    
+#ifndef NAUT_CONFIG_USE_RT_SCHEDULER
+    int
+    nk_thread_start (nk_thread_fun_t fun,
+                     void * input,
+                     void ** output,
+                     uint8_t is_detached,
+                     nk_stack_size_t stack_size,
+                     nk_thread_id_t * tid,
+                     int cpu);
+#else
+    int nk_thread_start(nk_thread_fun_t fun,
+                        void * input,
+                        void ** output,
+                        uint8_t is_detached,
+                        nk_stack_size_t stack_size,
+                        nk_thread_id_t * tid,
+                        int cpu,
+                        int rt_type,
+                        rt_constraints *rt_constraints,
+                        uint64_t rt_deadline);
+#endif
+    extern nk_thread_id_t nk_thread_fork(void);
+    
+    void nk_set_thread_fork_output(void * result);
+    void nk_yield(void);
+    void nk_thread_exit(void * retval);
+    void nk_thread_destroy(nk_thread_id_t t); /* like thread_kill */
+    void nk_wait(nk_thread_id_t t);
+    
+    void nk_wake_waiters(void);
+    int nk_join(nk_thread_id_t t, void ** retval);
+    int nk_join_all_children(int (*)(void*));
+    
 #ifndef __LEGION__
-nk_thread_id_t nk_get_tid(void);
+    nk_thread_id_t nk_get_tid(void);
 #endif
-nk_thread_id_t nk_get_parent_tid(void);
-
-/* thread local storage */
-typedef unsigned int nk_tls_key_t; 
-int nk_tls_key_create(nk_tls_key_t * key, void (*destructor)(void*));
-int nk_tls_key_delete(nk_tls_key_t key);
-void* nk_tls_get(nk_tls_key_t key);
-int nk_tls_set(nk_tls_key_t key, const void * val);
-
-
-/********* INTERNALS ***********/
-
+    nk_thread_id_t nk_get_parent_tid(void);
+    
+    /* thread local storage */
+    typedef unsigned int nk_tls_key_t;
+    int nk_tls_key_create(nk_tls_key_t * key, void (*destructor)(void*));
+    int nk_tls_key_delete(nk_tls_key_t key);
+    void* nk_tls_get(nk_tls_key_t key);
+    int nk_tls_set(nk_tls_key_t key, const void * val);
+    
+    
+    /********* INTERNALS ***********/
+    
 #define FXSAVE_SIZE 512
-
-
-/* FOR TLS */
+    
+    
+    /* FOR TLS */
 #define TLS_MAX_KEYS 256
 #define MIN_DESTRUCT_ITER 4
 #define TLS_KEY_AVAIL(x) (((x) & 1) == 0)
 #define TLS_KEY_USABLE(x) ((unsigned long)(x) < (unsigned long)((x)+2))
+    
+    
+    /* thread status */
+    typedef enum {
+        NK_THR_INIT,
+        NK_THR_RUNNING,
+        NK_THR_WAITING,
+        NK_THR_SUSPENDED,
+        NK_THR_EXITED
+    } nk_thread_status_t;
+    
+    typedef struct nk_queue nk_thread_queue_t;
+    
+    struct nk_thread {
+        uint64_t rsp; /* SHOULD NOT CHANGE POSITION */
+        void * stack; /* SHOULD NOT CHANGE POSITION */
+        uint16_t fpu_state_offset; /* SHOULD NOT CHANGE POSITION */
+        
+        nk_stack_size_t stack_size;
+        unsigned long tid;
+        
+        int lock;
+        
+        nk_queue_entry_t runq_node; // formerly q_node
+        nk_queue_entry_t thr_list_node;
+        
+        /* parent/child relationship */
+        struct nk_thread * parent;
+        struct list_head children;
+        struct list_head child_node;
+        unsigned long refcount;
+        
+        nk_thread_queue_t * waitq;
+        nk_queue_entry_t wait_node;
+        
+        nk_thread_queue_t * cur_run_q;
+        
+        /* thread state */
+        nk_thread_status_t status;
+        
+        int bound_cpu;
+        
+        uint8_t is_idle;
+        
+        void * output;
+        void * input;
+        nk_thread_fun_t fun;
+        
+        struct nk_virtual_console *vc;
+        
+        const void * tls[TLS_MAX_KEYS];
+        
+        uint8_t fpu_state[FXSAVE_SIZE] __align(16);
+        
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+        rt_thread *rt_thread;
+#endif
+    } __packed;
+    
+    // internal thread representations
+    typedef struct nk_thread nk_thread_t;
+    
+    struct nk_sched_state {
+        nk_thread_queue_t * thread_list;
+        uint_t num_threads;
+    };
+    
+    
+    nk_thread_id_t __thread_fork(void);
+    nk_thread_t* nk_need_resched(void);
+    int nk_sched_init(void);
+    int nk_sched_init_ap(void);
+    int nk_thread_start_sim (nk_thread_fun_t fun,
+                 void *input,
+                 void **output,
+                 uint8_t is_detached,
+                 nk_stack_size_t stack_size,
+                 nk_thread_id_t *tid,
+                 int cpu,
+                 int rt_type,
+                 rt_constraints *rt_constraints,
+                 uint64_t rt_deadline);
+    
+    void nk_schedule(void);
+    
+    
+    /* thread queues */
+    
+    nk_thread_queue_t * nk_thread_queue_create (void);
+    void nk_thread_queue_destroy(nk_thread_queue_t * q);
+    inline void nk_enqueue_thread_on_runq(nk_thread_t * t, int cpu);
+    inline nk_thread_t* nk_dequeue_thread_from_runq(nk_thread_t * t);
+    int nk_thread_queue_sleep(nk_thread_queue_t * q);
+
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+    int sleep_on_queue(rt_thread *sleep);
+#endif
 
-
-/* thread status */
-typedef enum {
-    NK_THR_INIT,
-    NK_THR_RUNNING, 
-    NK_THR_WAITING,
-    NK_THR_SUSPENDED, 
-    NK_THR_EXITED
-} nk_thread_status_t;
-
-typedef struct nk_queue nk_thread_queue_t;
-
-struct nk_thread {
-    uint64_t rsp; /* SHOULD NOT CHANGE POSITION */
-    void * stack; /* SHOULD NOT CHANGE POSITION */
-    uint16_t fpu_state_offset; /* SHOULD NOT CHANGE POSITION */
-
-    nk_stack_size_t stack_size;
-    unsigned long tid;
-
-    int lock;
-
-    nk_queue_entry_t runq_node; // formerly q_node
-    nk_queue_entry_t thr_list_node;
-
-    /* parent/child relationship */
-    struct nk_thread * parent;
-    struct list_head children;
-    struct list_head child_node;
-    unsigned long refcount;
-
-    nk_thread_queue_t * waitq;
-    nk_queue_entry_t wait_node;
-
-    nk_thread_queue_t * cur_run_q;
-
-    /* thread state */
-    nk_thread_status_t status;
-
-    int bound_cpu;
-
-    uint8_t is_idle;
-
-    void * output;
-    void * input;
-    nk_thread_fun_t fun;
-
-    struct nk_virtual_console *vc;
-
-    const void * tls[TLS_MAX_KEYS];
-
-    uint8_t fpu_state[FXSAVE_SIZE] __align(16);
-} __packed;
-
-// internal thread representations
-typedef struct nk_thread nk_thread_t;
-
-struct nk_sched_state {
-    nk_thread_queue_t * thread_list;
-    uint_t num_threads;
-};
-
-
-
-nk_thread_id_t __thread_fork(void);
-nk_thread_t* nk_need_resched(void);
-int nk_sched_init(void);
-int nk_sched_init_ap(void);
-
-void nk_schedule(void);
-
-
-/* thread queues */
-
-nk_thread_queue_t * nk_thread_queue_create (void);
-void nk_thread_queue_destroy(nk_thread_queue_t * q);
-inline void nk_enqueue_thread_on_runq(nk_thread_t * t, int cpu);
-inline nk_thread_t* nk_dequeue_thread_from_runq(nk_thread_t * t);
-int nk_thread_queue_sleep(nk_thread_queue_t * q);
-int nk_thread_queue_wake_one(nk_thread_queue_t * q);
-int nk_thread_queue_wake_all(nk_thread_queue_t * q);
-
-struct nk_tls {
-    unsigned seq_num;
-    void (*destructor)(void*);
-};
-
-void nk_tls_test(void);
-
+    int nk_thread_queue_wake_one(nk_thread_queue_t * q);
+    int nk_thread_queue_wake_all(nk_thread_queue_t * q);
+    
+    struct nk_tls {
+        unsigned seq_num;
+        void (*destructor)(void*);
+    };
+    
+    void nk_tls_test(void);
+    
 #include <nautilus/percpu.h>
-
-static inline nk_thread_t*
-get_cur_thread (void)
-{
-    return (nk_thread_t*)per_cpu_get(cur_thread);
-}
-
-static inline void
-put_cur_thread (nk_thread_t * t) 
-{
-    per_cpu_put(cur_thread, t);
-}
-
-
+    
+    static inline nk_thread_t*
+    get_cur_thread (void)
+    {
+        return (nk_thread_t*)per_cpu_get(cur_thread);
+    }
+    
+    static inline void
+    put_cur_thread (nk_thread_t * t)
+    {
+        per_cpu_put(cur_thread, t);
+    }
+    
+    
+    
 #endif /* !__ASSEMBLER */
-
+    
 #define SAVE_GPRS() \
-    movq %rax, -8(%rsp); \
-    movq %rbx, -16(%rsp); \
-    movq %rcx, -24(%rsp); \
-    movq %rdx, -32(%rsp); \
-    movq %rsi, -40(%rsp); \
-    movq %rdi, -48(%rsp); \
-    movq %rbp, -56(%rsp); \
-    movq %r8,  -64(%rsp); \
-    movq %r9,  -72(%rsp); \
-    movq %r10, -80(%rsp); \
-    movq %r11, -88(%rsp); \
-    movq %r12, -96(%rsp); \
-    movq %r13, -104(%rsp); \
-    movq %r14, -112(%rsp); \
-    movq %r15, -120(%rsp); \
-    subq $120, %rsp; 
-
+movq %rax, -8(%rsp); \
+movq %rbx, -16(%rsp); \
+movq %rcx, -24(%rsp); \
+movq %rdx, -32(%rsp); \
+movq %rsi, -40(%rsp); \
+movq %rdi, -48(%rsp); \
+movq %rbp, -56(%rsp); \
+movq %r8,  -64(%rsp); \
+movq %r9,  -72(%rsp); \
+movq %r10, -80(%rsp); \
+movq %r11, -88(%rsp); \
+movq %r12, -96(%rsp); \
+movq %r13, -104(%rsp); \
+movq %r14, -112(%rsp); \
+movq %r15, -120(%rsp); \
+subq $120, %rsp; 
+    
 #define RESTORE_GPRS() \
-    movq (%rsp), %r15; \
-    movq 8(%rsp), %r14; \
-    movq 16(%rsp), %r13; \
-    movq 24(%rsp), %r12; \
-    movq 32(%rsp), %r11; \
-    movq 40(%rsp), %r10; \
-    movq 48(%rsp), %r9; \
-    movq 56(%rsp), %r8; \
-    movq 64(%rsp), %rbp; \
-    movq 72(%rsp), %rdi; \
-    movq 80(%rsp), %rsi; \
-    movq 88(%rsp), %rdx; \
-    movq 96(%rsp), %rcx; \
-    movq 104(%rsp), %rbx; \
-    movq 112(%rsp), %rax; \
-    addq $120, %rsp; 
-
+movq (%rsp), %r15; \
+movq 8(%rsp), %r14; \
+movq 16(%rsp), %r13; \
+movq 24(%rsp), %r12; \
+movq 32(%rsp), %r11; \
+movq 40(%rsp), %r10; \
+movq 48(%rsp), %r9; \
+movq 56(%rsp), %r8; \
+movq 64(%rsp), %rbp; \
+movq 72(%rsp), %rdi; \
+movq 80(%rsp), %rsi; \
+movq 88(%rsp), %rdx; \
+movq 96(%rsp), %rcx; \
+movq 104(%rsp), %rbx; \
+movq 112(%rsp), %rax; \
+addq $120, %rsp; 
+    
 #ifdef __cplusplus
 }
 #endif
diff --git a/./include/nautilus/ticketlock.h b/../../nrt/nautilus/include/nautilus/ticketlock.h
old mode 100644
new mode 100755
diff --git a/./include/nautilus/vc.h b/../../nrt/nautilus/include/nautilus/vc.h
old mode 100644
new mode 100755
diff --git a/./iso/boot/grub/grub.cfg b/../../nrt/nautilus/iso/boot/grub/grub.cfg
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/iso/boot/nautilus.bin b/../../nrt/nautilus/iso/boot/nautilus.bin
new file mode 100755
index 0000000..3498d08
Binary files /dev/null and b/../../nrt/nautilus/iso/boot/nautilus.bin differ
diff --git a/../../nrt/nautilus/lib/.bitmap.o.cmd b/../../nrt/nautilus/lib/.bitmap.o.cmd
new file mode 100644
index 0000000..1b420ed
--- /dev/null
+++ b/../../nrt/nautilus/lib/.bitmap.o.cmd
@@ -0,0 +1,71 @@
+cmd_lib/bitmap.o := gcc -Wp,-MD,lib/.bitmap.o.d   -D__NAUTILUS__ -Iinclude  -include include/autoconf.h -D__NAUTILUS__ -O2 -fno-omit-frame-pointer -ffreestanding -fno-stack-protector -fno-strict-aliasing -mno-red-zone -mcmodel=large -Wall -Wno-unused-function -Wno-unused-variable -fno-common -std=gnu99  -Wno-unused-but-set-variable -fgnu89-inline -g -m64  -Wno-pointer-sign    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(bitmap)"  -D"KBUILD_MODNAME=KBUILD_STR(bitmap)" -c -o lib/bitmap.o lib/bitmap.c
+
+deps_lib/bitmap.o := \
+  lib/bitmap.c \
+  include/autoconf.h \
+    $(wildcard include/config/x86/64/host.h) \
+    $(wildcard include/config/xeon/phi.h) \
+    $(wildcard include/config/hvm/hrt.h) \
+    $(wildcard include/config/max/cpus.h) \
+    $(wildcard include/config/max/ioapics.h) \
+    $(wildcard include/config/palacios.h) \
+    $(wildcard include/config/use/naut/builtins.h) \
+    $(wildcard include/config/cxx/support.h) \
+    $(wildcard include/config/toolchain/root.h) \
+    $(wildcard include/config/thread/exit/keycode.h) \
+    $(wildcard include/config/use/ticketlocks.h) \
+    $(wildcard include/config/virtual/console/serial/mirror.h) \
+    $(wildcard include/config/virtual/console/serial/mirror/all.h) \
+    $(wildcard include/config/fpu/save.h) \
+    $(wildcard include/config/kick/schedule.h) \
+    $(wildcard include/config/halt/while/idle.h) \
+    $(wildcard include/config/thread/optimize.h) \
+    $(wildcard include/config/use/idle/threads.h) \
+    $(wildcard include/config/use/rt/scheduler.h) \
+    $(wildcard include/config/debug/info.h) \
+    $(wildcard include/config/debug/prints.h) \
+    $(wildcard include/config/enable/asserts.h) \
+    $(wildcard include/config/profile.h) \
+    $(wildcard include/config/silence/undef/err.h) \
+    $(wildcard include/config/enable/stack/check.h) \
+    $(wildcard include/config/debug/paging.h) \
+    $(wildcard include/config/debug/bootmem.h) \
+    $(wildcard include/config/debug/buddy.h) \
+    $(wildcard include/config/debug/kmem.h) \
+    $(wildcard include/config/debug/fpu.h) \
+    $(wildcard include/config/debug/smp.h) \
+    $(wildcard include/config/debug/sfi.h) \
+    $(wildcard include/config/debug/cxx.h) \
+    $(wildcard include/config/debug/threads.h) \
+    $(wildcard include/config/rt/debug.h) \
+    $(wildcard include/config/debug/rt/scheduler.h) \
+    $(wildcard include/config/debug/rt/threads.h) \
+    $(wildcard include/config/debug/synch.h) \
+    $(wildcard include/config/debug/barrier.h) \
+    $(wildcard include/config/debug/numa.h) \
+    $(wildcard include/config/debug/virtual/console.h) \
+    $(wildcard include/config/legion/rt.h) \
+    $(wildcard include/config/ndpc/rt.h) \
+    $(wildcard include/config/nesl/rt.h) \
+    $(wildcard include/config/no/rt.h) \
+    $(wildcard include/config/serial/redirect.h) \
+    $(wildcard include/config/serial/port.h) \
+    $(wildcard include/config/debug/apic.h) \
+    $(wildcard include/config/debug/ioapic.h) \
+    $(wildcard include/config/debug/pci.h) \
+    $(wildcard include/config/debug/kbd.h) \
+    $(wildcard include/config/debug/timers.h) \
+    $(wildcard include/config/debug/pit.h) \
+    $(wildcard include/config/hpet.h) \
+    $(wildcard include/config/hz.h) \
+    $(wildcard include/config/virtio/pci.h) \
+  include/lib/bitmap.h \
+  include/nautilus/naut_types.h \
+  include/lib/bitops.h \
+  include/asm/bitops.h \
+  include/nautilus/intrinsics.h \
+  include/nautilus/naut_string.h \
+
+lib/bitmap.o: $(deps_lib/bitmap.o)
+
+$(deps_lib/bitmap.o):
diff --git a/../../nrt/nautilus/lib/.built-in.o.cmd b/../../nrt/nautilus/lib/.built-in.o.cmd
new file mode 100644
index 0000000..b53efc6
--- /dev/null
+++ b/../../nrt/nautilus/lib/.built-in.o.cmd
@@ -0,0 +1 @@
+cmd_lib/built-in.o :=  ld -z max-page-size=0x1000 -melf_x86_64 -dp  -r -o lib/built-in.o lib/bitmap.o
diff --git a/./lib/Makefile b/../../nrt/nautilus/lib/Makefile
old mode 100644
new mode 100755
diff --git a/./lib/bitmap.c b/../../nrt/nautilus/lib/bitmap.c
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/lib/bitmap.o b/../../nrt/nautilus/lib/bitmap.o
new file mode 100644
index 0000000..31f688d
Binary files /dev/null and b/../../nrt/nautilus/lib/bitmap.o differ
diff --git a/../../nrt/nautilus/lib/built-in.o b/../../nrt/nautilus/lib/built-in.o
new file mode 100644
index 0000000..807780a
Binary files /dev/null and b/../../nrt/nautilus/lib/built-in.o differ
diff --git a/./link/hrt.lds b/../../nrt/nautilus/link/hrt.lds
old mode 100644
new mode 100755
diff --git a/./link/nautilus.ld b/../../nrt/nautilus/link/nautilus.ld
old mode 100644
new mode 100755
diff --git a/./link/nautilus.ld.hrt b/../../nrt/nautilus/link/nautilus.ld.hrt
old mode 100644
new mode 100755
diff --git a/./link/nautilus.ld.xeon_phi b/../../nrt/nautilus/link/nautilus.ld.xeon_phi
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/reboot_machine b/../../nrt/nautilus/reboot_machine
new file mode 100755
index 0000000..d1b85c4
--- /dev/null
+++ b/../../nrt/nautilus/reboot_machine
@@ -0,0 +1 @@
+ipmitool -I lanplus -H v-test-r415-2-rsa.cs.northwestern.edu -U root -P v3vee\!\! power reset
diff --git a/./rt_diff.patch b/./rt_diff.patch
deleted file mode 100644
index c1c867b..0000000
--- a/./rt_diff.patch
+++ /dev/null
@@ -1,2429 +0,0 @@
-diff --git a/../../nrt/nautilus/.DS_Store b/../../nrt/nautilus/.DS_Store
-new file mode 100755
-index 0000000..e0d9c9e
-Binary files /dev/null and b/../../nrt/nautilus/.DS_Store differ
-diff --git a/../../nrt/nautilus/.config b/../../nrt/nautilus/.config
-new file mode 100644
-index 0000000..ca6d3c8
---- /dev/null
-+++ b/../../nrt/nautilus/.config
-@@ -0,0 +1,93 @@
-+#
-+# Automatically generated make config: don't edit
-+#Nautilus: 
-+# Fri Jun 10 14:02:58 2016
-+#
-+
-+#
-+# Platform/Arch Options
-+#
-+NAUT_CONFIG_X86_64_HOST=y
-+# NAUT_CONFIG_XEON_PHI is not set
-+# NAUT_CONFIG_HVM_HRT is not set
-+NAUT_CONFIG_MAX_CPUS=256
-+NAUT_CONFIG_MAX_IOAPICS=16
-+# NAUT_CONFIG_PALACIOS is not set
-+
-+#
-+# Nautilus AeroKernel Build Config
-+#
-+NAUT_CONFIG_USE_NAUT_BUILTINS=y
-+NAUT_CONFIG_CXX_SUPPORT=y
-+NAUT_CONFIG_TOOLCHAIN_ROOT=""
-+
-+#
-+# Interface Options
-+#
-+NAUT_CONFIG_THREAD_EXIT_KEYCODE=196
-+
-+#
-+# Nautilus AeroKernel Configuration
-+#
-+# NAUT_CONFIG_USE_TICKETLOCKS is not set
-+NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR=y
-+NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR_ALL=y
-+
-+#
-+# AeroKernel Performance Optimizations
-+#
-+NAUT_CONFIG_FPU_SAVE=y
-+# NAUT_CONFIG_KICK_SCHEDULE is not set
-+# NAUT_CONFIG_HALT_WHILE_IDLE is not set
-+# NAUT_CONFIG_THREAD_OPTIMIZE is not set
-+# NAUT_CONFIG_USE_IDLE_THREADS is not set
-+NAUT_CONFIG_USE_RT_SCHEDULER=y
-+
-+#
-+# Debugging
-+#
-+NAUT_CONFIG_DEBUG_INFO=y
-+NAUT_CONFIG_DEBUG_PRINTS=y
-+# NAUT_CONFIG_ENABLE_ASSERTS is not set
-+# NAUT_CONFIG_PROFILE is not set
-+# NAUT_CONFIG_SILENCE_UNDEF_ERR is not set
-+# NAUT_CONFIG_ENABLE_STACK_CHECK is not set
-+# NAUT_CONFIG_DEBUG_PAGING is not set
-+# NAUT_CONFIG_DEBUG_BOOTMEM is not set
-+# NAUT_CONFIG_DEBUG_BUDDY is not set
-+# NAUT_CONFIG_DEBUG_KMEM is not set
-+# NAUT_CONFIG_DEBUG_FPU is not set
-+# NAUT_CONFIG_DEBUG_SMP is not set
-+# NAUT_CONFIG_DEBUG_SFI is not set
-+# NAUT_CONFIG_DEBUG_CXX is not set
-+NAUT_CONFIG_DEBUG_THREADS=y
-+NAUT_CONFIG_RT_DEBUG=y
-+NAUT_CONFIG_DEBUG_RT_SCHEDULER=y
-+NAUT_CONFIG_DEBUG_RT_THREADS=y
-+# NAUT_CONFIG_DEBUG_SYNCH is not set
-+# NAUT_CONFIG_DEBUG_BARRIER is not set
-+# NAUT_CONFIG_DEBUG_NUMA is not set
-+# NAUT_CONFIG_DEBUG_VIRTUAL_CONSOLE is not set
-+
-+#
-+# Parallel Runtime Integration
-+#
-+# NAUT_CONFIG_LEGION_RT is not set
-+# NAUT_CONFIG_NDPC_RT is not set
-+# NAUT_CONFIG_NESL_RT is not set
-+NAUT_CONFIG_NO_RT=y
-+
-+#
-+# Device options
-+#
-+NAUT_CONFIG_SERIAL_REDIRECT=y
-+NAUT_CONFIG_SERIAL_PORT=1
-+NAUT_CONFIG_DEBUG_APIC=y
-+# NAUT_CONFIG_DEBUG_IOAPIC is not set
-+# NAUT_CONFIG_DEBUG_PCI is not set
-+# NAUT_CONFIG_DEBUG_KBD is not set
-+# NAUT_CONFIG_DEBUG_TIMERS is not set
-+# NAUT_CONFIG_DEBUG_PIT is not set
-+# NAUT_CONFIG_HPET is not set
-+NAUT_CONFIG_HZ=10
-+# NAUT_CONFIG_VIRTIO_PCI is not set
-diff --git a/../../nrt/nautilus/.config.old b/../../nrt/nautilus/.config.old
-new file mode 100644
-index 0000000..0ad3678
---- /dev/null
-+++ b/../../nrt/nautilus/.config.old
-@@ -0,0 +1,93 @@
-+#
-+# Automatically generated make config: don't edit
-+#Nautilus: 
-+# Fri Jun 10 13:57:12 2016
-+#
-+
-+#
-+# Platform/Arch Options
-+#
-+NAUT_CONFIG_X86_64_HOST=y
-+# NAUT_CONFIG_XEON_PHI is not set
-+# NAUT_CONFIG_HVM_HRT is not set
-+NAUT_CONFIG_MAX_CPUS=256
-+NAUT_CONFIG_MAX_IOAPICS=16
-+# NAUT_CONFIG_PALACIOS is not set
-+
-+#
-+# Nautilus AeroKernel Build Config
-+#
-+NAUT_CONFIG_USE_NAUT_BUILTINS=y
-+NAUT_CONFIG_CXX_SUPPORT=y
-+NAUT_CONFIG_TOOLCHAIN_ROOT=""
-+
-+#
-+# Interface Options
-+#
-+NAUT_CONFIG_THREAD_EXIT_KEYCODE=196
-+
-+#
-+# Nautilus AeroKernel Configuration
-+#
-+# NAUT_CONFIG_USE_TICKETLOCKS is not set
-+NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR=y
-+NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR_ALL=y
-+
-+#
-+# AeroKernel Performance Optimizations
-+#
-+NAUT_CONFIG_FPU_SAVE=y
-+# NAUT_CONFIG_KICK_SCHEDULE is not set
-+# NAUT_CONFIG_HALT_WHILE_IDLE is not set
-+# NAUT_CONFIG_THREAD_OPTIMIZE is not set
-+# NAUT_CONFIG_USE_IDLE_THREADS is not set
-+NAUT_CONFIG_USE_RT_SCHEDULER=y
-+
-+#
-+# Debugging
-+#
-+NAUT_CONFIG_DEBUG_INFO=y
-+NAUT_CONFIG_DEBUG_PRINTS=y
-+# NAUT_CONFIG_ENABLE_ASSERTS is not set
-+# NAUT_CONFIG_PROFILE is not set
-+# NAUT_CONFIG_SILENCE_UNDEF_ERR is not set
-+# NAUT_CONFIG_ENABLE_STACK_CHECK is not set
-+# NAUT_CONFIG_DEBUG_PAGING is not set
-+# NAUT_CONFIG_DEBUG_BOOTMEM is not set
-+# NAUT_CONFIG_DEBUG_BUDDY is not set
-+# NAUT_CONFIG_DEBUG_KMEM is not set
-+# NAUT_CONFIG_DEBUG_FPU is not set
-+# NAUT_CONFIG_DEBUG_SMP is not set
-+# NAUT_CONFIG_DEBUG_SFI is not set
-+# NAUT_CONFIG_DEBUG_CXX is not set
-+NAUT_CONFIG_DEBUG_THREADS=y
-+NAUT_CONFIG_RT_DEBUG=y
-+NAUT_CONFIG_DEBUG_RT_SCHEDULER=y
-+NAUT_CONFIG_DEBUG_RT_THREADS=y
-+# NAUT_CONFIG_DEBUG_SYNCH is not set
-+# NAUT_CONFIG_DEBUG_BARRIER is not set
-+# NAUT_CONFIG_DEBUG_NUMA is not set
-+# NAUT_CONFIG_DEBUG_VIRTUAL_CONSOLE is not set
-+
-+#
-+# Parallel Runtime Integration
-+#
-+# NAUT_CONFIG_LEGION_RT is not set
-+# NAUT_CONFIG_NDPC_RT is not set
-+# NAUT_CONFIG_NESL_RT is not set
-+NAUT_CONFIG_NO_RT=y
-+
-+#
-+# Device options
-+#
-+NAUT_CONFIG_SERIAL_REDIRECT=y
-+NAUT_CONFIG_SERIAL_PORT=1
-+NAUT_CONFIG_DEBUG_APIC=y
-+# NAUT_CONFIG_DEBUG_IOAPIC is not set
-+# NAUT_CONFIG_DEBUG_PCI is not set
-+# NAUT_CONFIG_DEBUG_KBD is not set
-+# NAUT_CONFIG_DEBUG_TIMERS is not set
-+# NAUT_CONFIG_DEBUG_PIT is not set
-+# NAUT_CONFIG_HPET is not set
-+NAUT_CONFIG_HZ=10
-+# NAUT_CONFIG_VIRTIO_PCI is not set
-diff --git a/./.git/HEAD b/./.git/HEAD
-deleted file mode 100644
-index cb089cd..0000000
---- a/./.git/HEAD
-+++ /dev/null
-@@ -1 +0,0 @@
--ref: refs/heads/master
-diff --git a/./.git/config b/./.git/config
-deleted file mode 100644
-index bf5b8e4..0000000
---- a/./.git/config
-+++ /dev/null
-@@ -1,11 +0,0 @@
--[core]
--	repositoryformatversion = 0
--	filemode = true
--	bare = false
--	logallrefupdates = true
--[remote "origin"]
--	url = https://bitbucket.org/kchale/nautilus
--	fetch = +refs/heads/*:refs/remotes/origin/*
--[branch "master"]
--	remote = origin
--	merge = refs/heads/master
-diff --git a/./.git/description b/./.git/description
-deleted file mode 100644
-index 498b267..0000000
---- a/./.git/description
-+++ /dev/null
-@@ -1 +0,0 @@
--Unnamed repository; edit this file 'description' to name the repository.
-diff --git a/./.git/hooks/applypatch-msg.sample b/./.git/hooks/applypatch-msg.sample
-deleted file mode 100755
-index 8b2a2fe..0000000
---- a/./.git/hooks/applypatch-msg.sample
-+++ /dev/null
-@@ -1,15 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to check the commit log message taken by
--# applypatch from an e-mail message.
--#
--# The hook should exit with non-zero status after issuing an
--# appropriate message if it wants to stop the commit.  The hook is
--# allowed to edit the commit message file.
--#
--# To enable this hook, rename this file to "applypatch-msg".
--
--. git-sh-setup
--test -x "$GIT_DIR/hooks/commit-msg" &&
--	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
--:
-diff --git a/./.git/hooks/commit-msg.sample b/./.git/hooks/commit-msg.sample
-deleted file mode 100755
-index b58d118..0000000
---- a/./.git/hooks/commit-msg.sample
-+++ /dev/null
-@@ -1,24 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to check the commit log message.
--# Called by "git commit" with one argument, the name of the file
--# that has the commit message.  The hook should exit with non-zero
--# status after issuing an appropriate message if it wants to stop the
--# commit.  The hook is allowed to edit the commit message file.
--#
--# To enable this hook, rename this file to "commit-msg".
--
--# Uncomment the below to add a Signed-off-by line to the message.
--# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
--# hook is more suited to it.
--#
--# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
--# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
--
--# This example catches duplicate Signed-off-by lines.
--
--test "" = "$(grep '^Signed-off-by: ' "$1" |
--	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
--	echo >&2 Duplicate Signed-off-by lines.
--	exit 1
--}
-diff --git a/./.git/hooks/post-update.sample b/./.git/hooks/post-update.sample
-deleted file mode 100755
-index ec17ec1..0000000
---- a/./.git/hooks/post-update.sample
-+++ /dev/null
-@@ -1,8 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to prepare a packed repository for use over
--# dumb transports.
--#
--# To enable this hook, rename this file to "post-update".
--
--exec git update-server-info
-diff --git a/./.git/hooks/pre-applypatch.sample b/./.git/hooks/pre-applypatch.sample
-deleted file mode 100755
-index b1f187c..0000000
---- a/./.git/hooks/pre-applypatch.sample
-+++ /dev/null
-@@ -1,14 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to verify what is about to be committed
--# by applypatch from an e-mail message.
--#
--# The hook should exit with non-zero status after issuing an
--# appropriate message if it wants to stop the commit.
--#
--# To enable this hook, rename this file to "pre-applypatch".
--
--. git-sh-setup
--test -x "$GIT_DIR/hooks/pre-commit" &&
--	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
--:
-diff --git a/./.git/hooks/pre-commit.sample b/./.git/hooks/pre-commit.sample
-deleted file mode 100755
-index 68d62d5..0000000
---- a/./.git/hooks/pre-commit.sample
-+++ /dev/null
-@@ -1,49 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to verify what is about to be committed.
--# Called by "git commit" with no arguments.  The hook should
--# exit with non-zero status after issuing an appropriate message if
--# it wants to stop the commit.
--#
--# To enable this hook, rename this file to "pre-commit".
--
--if git rev-parse --verify HEAD >/dev/null 2>&1
--then
--	against=HEAD
--else
--	# Initial commit: diff against an empty tree object
--	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
--fi
--
--# If you want to allow non-ASCII filenames set this variable to true.
--allownonascii=$(git config --bool hooks.allownonascii)
--
--# Redirect output to stderr.
--exec 1>&2
--
--# Cross platform projects tend to avoid non-ASCII filenames; prevent
--# them from being added to the repository. We exploit the fact that the
--# printable range starts at the space character and ends with tilde.
--if [ "$allownonascii" != "true" ] &&
--	# Note that the use of brackets around a tr range is ok here, (it's
--	# even required, for portability to Solaris 10's /usr/bin/tr), since
--	# the square bracket bytes happen to fall in the designated range.
--	test $(git diff --cached --name-only --diff-filter=A -z $against |
--	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
--then
--	cat <<\EOF
--Error: Attempt to add a non-ASCII file name.
--
--This can cause problems if you want to work with people on other platforms.
--
--To be portable it is advisable to rename the file.
--
--If you know what you are doing you can disable this check using:
--
--  git config hooks.allownonascii true
--EOF
--	exit 1
--fi
--
--# If there are whitespace errors, print the offending file names and fail.
--exec git diff-index --check --cached $against --
-diff --git a/./.git/hooks/pre-push.sample b/./.git/hooks/pre-push.sample
-deleted file mode 100755
-index 1f3bceb..0000000
---- a/./.git/hooks/pre-push.sample
-+++ /dev/null
-@@ -1,54 +0,0 @@
--#!/bin/sh
--
--# An example hook script to verify what is about to be pushed.  Called by "git
--# push" after it has checked the remote status, but before anything has been
--# pushed.  If this script exits with a non-zero status nothing will be pushed.
--#
--# This hook is called with the following parameters:
--#
--# $1 -- Name of the remote to which the push is being done
--# $2 -- URL to which the push is being done
--#
--# If pushing without using a named remote those arguments will be equal.
--#
--# Information about the commits which are being pushed is supplied as lines to
--# the standard input in the form:
--#
--#   <local ref> <local sha1> <remote ref> <remote sha1>
--#
--# This sample shows how to prevent push of commits where the log message starts
--# with "WIP" (work in progress).
--
--remote="$1"
--url="$2"
--
--z40=0000000000000000000000000000000000000000
--
--IFS=' '
--while read local_ref local_sha remote_ref remote_sha
--do
--	if [ "$local_sha" = $z40 ]
--	then
--		# Handle delete
--		:
--	else
--		if [ "$remote_sha" = $z40 ]
--		then
--			# New branch, examine all commits
--			range="$local_sha"
--		else
--			# Update to existing branch, examine new commits
--			range="$remote_sha..$local_sha"
--		fi
--
--		# Check for WIP commit
--		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
--		if [ -n "$commit" ]
--		then
--			echo "Found WIP commit in $local_ref, not pushing"
--			exit 1
--		fi
--	fi
--done
--
--exit 0
-diff --git a/./.git/hooks/pre-rebase.sample b/./.git/hooks/pre-rebase.sample
-deleted file mode 100755
-index 33730ca..0000000
---- a/./.git/hooks/pre-rebase.sample
-+++ /dev/null
-@@ -1,169 +0,0 @@
--#!/bin/sh
--#
--# Copyright (c) 2006, 2008 Junio C Hamano
--#
--# The "pre-rebase" hook is run just before "git rebase" starts doing
--# its job, and can prevent the command from running by exiting with
--# non-zero status.
--#
--# The hook is called with the following parameters:
--#
--# $1 -- the upstream the series was forked from.
--# $2 -- the branch being rebased (or empty when rebasing the current branch).
--#
--# This sample shows how to prevent topic branches that are already
--# merged to 'next' branch from getting rebased, because allowing it
--# would result in rebasing already published history.
--
--publish=next
--basebranch="$1"
--if test "$#" = 2
--then
--	topic="refs/heads/$2"
--else
--	topic=`git symbolic-ref HEAD` ||
--	exit 0 ;# we do not interrupt rebasing detached HEAD
--fi
--
--case "$topic" in
--refs/heads/??/*)
--	;;
--*)
--	exit 0 ;# we do not interrupt others.
--	;;
--esac
--
--# Now we are dealing with a topic branch being rebased
--# on top of master.  Is it OK to rebase it?
--
--# Does the topic really exist?
--git show-ref -q "$topic" || {
--	echo >&2 "No such branch $topic"
--	exit 1
--}
--
--# Is topic fully merged to master?
--not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
--if test -z "$not_in_master"
--then
--	echo >&2 "$topic is fully merged to master; better remove it."
--	exit 1 ;# we could allow it, but there is no point.
--fi
--
--# Is topic ever merged to next?  If so you should not be rebasing it.
--only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
--only_next_2=`git rev-list ^master           ${publish} | sort`
--if test "$only_next_1" = "$only_next_2"
--then
--	not_in_topic=`git rev-list "^$topic" master`
--	if test -z "$not_in_topic"
--	then
--		echo >&2 "$topic is already up-to-date with master"
--		exit 1 ;# we could allow it, but there is no point.
--	else
--		exit 0
--	fi
--else
--	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
--	/usr/bin/perl -e '
--		my $topic = $ARGV[0];
--		my $msg = "* $topic has commits already merged to public branch:\n";
--		my (%not_in_next) = map {
--			/^([0-9a-f]+) /;
--			($1 => 1);
--		} split(/\n/, $ARGV[1]);
--		for my $elem (map {
--				/^([0-9a-f]+) (.*)$/;
--				[$1 => $2];
--			} split(/\n/, $ARGV[2])) {
--			if (!exists $not_in_next{$elem->[0]}) {
--				if ($msg) {
--					print STDERR $msg;
--					undef $msg;
--				}
--				print STDERR " $elem->[1]\n";
--			}
--		}
--	' "$topic" "$not_in_next" "$not_in_master"
--	exit 1
--fi
--
--<<\DOC_END
--
--This sample hook safeguards topic branches that have been
--published from being rewound.
--
--The workflow assumed here is:
--
-- * Once a topic branch forks from "master", "master" is never
--   merged into it again (either directly or indirectly).
--
-- * Once a topic branch is fully cooked and merged into "master",
--   it is deleted.  If you need to build on top of it to correct
--   earlier mistakes, a new topic branch is created by forking at
--   the tip of the "master".  This is not strictly necessary, but
--   it makes it easier to keep your history simple.
--
-- * Whenever you need to test or publish your changes to topic
--   branches, merge them into "next" branch.
--
--The script, being an example, hardcodes the publish branch name
--to be "next", but it is trivial to make it configurable via
--$GIT_DIR/config mechanism.
--
--With this workflow, you would want to know:
--
--(1) ... if a topic branch has ever been merged to "next".  Young
--    topic branches can have stupid mistakes you would rather
--    clean up before publishing, and things that have not been
--    merged into other branches can be easily rebased without
--    affecting other people.  But once it is published, you would
--    not want to rewind it.
--
--(2) ... if a topic branch has been fully merged to "master".
--    Then you can delete it.  More importantly, you should not
--    build on top of it -- other people may already want to
--    change things related to the topic as patches against your
--    "master", so if you need further changes, it is better to
--    fork the topic (perhaps with the same name) afresh from the
--    tip of "master".
--
--Let's look at this example:
--
--		   o---o---o---o---o---o---o---o---o---o "next"
--		  /       /           /           /
--		 /   a---a---b A     /           /
--		/   /               /           /
--	       /   /   c---c---c---c B         /
--	      /   /   /             \         /
--	     /   /   /   b---b C     \       /
--	    /   /   /   /             \     /
--    ---o---o---o---o---o---o---o---o---o---o---o "master"
--
--
--A, B and C are topic branches.
--
-- * A has one fix since it was merged up to "next".
--
-- * B has finished.  It has been fully merged up to "master" and "next",
--   and is ready to be deleted.
--
-- * C has not merged to "next" at all.
--
--We would want to allow C to be rebased, refuse A, and encourage
--B to be deleted.
--
--To compute (1):
--
--	git rev-list ^master ^topic next
--	git rev-list ^master        next
--
--	if these match, topic has not merged in next at all.
--
--To compute (2):
--
--	git rev-list master..topic
--
--	if this is empty, it is fully merged to "master".
--
--DOC_END
-diff --git a/./.git/hooks/prepare-commit-msg.sample b/./.git/hooks/prepare-commit-msg.sample
-deleted file mode 100755
-index f093a02..0000000
---- a/./.git/hooks/prepare-commit-msg.sample
-+++ /dev/null
-@@ -1,36 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to prepare the commit log message.
--# Called by "git commit" with the name of the file that has the
--# commit message, followed by the description of the commit
--# message's source.  The hook's purpose is to edit the commit
--# message file.  If the hook fails with a non-zero status,
--# the commit is aborted.
--#
--# To enable this hook, rename this file to "prepare-commit-msg".
--
--# This hook includes three examples.  The first comments out the
--# "Conflicts:" part of a merge commit.
--#
--# The second includes the output of "git diff --name-status -r"
--# into the message, just before the "git status" output.  It is
--# commented because it doesn't cope with --amend or with squashed
--# commits.
--#
--# The third example adds a Signed-off-by line to the message, that can
--# still be edited.  This is rarely a good idea.
--
--case "$2,$3" in
--  merge,)
--    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
--
--# ,|template,)
--#   /usr/bin/perl -i.bak -pe '
--#      print "\n" . `git diff --cached --name-status -r`
--#	 if /^#/ && $first++ == 0' "$1" ;;
--
--  *) ;;
--esac
--
--# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
--# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
-diff --git a/./.git/hooks/update.sample b/./.git/hooks/update.sample
-deleted file mode 100755
-index d847583..0000000
---- a/./.git/hooks/update.sample
-+++ /dev/null
-@@ -1,128 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to blocks unannotated tags from entering.
--# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
--#
--# To enable this hook, rename this file to "update".
--#
--# Config
--# ------
--# hooks.allowunannotated
--#   This boolean sets whether unannotated tags will be allowed into the
--#   repository.  By default they won't be.
--# hooks.allowdeletetag
--#   This boolean sets whether deleting tags will be allowed in the
--#   repository.  By default they won't be.
--# hooks.allowmodifytag
--#   This boolean sets whether a tag may be modified after creation. By default
--#   it won't be.
--# hooks.allowdeletebranch
--#   This boolean sets whether deleting branches will be allowed in the
--#   repository.  By default they won't be.
--# hooks.denycreatebranch
--#   This boolean sets whether remotely creating branches will be denied
--#   in the repository.  By default this is allowed.
--#
--
--# --- Command line
--refname="$1"
--oldrev="$2"
--newrev="$3"
--
--# --- Safety check
--if [ -z "$GIT_DIR" ]; then
--	echo "Don't run this script from the command line." >&2
--	echo " (if you want, you could supply GIT_DIR then run" >&2
--	echo "  $0 <ref> <oldrev> <newrev>)" >&2
--	exit 1
--fi
--
--if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
--	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
--	exit 1
--fi
--
--# --- Config
--allowunannotated=$(git config --bool hooks.allowunannotated)
--allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
--denycreatebranch=$(git config --bool hooks.denycreatebranch)
--allowdeletetag=$(git config --bool hooks.allowdeletetag)
--allowmodifytag=$(git config --bool hooks.allowmodifytag)
--
--# check for no description
--projectdesc=$(sed -e '1q' "$GIT_DIR/description")
--case "$projectdesc" in
--"Unnamed repository"* | "")
--	echo "*** Project description file hasn't been set" >&2
--	exit 1
--	;;
--esac
--
--# --- Check types
--# if $newrev is 0000...0000, it's a commit to delete a ref.
--zero="0000000000000000000000000000000000000000"
--if [ "$newrev" = "$zero" ]; then
--	newrev_type=delete
--else
--	newrev_type=$(git cat-file -t $newrev)
--fi
--
--case "$refname","$newrev_type" in
--	refs/tags/*,commit)
--		# un-annotated tag
--		short_refname=${refname##refs/tags/}
--		if [ "$allowunannotated" != "true" ]; then
--			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
--			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
--			exit 1
--		fi
--		;;
--	refs/tags/*,delete)
--		# delete tag
--		if [ "$allowdeletetag" != "true" ]; then
--			echo "*** Deleting a tag is not allowed in this repository" >&2
--			exit 1
--		fi
--		;;
--	refs/tags/*,tag)
--		# annotated tag
--		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
--		then
--			echo "*** Tag '$refname' already exists." >&2
--			echo "*** Modifying a tag is not allowed in this repository." >&2
--			exit 1
--		fi
--		;;
--	refs/heads/*,commit)
--		# branch
--		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
--			echo "*** Creating a branch is not allowed in this repository" >&2
--			exit 1
--		fi
--		;;
--	refs/heads/*,delete)
--		# delete branch
--		if [ "$allowdeletebranch" != "true" ]; then
--			echo "*** Deleting a branch is not allowed in this repository" >&2
--			exit 1
--		fi
--		;;
--	refs/remotes/*,commit)
--		# tracking branch
--		;;
--	refs/remotes/*,delete)
--		# delete tracking branch
--		if [ "$allowdeletebranch" != "true" ]; then
--			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
--			exit 1
--		fi
--		;;
--	*)
--		# Anything else (is there anything else?)
--		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
--		exit 1
--		;;
--esac
--
--# --- Finished
--exit 0
-diff --git a/./.git/index b/./.git/index
-deleted file mode 100644
-index 6b9968a..0000000
-Binary files a/./.git/index and /dev/null differ
-diff --git a/./.git/info/exclude b/./.git/info/exclude
-deleted file mode 100644
-index a5196d1..0000000
---- a/./.git/info/exclude
-+++ /dev/null
-@@ -1,6 +0,0 @@
--# git ls-files --others --exclude-from=.git/info/exclude
--# Lines that start with '#' are comments.
--# For a project mostly in C, the following would be a good set of
--# exclude patterns (uncomment them if you want to use them):
--# *.[oa]
--# *~
-diff --git a/./.git/logs/HEAD b/./.git/logs/HEAD
-deleted file mode 100644
-index 7b0736e..0000000
---- a/./.git/logs/HEAD
-+++ /dev/null
-@@ -1 +0,0 @@
--0000000000000000000000000000000000000000 b512503d27acf20ae65b5c95571e472014fbdf7b ChrisBeauchene <christopherbeauchene2016@u.northwestern.edu> 1465587652 -0500	clone: from https://bitbucket.org/kchale/nautilus
-diff --git a/./.git/logs/refs/heads/master b/./.git/logs/refs/heads/master
-deleted file mode 100644
-index 7b0736e..0000000
---- a/./.git/logs/refs/heads/master
-+++ /dev/null
-@@ -1 +0,0 @@
--0000000000000000000000000000000000000000 b512503d27acf20ae65b5c95571e472014fbdf7b ChrisBeauchene <christopherbeauchene2016@u.northwestern.edu> 1465587652 -0500	clone: from https://bitbucket.org/kchale/nautilus
-diff --git a/./.git/logs/refs/remotes/origin/HEAD b/./.git/logs/refs/remotes/origin/HEAD
-deleted file mode 100644
-index 7b0736e..0000000
---- a/./.git/logs/refs/remotes/origin/HEAD
-+++ /dev/null
-@@ -1 +0,0 @@
--0000000000000000000000000000000000000000 b512503d27acf20ae65b5c95571e472014fbdf7b ChrisBeauchene <christopherbeauchene2016@u.northwestern.edu> 1465587652 -0500	clone: from https://bitbucket.org/kchale/nautilus
-diff --git a/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.idx b/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.idx
-deleted file mode 100644
-index bb29d79..0000000
-Binary files a/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.idx and /dev/null differ
-diff --git a/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.pack b/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.pack
-deleted file mode 100644
-index e6baac6..0000000
-Binary files a/./.git/objects/pack/pack-147d3c42f7e77085a8234875bf3dd32c8d841bb0.pack and /dev/null differ
-diff --git a/./.git/packed-refs b/./.git/packed-refs
-deleted file mode 100644
-index aab9e22..0000000
---- a/./.git/packed-refs
-+++ /dev/null
-@@ -1,2 +0,0 @@
--# pack-refs with: peeled fully-peeled 
--b512503d27acf20ae65b5c95571e472014fbdf7b refs/remotes/origin/master
-diff --git a/./.git/refs/heads/master b/./.git/refs/heads/master
-deleted file mode 100644
-index abae1b4..0000000
---- a/./.git/refs/heads/master
-+++ /dev/null
-@@ -1 +0,0 @@
--b512503d27acf20ae65b5c95571e472014fbdf7b
-diff --git a/./.git/refs/remotes/origin/HEAD b/./.git/refs/remotes/origin/HEAD
-deleted file mode 100644
-index 6efe28f..0000000
---- a/./.git/refs/remotes/origin/HEAD
-+++ /dev/null
-@@ -1 +0,0 @@
--ref: refs/remotes/origin/master
-diff --git a/./.gitignore b/../../nrt/nautilus/.gitignore
-old mode 100644
-new mode 100755
-diff --git a/./Kconfig b/../../nrt/nautilus/Kconfig
-old mode 100644
-new mode 100755
-index 50bdaea..3c136d3
---- a/./Kconfig
-+++ b/../../nrt/nautilus/Kconfig
-@@ -213,6 +213,13 @@ menu "AeroKernel Performance Optimizations"
-             Enables idle threads to start in addition to the main boot threads. 
-             Usually not needed.
- 
-+    config USE_RT_SCHEDULER
-+    bool "Use real-time scheduler."
-+    default n
-+    help
-+        Enables the use of the real-time scheduler.
-+        Disables apic periodic timer and uses a oneshot timer to call the scheduler at various intervals.
-+
- 
- endmenu
-     
-@@ -332,6 +339,27 @@ menu Debugging
-       help
-         Turn on debug prints for the scheduler/threads
- 
-+    config RT_DEBUG
-+    bool "Enable real-time debugging"
-+    depends on USE_RT_SCHEDULER
-+    default n
-+    help
-+        Compiles the Nautilus kernl with real-time debugging prints
-+
-+    config DEBUG_RT_SCHEDULER
-+    bool "Debug Real-Time Scheduler"
-+    depends on RT_DEBUG
-+    default n
-+    help
-+        Turn on debug prints for real-time scheduler code
-+
-+    config DEBUG_RT_THREADS
-+    bool "Debug Real-Time Threads"
-+    depends on RT_DEBUG
-+    default n
-+    help
-+        Turn on debug prints for real-time thread code
-+
-     config DEBUG_SYNCH
-       bool "Debug Synchronization"
-       depends on DEBUG_PRINTS
-@@ -431,3 +459,5 @@ endmenu
- 
- source "src/dev/Kconfig"
- 
-+
-+
-diff --git a/./LICENSE.txt b/../../nrt/nautilus/LICENSE.txt
-old mode 100644
-new mode 100755
-diff --git a/./Makefile b/../../nrt/nautilus/Makefile
-old mode 100644
-new mode 100755
-diff --git a/./Makefile.x86_64 b/../../nrt/nautilus/Makefile.x86_64
-old mode 100644
-new mode 100755
-diff --git a/./README.md b/../../nrt/nautilus/README.md
-old mode 100644
-new mode 100755
-diff --git a/../../nrt/nautilus/include/.DS_Store b/../../nrt/nautilus/include/.DS_Store
-new file mode 100755
-index 0000000..00e67e6
-Binary files /dev/null and b/../../nrt/nautilus/include/.DS_Store differ
-diff --git a/./include/acpi/acexcep.h b/../../nrt/nautilus/include/acpi/acexcep.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/acnames.h b/../../nrt/nautilus/include/acpi/acnames.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/acoutput.h b/../../nrt/nautilus/include/acpi/acoutput.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/acpi.h b/../../nrt/nautilus/include/acpi/acpi.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/acpiosxf.h b/../../nrt/nautilus/include/acpi/acpiosxf.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/acpixf.h b/../../nrt/nautilus/include/acpi/acpixf.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/acrestyp.h b/../../nrt/nautilus/include/acpi/acrestyp.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/actbl.h b/../../nrt/nautilus/include/acpi/actbl.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/actbl1.h b/../../nrt/nautilus/include/acpi/actbl1.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/actbl2.h b/../../nrt/nautilus/include/acpi/actbl2.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/actypes.h b/../../nrt/nautilus/include/acpi/actypes.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/platform/acenv.h b/../../nrt/nautilus/include/acpi/platform/acenv.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/platform/acgcc.h b/../../nrt/nautilus/include/acpi/platform/acgcc.h
-old mode 100644
-new mode 100755
-diff --git a/./include/acpi/platform/acnautilus.h b/../../nrt/nautilus/include/acpi/platform/acnautilus.h
-old mode 100644
-new mode 100755
-diff --git a/./include/arch/hrt/hrt.h b/../../nrt/nautilus/include/arch/hrt/hrt.h
-old mode 100644
-new mode 100755
-diff --git a/./include/arch/hrt/init.h b/../../nrt/nautilus/include/arch/hrt/init.h
-old mode 100644
-new mode 100755
-diff --git a/./include/arch/hrt/main.h b/../../nrt/nautilus/include/arch/hrt/main.h
-old mode 100644
-new mode 100755
-diff --git a/./include/arch/k1om/init.h b/../../nrt/nautilus/include/arch/k1om/init.h
-old mode 100644
-new mode 100755
-diff --git a/./include/arch/k1om/k1omsfi.h b/../../nrt/nautilus/include/arch/k1om/k1omsfi.h
-old mode 100644
-new mode 100755
-diff --git a/./include/arch/k1om/main.h b/../../nrt/nautilus/include/arch/k1om/main.h
-old mode 100644
-new mode 100755
-diff --git a/./include/arch/k1om/xeon_phi.h b/../../nrt/nautilus/include/arch/k1om/xeon_phi.h
-old mode 100644
-new mode 100755
-diff --git a/./include/arch/x64/init.h b/../../nrt/nautilus/include/arch/x64/init.h
-old mode 100644
-new mode 100755
-diff --git a/./include/arch/x64/main.h b/../../nrt/nautilus/include/arch/x64/main.h
-old mode 100644
-new mode 100755
-diff --git a/./include/asm/bitops.h b/../../nrt/nautilus/include/asm/bitops.h
-old mode 100644
-new mode 100755
-diff --git a/./include/asm/lowlevel.h b/../../nrt/nautilus/include/asm/lowlevel.h
-old mode 100644
-new mode 100755
-diff --git a/../../nrt/nautilus/include/autoconf.h b/../../nrt/nautilus/include/autoconf.h
-new file mode 100644
-index 0000000..656b8b4
---- /dev/null
-+++ b/../../nrt/nautilus/include/autoconf.h
-@@ -0,0 +1,94 @@
-+/*
-+ * Automatically generated C config: don't edit
-+ * Nautilus version: 
-+ * Fri Jun 10 14:02:58 2016
-+ */
-+#define AUTOCONF_INCLUDED
-+
-+/*
-+ * Platform/Arch Options
-+ */
-+#define NAUT_CONFIG_X86_64_HOST 1
-+#undef NAUT_CONFIG_XEON_PHI
-+#undef NAUT_CONFIG_HVM_HRT
-+#define NAUT_CONFIG_MAX_CPUS 256
-+#define NAUT_CONFIG_MAX_IOAPICS 16
-+#undef NAUT_CONFIG_PALACIOS
-+
-+/*
-+ * Nautilus AeroKernel Build Config
-+ */
-+#define NAUT_CONFIG_USE_NAUT_BUILTINS 1
-+#define NAUT_CONFIG_CXX_SUPPORT 1
-+#define NAUT_CONFIG_TOOLCHAIN_ROOT ""
-+
-+/*
-+ * Interface Options
-+ */
-+#define NAUT_CONFIG_THREAD_EXIT_KEYCODE 196
-+
-+/*
-+ * Nautilus AeroKernel Configuration
-+ */
-+#undef NAUT_CONFIG_USE_TICKETLOCKS
-+#define NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR 1
-+#define NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR_ALL 1
-+
-+/*
-+ * AeroKernel Performance Optimizations
-+ */
-+#define NAUT_CONFIG_FPU_SAVE 1
-+#undef NAUT_CONFIG_KICK_SCHEDULE
-+#undef NAUT_CONFIG_HALT_WHILE_IDLE
-+#undef NAUT_CONFIG_THREAD_OPTIMIZE
-+#undef NAUT_CONFIG_USE_IDLE_THREADS
-+#define NAUT_CONFIG_USE_RT_SCHEDULER 1
-+
-+/*
-+ * Debugging
-+ */
-+#define NAUT_CONFIG_DEBUG_INFO 1
-+#define NAUT_CONFIG_DEBUG_PRINTS 1
-+#undef NAUT_CONFIG_ENABLE_ASSERTS
-+#undef NAUT_CONFIG_PROFILE
-+#undef NAUT_CONFIG_SILENCE_UNDEF_ERR
-+#undef NAUT_CONFIG_ENABLE_STACK_CHECK
-+#undef NAUT_CONFIG_DEBUG_PAGING
-+#undef NAUT_CONFIG_DEBUG_BOOTMEM
-+#undef NAUT_CONFIG_DEBUG_BUDDY
-+#undef NAUT_CONFIG_DEBUG_KMEM
-+#undef NAUT_CONFIG_DEBUG_FPU
-+#undef NAUT_CONFIG_DEBUG_SMP
-+#undef NAUT_CONFIG_DEBUG_SFI
-+#undef NAUT_CONFIG_DEBUG_CXX
-+#define NAUT_CONFIG_DEBUG_THREADS 1
-+#define NAUT_CONFIG_RT_DEBUG 1
-+#define NAUT_CONFIG_DEBUG_RT_SCHEDULER 1
-+#define NAUT_CONFIG_DEBUG_RT_THREADS 1
-+#undef NAUT_CONFIG_DEBUG_SYNCH
-+#undef NAUT_CONFIG_DEBUG_BARRIER
-+#undef NAUT_CONFIG_DEBUG_NUMA
-+#undef NAUT_CONFIG_DEBUG_VIRTUAL_CONSOLE
-+
-+/*
-+ * Parallel Runtime Integration
-+ */
-+#undef NAUT_CONFIG_LEGION_RT
-+#undef NAUT_CONFIG_NDPC_RT
-+#undef NAUT_CONFIG_NESL_RT
-+#define NAUT_CONFIG_NO_RT 1
-+
-+/*
-+ * Device options
-+ */
-+#define NAUT_CONFIG_SERIAL_REDIRECT 1
-+#define NAUT_CONFIG_SERIAL_PORT 1
-+#define NAUT_CONFIG_DEBUG_APIC 1
-+#undef NAUT_CONFIG_DEBUG_IOAPIC
-+#undef NAUT_CONFIG_DEBUG_PCI
-+#undef NAUT_CONFIG_DEBUG_KBD
-+#undef NAUT_CONFIG_DEBUG_TIMERS
-+#undef NAUT_CONFIG_DEBUG_PIT
-+#undef NAUT_CONFIG_HPET
-+#define NAUT_CONFIG_HZ 10
-+#undef NAUT_CONFIG_VIRTIO_PCI
-diff --git a/../../nrt/nautilus/include/config/MARKER b/../../nrt/nautilus/include/config/MARKER
-new file mode 100755
-index 0000000..e69de29
-diff --git a/../../nrt/nautilus/include/config/cxx/support.h b/../../nrt/nautilus/include/config/cxx/support.h
-new file mode 100755
-index 0000000..5764e41
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/cxx/support.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_CXX_SUPPORT 1
-diff --git a/../../nrt/nautilus/include/config/debug/apic.h b/../../nrt/nautilus/include/config/debug/apic.h
-new file mode 100755
-index 0000000..6c9af72
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/apic.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_DEBUG_APIC 1
-diff --git a/../../nrt/nautilus/include/config/debug/barrier.h b/../../nrt/nautilus/include/config/debug/barrier.h
-new file mode 100755
-index 0000000..df18039
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/barrier.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_BARRIER
-diff --git a/../../nrt/nautilus/include/config/debug/bootmem.h b/../../nrt/nautilus/include/config/debug/bootmem.h
-new file mode 100755
-index 0000000..7e534d0
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/bootmem.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_BOOTMEM
-diff --git a/../../nrt/nautilus/include/config/debug/buddy.h b/../../nrt/nautilus/include/config/debug/buddy.h
-new file mode 100755
-index 0000000..cd02529
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/buddy.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_BUDDY
-diff --git a/../../nrt/nautilus/include/config/debug/cxx.h b/../../nrt/nautilus/include/config/debug/cxx.h
-new file mode 100755
-index 0000000..9b8a1a0
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/cxx.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_CXX
-diff --git a/../../nrt/nautilus/include/config/debug/fpu.h b/../../nrt/nautilus/include/config/debug/fpu.h
-new file mode 100755
-index 0000000..501de9c
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/fpu.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_FPU
-diff --git a/../../nrt/nautilus/include/config/debug/info.h b/../../nrt/nautilus/include/config/debug/info.h
-new file mode 100755
-index 0000000..692d822
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/info.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_DEBUG_INFO 1
-diff --git a/../../nrt/nautilus/include/config/debug/ioapic.h b/../../nrt/nautilus/include/config/debug/ioapic.h
-new file mode 100755
-index 0000000..f2ee5d4
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/ioapic.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_IOAPIC
-diff --git a/../../nrt/nautilus/include/config/debug/kbd.h b/../../nrt/nautilus/include/config/debug/kbd.h
-new file mode 100755
-index 0000000..52ea805
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/kbd.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_KBD
-diff --git a/../../nrt/nautilus/include/config/debug/kmem.h b/../../nrt/nautilus/include/config/debug/kmem.h
-new file mode 100755
-index 0000000..574a48c
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/kmem.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_KMEM
-diff --git a/../../nrt/nautilus/include/config/debug/numa.h b/../../nrt/nautilus/include/config/debug/numa.h
-new file mode 100755
-index 0000000..fffcecd
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/numa.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_NUMA
-diff --git a/../../nrt/nautilus/include/config/debug/paging.h b/../../nrt/nautilus/include/config/debug/paging.h
-new file mode 100755
-index 0000000..5b5b1bf
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/paging.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_PAGING
-diff --git a/../../nrt/nautilus/include/config/debug/pci.h b/../../nrt/nautilus/include/config/debug/pci.h
-new file mode 100755
-index 0000000..fccd313
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/pci.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_PCI
-diff --git a/../../nrt/nautilus/include/config/debug/pit.h b/../../nrt/nautilus/include/config/debug/pit.h
-new file mode 100755
-index 0000000..1df573d
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/pit.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_PIT
-diff --git a/../../nrt/nautilus/include/config/debug/prints.h b/../../nrt/nautilus/include/config/debug/prints.h
-new file mode 100755
-index 0000000..78fe9d5
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/prints.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_DEBUG_PRINTS 1
-diff --git a/../../nrt/nautilus/include/config/debug/rt/scheduler.h b/../../nrt/nautilus/include/config/debug/rt/scheduler.h
-new file mode 100755
-index 0000000..b16dfd1
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/rt/scheduler.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_DEBUG_RT_SCHEDULER 1
-diff --git a/../../nrt/nautilus/include/config/debug/rt/threads.h b/../../nrt/nautilus/include/config/debug/rt/threads.h
-new file mode 100755
-index 0000000..360b1a7
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/rt/threads.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_DEBUG_RT_THREADS 1
-diff --git a/../../nrt/nautilus/include/config/debug/sfi.h b/../../nrt/nautilus/include/config/debug/sfi.h
-new file mode 100755
-index 0000000..474b985
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/sfi.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_SFI
-diff --git a/../../nrt/nautilus/include/config/debug/smp.h b/../../nrt/nautilus/include/config/debug/smp.h
-new file mode 100755
-index 0000000..1ebd356
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/smp.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_SMP
-diff --git a/../../nrt/nautilus/include/config/debug/synch.h b/../../nrt/nautilus/include/config/debug/synch.h
-new file mode 100755
-index 0000000..825f374
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/synch.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_SYNCH
-diff --git a/../../nrt/nautilus/include/config/debug/threads.h b/../../nrt/nautilus/include/config/debug/threads.h
-new file mode 100755
-index 0000000..0343541
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/threads.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_DEBUG_THREADS 1
-diff --git a/../../nrt/nautilus/include/config/debug/timers.h b/../../nrt/nautilus/include/config/debug/timers.h
-new file mode 100755
-index 0000000..7aca192
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/timers.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_TIMERS
-diff --git a/../../nrt/nautilus/include/config/debug/virtual/console.h b/../../nrt/nautilus/include/config/debug/virtual/console.h
-new file mode 100755
-index 0000000..d5c9cc9
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/debug/virtual/console.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_DEBUG_VIRTUAL_CONSOLE
-diff --git a/../../nrt/nautilus/include/config/enable/asserts.h b/../../nrt/nautilus/include/config/enable/asserts.h
-new file mode 100755
-index 0000000..6f10f30
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/enable/asserts.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_ENABLE_ASSERTS
-diff --git a/../../nrt/nautilus/include/config/enable/stack/check.h b/../../nrt/nautilus/include/config/enable/stack/check.h
-new file mode 100755
-index 0000000..713dafb
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/enable/stack/check.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_ENABLE_STACK_CHECK
-diff --git a/../../nrt/nautilus/include/config/fpu/save.h b/../../nrt/nautilus/include/config/fpu/save.h
-new file mode 100755
-index 0000000..6728556
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/fpu/save.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_FPU_SAVE 1
-diff --git a/../../nrt/nautilus/include/config/halt/while/idle.h b/../../nrt/nautilus/include/config/halt/while/idle.h
-new file mode 100755
-index 0000000..0415b63
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/halt/while/idle.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_HALT_WHILE_IDLE
-diff --git a/../../nrt/nautilus/include/config/hpet.h b/../../nrt/nautilus/include/config/hpet.h
-new file mode 100755
-index 0000000..ef70aaf
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/hpet.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_HPET
-diff --git a/../../nrt/nautilus/include/config/hvm/hrt.h b/../../nrt/nautilus/include/config/hvm/hrt.h
-new file mode 100755
-index 0000000..ef047ea
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/hvm/hrt.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_HVM_HRT
-diff --git a/../../nrt/nautilus/include/config/hz.h b/../../nrt/nautilus/include/config/hz.h
-new file mode 100755
-index 0000000..0e8bd4c
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/hz.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_HZ 10
-diff --git a/../../nrt/nautilus/include/config/kick/schedule.h b/../../nrt/nautilus/include/config/kick/schedule.h
-new file mode 100755
-index 0000000..7f218da
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/kick/schedule.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_KICK_SCHEDULE
-diff --git a/../../nrt/nautilus/include/config/legion/rt.h b/../../nrt/nautilus/include/config/legion/rt.h
-new file mode 100755
-index 0000000..ee6c70d
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/legion/rt.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_LEGION_RT
-diff --git a/../../nrt/nautilus/include/config/max/cpus.h b/../../nrt/nautilus/include/config/max/cpus.h
-new file mode 100755
-index 0000000..43a1619
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/max/cpus.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_MAX_CPUS 256
-diff --git a/../../nrt/nautilus/include/config/max/ioapics.h b/../../nrt/nautilus/include/config/max/ioapics.h
-new file mode 100755
-index 0000000..805949f
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/max/ioapics.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_MAX_IOAPICS 16
-diff --git a/../../nrt/nautilus/include/config/ndpc/rt.h b/../../nrt/nautilus/include/config/ndpc/rt.h
-new file mode 100755
-index 0000000..20e74e1
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/ndpc/rt.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_NDPC_RT
-diff --git a/../../nrt/nautilus/include/config/nesl/rt.h b/../../nrt/nautilus/include/config/nesl/rt.h
-new file mode 100755
-index 0000000..9c7a383
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/nesl/rt.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_NESL_RT
-diff --git a/../../nrt/nautilus/include/config/no/rt.h b/../../nrt/nautilus/include/config/no/rt.h
-new file mode 100755
-index 0000000..c7b6351
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/no/rt.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_NO_RT 1
-diff --git a/../../nrt/nautilus/include/config/palacios.h b/../../nrt/nautilus/include/config/palacios.h
-new file mode 100755
-index 0000000..f8ecccf
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/palacios.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_PALACIOS
-diff --git a/../../nrt/nautilus/include/config/profile.h b/../../nrt/nautilus/include/config/profile.h
-new file mode 100755
-index 0000000..8393920
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/profile.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_PROFILE
-diff --git a/../../nrt/nautilus/include/config/rt/debug.h b/../../nrt/nautilus/include/config/rt/debug.h
-new file mode 100755
-index 0000000..1b9e7bf
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/rt/debug.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_RT_DEBUG 1
-diff --git a/../../nrt/nautilus/include/config/serial/port.h b/../../nrt/nautilus/include/config/serial/port.h
-new file mode 100755
-index 0000000..9fdd4fb
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/serial/port.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_SERIAL_PORT 1
-diff --git a/../../nrt/nautilus/include/config/serial/redirect.h b/../../nrt/nautilus/include/config/serial/redirect.h
-new file mode 100755
-index 0000000..911f3c5
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/serial/redirect.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_SERIAL_REDIRECT 1
-diff --git a/../../nrt/nautilus/include/config/silence/undef/err.h b/../../nrt/nautilus/include/config/silence/undef/err.h
-new file mode 100755
-index 0000000..bcae6cc
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/silence/undef/err.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_SILENCE_UNDEF_ERR
-diff --git a/../../nrt/nautilus/include/config/thread/exit/keycode.h b/../../nrt/nautilus/include/config/thread/exit/keycode.h
-new file mode 100755
-index 0000000..094e82e
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/thread/exit/keycode.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_THREAD_EXIT_KEYCODE 196
-diff --git a/../../nrt/nautilus/include/config/thread/optimize.h b/../../nrt/nautilus/include/config/thread/optimize.h
-new file mode 100755
-index 0000000..6602fd6
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/thread/optimize.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_THREAD_OPTIMIZE
-diff --git a/../../nrt/nautilus/include/config/toolchain/root.h b/../../nrt/nautilus/include/config/toolchain/root.h
-new file mode 100755
-index 0000000..7f1af81
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/toolchain/root.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_TOOLCHAIN_ROOT ""
-diff --git a/../../nrt/nautilus/include/config/use/idle/threads.h b/../../nrt/nautilus/include/config/use/idle/threads.h
-new file mode 100755
-index 0000000..80206cf
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/use/idle/threads.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_USE_IDLE_THREADS
-diff --git a/../../nrt/nautilus/include/config/use/naut/builtins.h b/../../nrt/nautilus/include/config/use/naut/builtins.h
-new file mode 100755
-index 0000000..8c7e355
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/use/naut/builtins.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_USE_NAUT_BUILTINS 1
-diff --git a/../../nrt/nautilus/include/config/use/rt/scheduler.h b/../../nrt/nautilus/include/config/use/rt/scheduler.h
-new file mode 100755
-index 0000000..d18df1f
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/use/rt/scheduler.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_USE_RT_SCHEDULER 1
-diff --git a/../../nrt/nautilus/include/config/use/ticketlocks.h b/../../nrt/nautilus/include/config/use/ticketlocks.h
-new file mode 100755
-index 0000000..6ee82ca
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/use/ticketlocks.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_USE_TICKETLOCKS
-diff --git a/../../nrt/nautilus/include/config/virtio/pci.h b/../../nrt/nautilus/include/config/virtio/pci.h
-new file mode 100755
-index 0000000..616a2d0
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/virtio/pci.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_VIRTIO_PCI
-diff --git a/../../nrt/nautilus/include/config/virtual/console/serial/mirror/all.h b/../../nrt/nautilus/include/config/virtual/console/serial/mirror/all.h
-new file mode 100755
-index 0000000..ba3d482
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/virtual/console/serial/mirror/all.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR_ALL 1
-diff --git a/../../nrt/nautilus/include/config/virtual/console/serial/mirror.h b/../../nrt/nautilus/include/config/virtual/console/serial/mirror.h
-new file mode 100755
-index 0000000..b315fc2
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/virtual/console/serial/mirror.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_VIRTUAL_CONSOLE_SERIAL_MIRROR 1
-diff --git a/../../nrt/nautilus/include/config/x86/64/host.h b/../../nrt/nautilus/include/config/x86/64/host.h
-new file mode 100755
-index 0000000..462e354
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/x86/64/host.h
-@@ -0,0 +1 @@
-+#define NAUT_CONFIG_X86_64_HOST 1
-diff --git a/../../nrt/nautilus/include/config/xeon/phi.h b/../../nrt/nautilus/include/config/xeon/phi.h
-new file mode 100755
-index 0000000..a54b92e
---- /dev/null
-+++ b/../../nrt/nautilus/include/config/xeon/phi.h
-@@ -0,0 +1 @@
-+#undef NAUT_CONFIG_XEON_PHI
-diff --git a/./include/dev/apic.h b/../../nrt/nautilus/include/dev/apic.h
-old mode 100644
-new mode 100755
-index e38db5b..9d61d0b
---- a/./include/dev/apic.h
-+++ b/../../nrt/nautilus/include/dev/apic.h
-@@ -196,6 +196,8 @@ struct apic_dev {
-     uint_t   id;
-     uint64_t spur_int_cnt;
-     uint64_t err_int_cnt;
-+    uint64_t scale;
-+    uint64_t frequency;
- };
- 
- 
-@@ -207,6 +209,10 @@ apic_write (struct apic_dev * apic,
- {
-     *((volatile uint32_t *)(apic->base_addr + reg)) = val;
- }
-+    
-+inline void apic_oneshot_write(struct apic_dev *apic, uint64_t time);
-+
-+void calibrate_apic(struct apic_dev *apic);
- 
- 
- static inline uint32_t
-diff --git a/./include/dev/hpet.h b/../../nrt/nautilus/include/dev/hpet.h
-old mode 100644
-new mode 100755
-diff --git a/./include/dev/i8254.h b/../../nrt/nautilus/include/dev/i8254.h
-old mode 100644
-new mode 100755
-diff --git a/./include/dev/ioapic.h b/../../nrt/nautilus/include/dev/ioapic.h
-old mode 100644
-new mode 100755
-diff --git a/./include/dev/kbd.h b/../../nrt/nautilus/include/dev/kbd.h
-old mode 100644
-new mode 100755
-diff --git a/./include/dev/pci.h b/../../nrt/nautilus/include/dev/pci.h
-old mode 100644
-new mode 100755
-diff --git a/./include/dev/serial.h b/../../nrt/nautilus/include/dev/serial.h
-old mode 100644
-new mode 100755
-diff --git a/./include/dev/timer.h b/../../nrt/nautilus/include/dev/timer.h
-old mode 100644
-new mode 100755
-diff --git a/./include/dev/vga.h b/../../nrt/nautilus/include/dev/vga.h
-old mode 100644
-new mode 100755
-diff --git a/./include/dev/virtio_pci.h b/../../nrt/nautilus/include/dev/virtio_pci.h
-old mode 100644
-new mode 100755
-diff --git a/./include/lib/bitmap.h b/../../nrt/nautilus/include/lib/bitmap.h
-old mode 100644
-new mode 100755
-diff --git a/./include/lib/bitops.h b/../../nrt/nautilus/include/lib/bitops.h
-old mode 100644
-new mode 100755
-diff --git a/./include/lib/linux_bitops.h b/../../nrt/nautilus/include/lib/linux_bitops.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/acpi-x86_64.h b/../../nrt/nautilus/include/nautilus/acpi-x86_64.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/acpi.h b/../../nrt/nautilus/include/nautilus/acpi.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/atomic.h b/../../nrt/nautilus/include/nautilus/atomic.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/backtrace.h b/../../nrt/nautilus/include/nautilus/backtrace.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/barrier.h b/../../nrt/nautilus/include/nautilus/barrier.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/bits.h b/../../nrt/nautilus/include/nautilus/bits.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/buddy.h b/../../nrt/nautilus/include/nautilus/buddy.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/bug.h b/../../nrt/nautilus/include/nautilus/bug.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/condvar.h b/../../nrt/nautilus/include/nautilus/condvar.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/cpu.h b/../../nrt/nautilus/include/nautilus/cpu.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/cpuid.h b/../../nrt/nautilus/include/nautilus/cpuid.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/cxxglue.h b/../../nrt/nautilus/include/nautilus/cxxglue.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/doprnt.h b/../../nrt/nautilus/include/nautilus/doprnt.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/errno.h b/../../nrt/nautilus/include/nautilus/errno.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/fmtout.h b/../../nrt/nautilus/include/nautilus/fmtout.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/fpu.h b/../../nrt/nautilus/include/nautilus/fpu.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/gdt.h b/../../nrt/nautilus/include/nautilus/gdt.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/hashtable.h b/../../nrt/nautilus/include/nautilus/hashtable.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/idle.h b/../../nrt/nautilus/include/nautilus/idle.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/idt.h b/../../nrt/nautilus/include/nautilus/idt.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/instrument.h b/../../nrt/nautilus/include/nautilus/instrument.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/intrinsics.h b/../../nrt/nautilus/include/nautilus/intrinsics.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/irq.h b/../../nrt/nautilus/include/nautilus/irq.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/libccompat.h b/../../nrt/nautilus/include/nautilus/libccompat.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/limits.h b/../../nrt/nautilus/include/nautilus/limits.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/list.h b/../../nrt/nautilus/include/nautilus/list.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/macros.h b/../../nrt/nautilus/include/nautilus/macros.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/math.h b/../../nrt/nautilus/include/nautilus/math.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/mb_utils.h b/../../nrt/nautilus/include/nautilus/mb_utils.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/mcslock.h b/../../nrt/nautilus/include/nautilus/mcslock.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/mm.h b/../../nrt/nautilus/include/nautilus/mm.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/msr.h b/../../nrt/nautilus/include/nautilus/msr.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/multiboot2.h b/../../nrt/nautilus/include/nautilus/multiboot2.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/mwait.h b/../../nrt/nautilus/include/nautilus/mwait.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/naut_assert.h b/../../nrt/nautilus/include/nautilus/naut_assert.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/naut_string.h b/../../nrt/nautilus/include/nautilus/naut_string.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/naut_types.h b/../../nrt/nautilus/include/nautilus/naut_types.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/nautilus.h b/../../nrt/nautilus/include/nautilus/nautilus.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/nemo.h b/../../nrt/nautilus/include/nautilus/nemo.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/numa.h b/../../nrt/nautilus/include/nautilus/numa.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/paging.h b/../../nrt/nautilus/include/nautilus/paging.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/percpu.h b/../../nrt/nautilus/include/nautilus/percpu.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/pmc.h b/../../nrt/nautilus/include/nautilus/pmc.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/printk.h b/../../nrt/nautilus/include/nautilus/printk.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/queue.h b/../../nrt/nautilus/include/nautilus/queue.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/random.h b/../../nrt/nautilus/include/nautilus/random.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/rbtree.h b/../../nrt/nautilus/include/nautilus/rbtree.h
-old mode 100644
-new mode 100755
-diff --git a/../../nrt/nautilus/include/nautilus/rt_scheduler.h b/../../nrt/nautilus/include/nautilus/rt_scheduler.h
-new file mode 100755
-index 0000000..96cceab
---- /dev/null
-+++ b/../../nrt/nautilus/include/nautilus/rt_scheduler.h
-@@ -0,0 +1,128 @@
-+//
-+//  rt_scheduler.h
-+//  rt_scheduler_test
-+//
-+//  Created by Chris Beauchene on 2/15/16.
-+//  Copyright  2016 EECS 395/495 Kernel Development. All rights reserved.
-+//
-+
-+#ifndef rt_scheduler_h
-+#define rt_scheduler_h
-+
-+#include <nautilus/thread.h>
-+
-+struct periodic_constraints {
-+    uint64_t period, slice;
-+};
-+
-+struct sporadic_constraints {
-+    uint64_t work;
-+};
-+
-+struct aperiodic_constraints {
-+    uint64_t priority;
-+};
-+
-+typedef union rt_constraints {
-+    struct periodic_constraints     periodic;
-+    struct sporadic_constraints     sporadic;
-+    struct aperiodic_constraints    aperiodic;
-+} rt_constraints;
-+
-+typedef enum { APERIODIC = 0, SPORADIC = 1, PERIODIC = 2} rt_type;
-+typedef enum { RUNNABLE_QUEUE = 0, PENDING_QUEUE = 1, APERIODIC_QUEUE = 2} queue_type;
-+typedef enum { ARRIVED = 0, ADMITTED = 1, TOBO_REMOVED = 2, REMOVED = 3, SLEEPING = 4, DENIED = 5} rt_status;
-+
-+struct rt_thread;
-+
-+typedef struct rt_node {
-+    struct rt_thread *thread;
-+    struct rt_node *next;
-+    struct rt_node *prev;
-+} rt_node;
-+
-+typedef struct rt_list {
-+    rt_node *head;
-+    rt_node *tail;
-+} rt_list;
-+
-+typedef struct rt_thread {
-+    rt_type type;
-+    queue_type q_type;
-+    rt_status status;
-+    rt_constraints *constraints;
-+    uint64_t start_time; 
-+    uint64_t run_time;
-+    uint64_t deadline;
-+    uint64_t exit_time;
-+    struct nk_thread *thread;
-+
-+    rt_list *holding;
-+    rt_list *waiting;
-+
-+    struct rt_thread *parent;
-+    rt_list *children;
-+
-+} rt_thread;
-+
-+rt_thread* rt_thread_init(int type,
-+                          rt_constraints *constraints,
-+                          uint64_t deadline,
-+                          struct nk_thread *thread
-+                          );
-+
-+typedef struct rt_queue {
-+    queue_type type;
-+    uint64_t size;
-+    rt_thread *threads[0];
-+} rt_queue ;
-+
-+typedef struct tsc_info {
-+    uint64_t set_time;
-+    uint64_t start_time;
-+    uint64_t end_time;
-+    uint64_t elapsed_time;
-+    uint64_t error;
-+} tsc_info;
-+
-+typedef struct rt_scheduler {
-+    rt_queue *runnable;
-+    rt_queue *pending;
-+    rt_queue *aperiodic;
-+
-+    rt_list *sleeping;
-+    rt_list *arrival;
-+    rt_list *exited;
-+
-+    rt_thread *main_thread;
-+    uint64_t run_time;
-+    tsc_info *tsc;
-+} rt_scheduler;
-+
-+rt_scheduler* rt_scheduler_init(rt_thread *main_thread);
-+struct nk_thread* rt_need_resched();
-+void rt_start(uint64_t sched_slice_time, uint64_t sched_period);
-+
-+void enqueue_thread(rt_queue *queue, rt_thread *thread);
-+rt_thread* dequeue_thread(rt_queue *queue);
-+
-+void rt_thread_dump(rt_thread *thread);
-+
-+uint64_t cur_time();
-+
-+
-+int rt_admit(rt_scheduler *scheduler, rt_thread *thread);
-+void wait_on(rt_thread *A, rt_thread *B);
-+void wake_up(rt_thread *A, rt_thread *B);
-+void wake_up_all(rt_thread *A);
-+void list_enqueue(rt_list *l, rt_thread *t);
-+
-+rt_thread* list_dequeue(rt_list *l);
-+rt_thread* list_remove(rt_list *l, rt_thread *t);
-+rt_thread* remove_thread(rt_thread *thread);
-+void rt_thread_exit(rt_thread *thread);
-+int rt_list_empty(rt_list *l);
-+
-+
-+
-+#endif /* rt_scheduler_h */
-diff --git a/./include/nautilus/rwlock.h b/../../nrt/nautilus/include/nautilus/rwlock.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/sfi.h b/../../nrt/nautilus/include/nautilus/sfi.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/shutdown.h b/../../nrt/nautilus/include/nautilus/shutdown.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/smp.h b/../../nrt/nautilus/include/nautilus/smp.h
-old mode 100644
-new mode 100755
-index 9b06fb6..659202f
---- a/./include/nautilus/smp.h
-+++ b/../../nrt/nautilus/include/nautilus/smp.h
-@@ -50,6 +50,11 @@ struct nk_cpu_coords;
- 
- struct nk_queue;
- struct nk_thread;
-+    
-+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
-+    struct rt_scheduler;
-+    typedef struct rt_scheduler rt_scheduler;
-+#endif
- 
- //typedef struct nk_queue nk_thread_queue_t;
- //typedef struct nk_thread nk_thread_t;
-@@ -109,6 +114,11 @@ struct cpu {
- #ifdef NAUT_CONFIG_PROFILE
-     struct nk_instr_data * instr_data;
- #endif
-+    
-+    
-+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
-+    rt_scheduler *rt_sched;
-+#endif
- };
- 
- 
-diff --git a/./include/nautilus/spinlock.h b/../../nrt/nautilus/include/nautilus/spinlock.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/thread.h b/../../nrt/nautilus/include/nautilus/thread.h
-old mode 100644
-new mode 100755
-index df30d75..e6f42e2
---- a/./include/nautilus/thread.h
-+++ b/../../nrt/nautilus/include/nautilus/thread.h
-@@ -1,17 +1,17 @@
--/* 
-+/*
-  * This file is part of the Nautilus AeroKernel developed
-- * by the Hobbes and V3VEE Projects with funding from the 
-- * United States National  Science Foundation and the Department of Energy.  
-+ * by the Hobbes and V3VEE Projects with funding from the
-+ * United States National  Science Foundation and the Department of Energy.
-  *
-  * The V3VEE Project is a joint project between Northwestern University
-  * and the University of New Mexico.  The Hobbes Project is a collaboration
-- * led by Sandia National Laboratories that includes several national 
-+ * led by Sandia National Laboratories that includes several national
-  * laboratories and universities. You can find out more at:
-  * http://www.v3vee.org  and
-  * http://xtack.sandia.gov/hobbes
-  *
-  * Copyright (c) 2015, Kyle C. Hale <kh@u.northwestern.edu>
-- * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org> 
-+ * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org>
-  *                     The Hobbes Project <http://xstack.sandia.gov/hobbes>
-  * All rights reserved.
-  *
-@@ -26,228 +26,265 @@
- #ifdef __cplusplus
- extern "C" {
- #endif
--
-+    
- #ifndef __ASSEMBLER__
--
-+    
- #include <nautilus/spinlock.h>
- #include <nautilus/queue.h>
- #include <nautilus/intrinsics.h>
--
-+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
-+#include <nautilus/rt_scheduler.h>
-+#endif
-+    
- #define CPU_ANY       -1
--
--/* common thread stack sizes */
-+    
-+    /* common thread stack sizes */
- #define TSTACK_DEFAULT 0  // will be 4K
- #define TSTACK_4KB     0x001000
- #define TSTACK_1MB     0x100000
- #define TSTACK_2MB     0x200000
--
--/******** EXTERNAL INTERFACE **********/
--
--// opaque pointer given to users
--typedef void* nk_thread_id_t;
--typedef void (*nk_thread_fun_t)(void * input, void ** output);
--typedef uint64_t nk_stack_size_t;
--
--
--int
--nk_thread_create (nk_thread_fun_t fun, 
--                 void * input,
--                 void ** output,
--                 uint8_t is_detached,
--                 nk_stack_size_t stack_size,
--                 nk_thread_id_t * tid,
--                 int cpu);
--
--int
--nk_thread_run(nk_thread_id_t tid);
--
--int
--nk_thread_start (nk_thread_fun_t fun, 
--                 void * input,
--                 void ** output,
--                 uint8_t is_detached,
--                 nk_stack_size_t stack_size,
--                 nk_thread_id_t * tid,
--                 int cpu);
--
--extern nk_thread_id_t nk_thread_fork(void);
--
--void nk_set_thread_fork_output(void * result);
--void nk_yield(void);
--void nk_thread_exit(void * retval);
--void nk_thread_destroy(nk_thread_id_t t); /* like thread_kill */
--void nk_wait(nk_thread_id_t t);
--
--void nk_wake_waiters(void);
--int nk_join(nk_thread_id_t t, void ** retval);
--int nk_join_all_children(int (*)(void*));
--
-+    
-+    /******** EXTERNAL INTERFACE **********/
-+    
-+    // opaque pointer given to users
-+    typedef void* nk_thread_id_t;
-+    typedef void (*nk_thread_fun_t)(void * input, void ** output);
-+    typedef uint64_t nk_stack_size_t;
-+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
-+    typedef struct rt_thread rt_thread;
-+    typedef struct rt_scheduler rt_scheduler;
-+    typedef union rt_constraints rt_constraints;
-+#endif
-+    int
-+    nk_thread_create (nk_thread_fun_t fun,
-+                      void * input,
-+                      void ** output,
-+                      uint8_t is_detached,
-+                      nk_stack_size_t stack_size,
-+                      nk_thread_id_t * tid,
-+                      int cpu);
-+    
-+    int
-+    nk_thread_run(nk_thread_id_t tid);
-+    
-+#ifndef NAUT_CONFIG_USE_RT_SCHEDULER
-+    int
-+    nk_thread_start (nk_thread_fun_t fun,
-+                     void * input,
-+                     void ** output,
-+                     uint8_t is_detached,
-+                     nk_stack_size_t stack_size,
-+                     nk_thread_id_t * tid,
-+                     int cpu);
-+#else
-+    int nk_thread_start(nk_thread_fun_t fun,
-+                        void * input,
-+                        void ** output,
-+                        uint8_t is_detached,
-+                        nk_stack_size_t stack_size,
-+                        nk_thread_id_t * tid,
-+                        int cpu,
-+                        int rt_type,
-+                        rt_constraints *rt_constraints,
-+                        uint64_t rt_deadline);
-+#endif
-+    extern nk_thread_id_t nk_thread_fork(void);
-+    
-+    void nk_set_thread_fork_output(void * result);
-+    void nk_yield(void);
-+    void nk_thread_exit(void * retval);
-+    void nk_thread_destroy(nk_thread_id_t t); /* like thread_kill */
-+    void nk_wait(nk_thread_id_t t);
-+    
-+    void nk_wake_waiters(void);
-+    int nk_join(nk_thread_id_t t, void ** retval);
-+    int nk_join_all_children(int (*)(void*));
-+    
- #ifndef __LEGION__
--nk_thread_id_t nk_get_tid(void);
-+    nk_thread_id_t nk_get_tid(void);
- #endif
--nk_thread_id_t nk_get_parent_tid(void);
--
--/* thread local storage */
--typedef unsigned int nk_tls_key_t; 
--int nk_tls_key_create(nk_tls_key_t * key, void (*destructor)(void*));
--int nk_tls_key_delete(nk_tls_key_t key);
--void* nk_tls_get(nk_tls_key_t key);
--int nk_tls_set(nk_tls_key_t key, const void * val);
--
--
--/********* INTERNALS ***********/
--
-+    nk_thread_id_t nk_get_parent_tid(void);
-+    
-+    /* thread local storage */
-+    typedef unsigned int nk_tls_key_t;
-+    int nk_tls_key_create(nk_tls_key_t * key, void (*destructor)(void*));
-+    int nk_tls_key_delete(nk_tls_key_t key);
-+    void* nk_tls_get(nk_tls_key_t key);
-+    int nk_tls_set(nk_tls_key_t key, const void * val);
-+    
-+    
-+    /********* INTERNALS ***********/
-+    
- #define FXSAVE_SIZE 512
--
--
--/* FOR TLS */
-+    
-+    
-+    /* FOR TLS */
- #define TLS_MAX_KEYS 256
- #define MIN_DESTRUCT_ITER 4
- #define TLS_KEY_AVAIL(x) (((x) & 1) == 0)
- #define TLS_KEY_USABLE(x) ((unsigned long)(x) < (unsigned long)((x)+2))
-+    
-+    
-+    /* thread status */
-+    typedef enum {
-+        NK_THR_INIT,
-+        NK_THR_RUNNING,
-+        NK_THR_WAITING,
-+        NK_THR_SUSPENDED,
-+        NK_THR_EXITED
-+    } nk_thread_status_t;
-+    
-+    typedef struct nk_queue nk_thread_queue_t;
-+    
-+    struct nk_thread {
-+        uint64_t rsp; /* SHOULD NOT CHANGE POSITION */
-+        void * stack; /* SHOULD NOT CHANGE POSITION */
-+        uint16_t fpu_state_offset; /* SHOULD NOT CHANGE POSITION */
-+        
-+        nk_stack_size_t stack_size;
-+        unsigned long tid;
-+        
-+        int lock;
-+        
-+        nk_queue_entry_t runq_node; // formerly q_node
-+        nk_queue_entry_t thr_list_node;
-+        
-+        /* parent/child relationship */
-+        struct nk_thread * parent;
-+        struct list_head children;
-+        struct list_head child_node;
-+        unsigned long refcount;
-+        
-+        nk_thread_queue_t * waitq;
-+        nk_queue_entry_t wait_node;
-+        
-+        nk_thread_queue_t * cur_run_q;
-+        
-+        /* thread state */
-+        nk_thread_status_t status;
-+        
-+        int bound_cpu;
-+        
-+        uint8_t is_idle;
-+        
-+        void * output;
-+        void * input;
-+        nk_thread_fun_t fun;
-+        
-+        struct nk_virtual_console *vc;
-+        
-+        const void * tls[TLS_MAX_KEYS];
-+        
-+        uint8_t fpu_state[FXSAVE_SIZE] __align(16);
-+        
-+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
-+        rt_thread *rt_thread;
-+#endif
-+    } __packed;
-+    
-+    // internal thread representations
-+    typedef struct nk_thread nk_thread_t;
-+    
-+    struct nk_sched_state {
-+        nk_thread_queue_t * thread_list;
-+        uint_t num_threads;
-+    };
-+    
-+    
-+    nk_thread_id_t __thread_fork(void);
-+    nk_thread_t* nk_need_resched(void);
-+    int nk_sched_init(void);
-+    int nk_sched_init_ap(void);
-+    int nk_thread_start_sim (nk_thread_fun_t fun,
-+                 void *input,
-+                 void **output,
-+                 uint8_t is_detached,
-+                 nk_stack_size_t stack_size,
-+                 nk_thread_id_t *tid,
-+                 int cpu,
-+                 int rt_type,
-+                 rt_constraints *rt_constraints,
-+                 uint64_t rt_deadline);
-+    
-+    void nk_schedule(void);
-+    
-+    
-+    /* thread queues */
-+    
-+    nk_thread_queue_t * nk_thread_queue_create (void);
-+    void nk_thread_queue_destroy(nk_thread_queue_t * q);
-+    inline void nk_enqueue_thread_on_runq(nk_thread_t * t, int cpu);
-+    inline nk_thread_t* nk_dequeue_thread_from_runq(nk_thread_t * t);
-+    int nk_thread_queue_sleep(nk_thread_queue_t * q);
-+
-+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
-+    int sleep_on_queue(rt_thread *sleep);
-+#endif
- 
--
--/* thread status */
--typedef enum {
--    NK_THR_INIT,
--    NK_THR_RUNNING, 
--    NK_THR_WAITING,
--    NK_THR_SUSPENDED, 
--    NK_THR_EXITED
--} nk_thread_status_t;
--
--typedef struct nk_queue nk_thread_queue_t;
--
--struct nk_thread {
--    uint64_t rsp; /* SHOULD NOT CHANGE POSITION */
--    void * stack; /* SHOULD NOT CHANGE POSITION */
--    uint16_t fpu_state_offset; /* SHOULD NOT CHANGE POSITION */
--
--    nk_stack_size_t stack_size;
--    unsigned long tid;
--
--    int lock;
--
--    nk_queue_entry_t runq_node; // formerly q_node
--    nk_queue_entry_t thr_list_node;
--
--    /* parent/child relationship */
--    struct nk_thread * parent;
--    struct list_head children;
--    struct list_head child_node;
--    unsigned long refcount;
--
--    nk_thread_queue_t * waitq;
--    nk_queue_entry_t wait_node;
--
--    nk_thread_queue_t * cur_run_q;
--
--    /* thread state */
--    nk_thread_status_t status;
--
--    int bound_cpu;
--
--    uint8_t is_idle;
--
--    void * output;
--    void * input;
--    nk_thread_fun_t fun;
--
--    struct nk_virtual_console *vc;
--
--    const void * tls[TLS_MAX_KEYS];
--
--    uint8_t fpu_state[FXSAVE_SIZE] __align(16);
--} __packed;
--
--// internal thread representations
--typedef struct nk_thread nk_thread_t;
--
--struct nk_sched_state {
--    nk_thread_queue_t * thread_list;
--    uint_t num_threads;
--};
--
--
--
--nk_thread_id_t __thread_fork(void);
--nk_thread_t* nk_need_resched(void);
--int nk_sched_init(void);
--int nk_sched_init_ap(void);
--
--void nk_schedule(void);
--
--
--/* thread queues */
--
--nk_thread_queue_t * nk_thread_queue_create (void);
--void nk_thread_queue_destroy(nk_thread_queue_t * q);
--inline void nk_enqueue_thread_on_runq(nk_thread_t * t, int cpu);
--inline nk_thread_t* nk_dequeue_thread_from_runq(nk_thread_t * t);
--int nk_thread_queue_sleep(nk_thread_queue_t * q);
--int nk_thread_queue_wake_one(nk_thread_queue_t * q);
--int nk_thread_queue_wake_all(nk_thread_queue_t * q);
--
--struct nk_tls {
--    unsigned seq_num;
--    void (*destructor)(void*);
--};
--
--void nk_tls_test(void);
--
-+    int nk_thread_queue_wake_one(nk_thread_queue_t * q);
-+    int nk_thread_queue_wake_all(nk_thread_queue_t * q);
-+    
-+    struct nk_tls {
-+        unsigned seq_num;
-+        void (*destructor)(void*);
-+    };
-+    
-+    void nk_tls_test(void);
-+    
- #include <nautilus/percpu.h>
--
--static inline nk_thread_t*
--get_cur_thread (void)
--{
--    return (nk_thread_t*)per_cpu_get(cur_thread);
--}
--
--static inline void
--put_cur_thread (nk_thread_t * t) 
--{
--    per_cpu_put(cur_thread, t);
--}
--
--
-+    
-+    static inline nk_thread_t*
-+    get_cur_thread (void)
-+    {
-+        return (nk_thread_t*)per_cpu_get(cur_thread);
-+    }
-+    
-+    static inline void
-+    put_cur_thread (nk_thread_t * t)
-+    {
-+        per_cpu_put(cur_thread, t);
-+    }
-+    
-+    
-+    
- #endif /* !__ASSEMBLER */
--
-+    
- #define SAVE_GPRS() \
--    movq %rax, -8(%rsp); \
--    movq %rbx, -16(%rsp); \
--    movq %rcx, -24(%rsp); \
--    movq %rdx, -32(%rsp); \
--    movq %rsi, -40(%rsp); \
--    movq %rdi, -48(%rsp); \
--    movq %rbp, -56(%rsp); \
--    movq %r8,  -64(%rsp); \
--    movq %r9,  -72(%rsp); \
--    movq %r10, -80(%rsp); \
--    movq %r11, -88(%rsp); \
--    movq %r12, -96(%rsp); \
--    movq %r13, -104(%rsp); \
--    movq %r14, -112(%rsp); \
--    movq %r15, -120(%rsp); \
--    subq $120, %rsp; 
--
-+movq %rax, -8(%rsp); \
-+movq %rbx, -16(%rsp); \
-+movq %rcx, -24(%rsp); \
-+movq %rdx, -32(%rsp); \
-+movq %rsi, -40(%rsp); \
-+movq %rdi, -48(%rsp); \
-+movq %rbp, -56(%rsp); \
-+movq %r8,  -64(%rsp); \
-+movq %r9,  -72(%rsp); \
-+movq %r10, -80(%rsp); \
-+movq %r11, -88(%rsp); \
-+movq %r12, -96(%rsp); \
-+movq %r13, -104(%rsp); \
-+movq %r14, -112(%rsp); \
-+movq %r15, -120(%rsp); \
-+subq $120, %rsp; 
-+    
- #define RESTORE_GPRS() \
--    movq (%rsp), %r15; \
--    movq 8(%rsp), %r14; \
--    movq 16(%rsp), %r13; \
--    movq 24(%rsp), %r12; \
--    movq 32(%rsp), %r11; \
--    movq 40(%rsp), %r10; \
--    movq 48(%rsp), %r9; \
--    movq 56(%rsp), %r8; \
--    movq 64(%rsp), %rbp; \
--    movq 72(%rsp), %rdi; \
--    movq 80(%rsp), %rsi; \
--    movq 88(%rsp), %rdx; \
--    movq 96(%rsp), %rcx; \
--    movq 104(%rsp), %rbx; \
--    movq 112(%rsp), %rax; \
--    addq $120, %rsp; 
--
-+movq (%rsp), %r15; \
-+movq 8(%rsp), %r14; \
-+movq 16(%rsp), %r13; \
-+movq 24(%rsp), %r12; \
-+movq 32(%rsp), %r11; \
-+movq 40(%rsp), %r10; \
-+movq 48(%rsp), %r9; \
-+movq 56(%rsp), %r8; \
-+movq 64(%rsp), %rbp; \
-+movq 72(%rsp), %rdi; \
-+movq 80(%rsp), %rsi; \
-+movq 88(%rsp), %rdx; \
-+movq 96(%rsp), %rcx; \
-+movq 104(%rsp), %rbx; \
-+movq 112(%rsp), %rax; \
-+addq $120, %rsp; 
-+    
- #ifdef __cplusplus
- }
- #endif
-diff --git a/./include/nautilus/ticketlock.h b/../../nrt/nautilus/include/nautilus/ticketlock.h
-old mode 100644
-new mode 100755
-diff --git a/./include/nautilus/vc.h b/../../nrt/nautilus/include/nautilus/vc.h
-old mode 100644
-new mode 100755
-diff --git a/./iso/boot/grub/grub.cfg b/../../nrt/nautilus/iso/boot/grub/grub.cfg
-old mode 100644
-new mode 100755
-diff --git a/../../nrt/nautilus/iso/boot/nautilus.bin b/../../nrt/nautilus/iso/boot/nautilus.bin
-new file mode 100755
-index 0000000..3498d08
-Binary files /dev/null and b/../../nrt/nautilus/iso/boot/nautilus.bin differ
-diff --git a/../../nrt/nautilus/lib/.bitmap.o.cmd b/../../nrt/nautilus/lib/.bitmap.o.cmd
-new file mode 100644
-index 0000000..1b420ed
---- /dev/null
-+++ b/../../nrt/nautilus/lib/.bitmap.o.cmd
-@@ -0,0 +1,71 @@
-+cmd_lib/bitmap.o := gcc -Wp,-MD,lib/.bitmap.o.d   -D__NAUTILUS__ -Iinclude  -include include/autoconf.h -D__NAUTILUS__ -O2 -fno-omit-frame-pointer -ffreestanding -fno-stack-protector -fno-strict-aliasing -mno-red-zone -mcmodel=large -Wall -Wno-unused-function -Wno-unused-variable -fno-common -std=gnu99  -Wno-unused-but-set-variable -fgnu89-inline -g -m64  -Wno-pointer-sign    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(bitmap)"  -D"KBUILD_MODNAME=KBUILD_STR(bitmap)" -c -o lib/bitmap.o lib/bitmap.c
-+
-+deps_lib/bitmap.o := \
-+  lib/bitmap.c \
-+  include/autoconf.h \
-+    $(wildcard include/config/x86/64/host.h) \
-+    $(wildcard include/config/xeon/phi.h) \
-+    $(wildcard include/config/hvm/hrt.h) \
-+    $(wildcard include/config/max/cpus.h) \
-+    $(wildcard include/config/max/ioapics.h) \
-+    $(wildcard include/config/palacios.h) \
-+    $(wildcard include/config/use/naut/builtins.h) \
-+    $(wildcard include/config/cxx/support.h) \
-+    $(wildcard include/config/toolchain/root.h) \
-+    $(wildcard include/config/thread/exit/keycode.h) \
-+    $(wildcard include/config/use/ticketlocks.h) \
-+    $(wildcard include/config/virtual/console/serial/mirror.h) \
-+    $(wildcard include/config/virtual/console/serial/mirror/all.h) \
-+    $(wildcard include/config/fpu/save.h) \
-+    $(wildcard include/config/kick/schedule.h) \
-+    $(wildcard include/config/halt/while/idle.h) \
-+    $(wildcard include/config/thread/optimize.h) \
-+    $(wildcard include/config/use/idle/threads.h) \
-+    $(wildcard include/config/use/rt/scheduler.h) \
-+    $(wildcard include/config/debug/info.h) \
-+    $(wildcard include/config/debug/prints.h) \
-+    $(wildcard include/config/enable/asserts.h) \
-+    $(wildcard include/config/profile.h) \
-+    $(wildcard include/config/silence/undef/err.h) \
-+    $(wildcard include/config/enable/stack/check.h) \
-+    $(wildcard include/config/debug/paging.h) \
-+    $(wildcard include/config/debug/bootmem.h) \
-+    $(wildcard include/config/debug/buddy.h) \
-+    $(wildcard include/config/debug/kmem.h) \
-+    $(wildcard include/config/debug/fpu.h) \
-+    $(wildcard include/config/debug/smp.h) \
-+    $(wildcard include/config/debug/sfi.h) \
-+    $(wildcard include/config/debug/cxx.h) \
-+    $(wildcard include/config/debug/threads.h) \
-+    $(wildcard include/config/rt/debug.h) \
-+    $(wildcard include/con
\ No newline at end of file
diff --git a/./scripts/Kbuild.include b/../../nrt/nautilus/scripts/Kbuild.include
old mode 100644
new mode 100755
diff --git a/./scripts/Makefile b/../../nrt/nautilus/scripts/Makefile
old mode 100644
new mode 100755
diff --git a/./scripts/Makefile.build b/../../nrt/nautilus/scripts/Makefile.build
old mode 100644
new mode 100755
diff --git a/./scripts/Makefile.clean b/../../nrt/nautilus/scripts/Makefile.clean
old mode 100644
new mode 100755
diff --git a/./scripts/Makefile.host b/../../nrt/nautilus/scripts/Makefile.host
old mode 100644
new mode 100755
diff --git a/./scripts/Makefile.lib b/../../nrt/nautilus/scripts/Makefile.lib
old mode 100644
new mode 100755
diff --git a/./scripts/Makefile.modpost b/../../nrt/nautilus/scripts/Makefile.modpost
old mode 100644
new mode 100755
diff --git a/./scripts/basic/Makefile b/../../nrt/nautilus/scripts/basic/Makefile
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/scripts/basic/docproc b/../../nrt/nautilus/scripts/basic/docproc
new file mode 100755
index 0000000..7b255b4
Binary files /dev/null and b/../../nrt/nautilus/scripts/basic/docproc differ
diff --git a/./scripts/basic/docproc.c b/../../nrt/nautilus/scripts/basic/docproc.c
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/scripts/basic/fixdep b/../../nrt/nautilus/scripts/basic/fixdep
new file mode 100755
index 0000000..249f8c8
Binary files /dev/null and b/../../nrt/nautilus/scripts/basic/fixdep differ
diff --git a/./scripts/basic/fixdep.c b/../../nrt/nautilus/scripts/basic/fixdep.c
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/scripts/basic/split-include b/../../nrt/nautilus/scripts/basic/split-include
new file mode 100755
index 0000000..53b7bee
Binary files /dev/null and b/../../nrt/nautilus/scripts/basic/split-include differ
diff --git a/./scripts/basic/split-include.c b/../../nrt/nautilus/scripts/basic/split-include.c
old mode 100644
new mode 100755
diff --git a/./scripts/kallsyms.c b/../../nrt/nautilus/scripts/kallsyms.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/Makefile b/../../nrt/nautilus/scripts/kconfig/Makefile
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/POTFILES.in b/../../nrt/nautilus/scripts/kconfig/POTFILES.in
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/scripts/kconfig/conf b/../../nrt/nautilus/scripts/kconfig/conf
new file mode 100755
index 0000000..daf152a
Binary files /dev/null and b/../../nrt/nautilus/scripts/kconfig/conf differ
diff --git a/./scripts/kconfig/conf.c b/../../nrt/nautilus/scripts/kconfig/conf.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/confdata.c b/../../nrt/nautilus/scripts/kconfig/confdata.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/expr.c b/../../nrt/nautilus/scripts/kconfig/expr.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/expr.h b/../../nrt/nautilus/scripts/kconfig/expr.h
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/gconf.c b/../../nrt/nautilus/scripts/kconfig/gconf.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/gconf.glade b/../../nrt/nautilus/scripts/kconfig/gconf.glade
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/images.c b/../../nrt/nautilus/scripts/kconfig/images.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/kconfig_load.c b/../../nrt/nautilus/scripts/kconfig/kconfig_load.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/kxgettext.c b/../../nrt/nautilus/scripts/kconfig/kxgettext.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lex.zconf.c b/../../nrt/nautilus/scripts/kconfig/lex.zconf.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lex.zconf.c_shipped b/../../nrt/nautilus/scripts/kconfig/lex.zconf.c_shipped
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lkc.h b/../../nrt/nautilus/scripts/kconfig/lkc.h
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lkc_proto.h b/../../nrt/nautilus/scripts/kconfig/lkc_proto.h
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/BIG.FAT.WARNING b/../../nrt/nautilus/scripts/kconfig/lxdialog/BIG.FAT.WARNING
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/Makefile b/../../nrt/nautilus/scripts/kconfig/lxdialog/Makefile
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/check-lxdialog.sh b/../../nrt/nautilus/scripts/kconfig/lxdialog/check-lxdialog.sh
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/checklist.c b/../../nrt/nautilus/scripts/kconfig/lxdialog/checklist.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/colors.h b/../../nrt/nautilus/scripts/kconfig/lxdialog/colors.h
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/dialog.h b/../../nrt/nautilus/scripts/kconfig/lxdialog/dialog.h
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/inputbox.c b/../../nrt/nautilus/scripts/kconfig/lxdialog/inputbox.c
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/scripts/kconfig/lxdialog/lxdialog b/../../nrt/nautilus/scripts/kconfig/lxdialog/lxdialog
new file mode 100755
index 0000000..07a80f6
Binary files /dev/null and b/../../nrt/nautilus/scripts/kconfig/lxdialog/lxdialog differ
diff --git a/./scripts/kconfig/lxdialog/lxdialog.c b/../../nrt/nautilus/scripts/kconfig/lxdialog/lxdialog.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/menubox.c b/../../nrt/nautilus/scripts/kconfig/lxdialog/menubox.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/msgbox.c b/../../nrt/nautilus/scripts/kconfig/lxdialog/msgbox.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/textbox.c b/../../nrt/nautilus/scripts/kconfig/lxdialog/textbox.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/util.c b/../../nrt/nautilus/scripts/kconfig/lxdialog/util.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/lxdialog/yesno.c b/../../nrt/nautilus/scripts/kconfig/lxdialog/yesno.c
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/scripts/kconfig/mconf b/../../nrt/nautilus/scripts/kconfig/mconf
new file mode 100755
index 0000000..4953f56
Binary files /dev/null and b/../../nrt/nautilus/scripts/kconfig/mconf differ
diff --git a/./scripts/kconfig/mconf.c b/../../nrt/nautilus/scripts/kconfig/mconf.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/menu.c b/../../nrt/nautilus/scripts/kconfig/menu.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/qconf.cc b/../../nrt/nautilus/scripts/kconfig/qconf.cc
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/qconf.h b/../../nrt/nautilus/scripts/kconfig/qconf.h
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/symbol.c b/../../nrt/nautilus/scripts/kconfig/symbol.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/util.c b/../../nrt/nautilus/scripts/kconfig/util.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/zconf.gperf b/../../nrt/nautilus/scripts/kconfig/zconf.gperf
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/zconf.hash.c b/../../nrt/nautilus/scripts/kconfig/zconf.hash.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/zconf.hash.c_shipped b/../../nrt/nautilus/scripts/kconfig/zconf.hash.c_shipped
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/zconf.l b/../../nrt/nautilus/scripts/kconfig/zconf.l
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/zconf.tab.c b/../../nrt/nautilus/scripts/kconfig/zconf.tab.c
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/zconf.tab.c_shipped b/../../nrt/nautilus/scripts/kconfig/zconf.tab.c_shipped
old mode 100644
new mode 100755
diff --git a/./scripts/kconfig/zconf.y b/../../nrt/nautilus/scripts/kconfig/zconf.y
old mode 100644
new mode 100755
diff --git a/./scripts/mkmakefile b/../../nrt/nautilus/scripts/mkmakefile
old mode 100644
new mode 100755
diff --git a/./scripts/mksysmap b/../../nrt/nautilus/scripts/mksysmap
old mode 100644
new mode 100755
diff --git a/./scripts/setlocalversion b/../../nrt/nautilus/scripts/setlocalversion
old mode 100644
new mode 100755
diff --git a/./setups/config-leviathan b/../../nrt/nautilus/setups/config-leviathan
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/src/.DS_Store b/../../nrt/nautilus/src/.DS_Store
new file mode 100755
index 0000000..00e67e6
Binary files /dev/null and b/../../nrt/nautilus/src/.DS_Store differ
diff --git a/./src/Makefile b/../../nrt/nautilus/src/Makefile
old mode 100644
new mode 100755
diff --git a/./src/acpi/Makefile b/../../nrt/nautilus/src/acpi/Makefile
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/Makefile b/../../nrt/nautilus/src/acpi/acpica/Makefile
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/accommon.h b/../../nrt/nautilus/src/acpi/acpica/accommon.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/acconfig.h b/../../nrt/nautilus/src/acpi/acpica/acconfig.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/acdebug.h b/../../nrt/nautilus/src/acpi/acpica/acdebug.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/acglobal.h b/../../nrt/nautilus/src/acpi/acpica/acglobal.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/achware.h b/../../nrt/nautilus/src/acpi/acpica/achware.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/aclocal.h b/../../nrt/nautilus/src/acpi/acpica/aclocal.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/acmacros.h b/../../nrt/nautilus/src/acpi/acpica/acmacros.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/acnamesp.h b/../../nrt/nautilus/src/acpi/acpica/acnamesp.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/acobject.h b/../../nrt/nautilus/src/acpi/acpica/acobject.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/acstruct.h b/../../nrt/nautilus/src/acpi/acpica/acstruct.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/actables.h b/../../nrt/nautilus/src/acpi/acpica/actables.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/acutils.h b/../../nrt/nautilus/src/acpi/acpica/acutils.h
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/tbinstal.c b/../../nrt/nautilus/src/acpi/acpica/tbinstal.c
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/tbutils.c b/../../nrt/nautilus/src/acpi/acpica/tbutils.c
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/tbxface.c b/../../nrt/nautilus/src/acpi/acpica/tbxface.c
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/tbxfroot.c b/../../nrt/nautilus/src/acpi/acpica/tbxfroot.c
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/utalloc.c b/../../nrt/nautilus/src/acpi/acpica/utalloc.c
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/utglobal.c b/../../nrt/nautilus/src/acpi/acpica/utglobal.c
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/utmisc.c b/../../nrt/nautilus/src/acpi/acpica/utmisc.c
old mode 100644
new mode 100755
diff --git a/./src/acpi/acpica/utxferror.c b/../../nrt/nautilus/src/acpi/acpica/utxferror.c
old mode 100644
new mode 100755
diff --git a/./src/acpi/osl.c b/../../nrt/nautilus/src/acpi/osl.c
old mode 100644
new mode 100755
diff --git a/./src/acpi/tables.c b/../../nrt/nautilus/src/acpi/tables.c
old mode 100644
new mode 100755
diff --git a/./src/arch/Makefile b/../../nrt/nautilus/src/arch/Makefile
old mode 100644
new mode 100755
diff --git a/./src/arch/hrt/Makefile b/../../nrt/nautilus/src/arch/hrt/Makefile
old mode 100644
new mode 100755
diff --git a/./src/arch/hrt/asm/Makefile b/../../nrt/nautilus/src/arch/hrt/asm/Makefile
old mode 100644
new mode 100755
diff --git a/./src/arch/hrt/asm/boot.S b/../../nrt/nautilus/src/arch/hrt/asm/boot.S
old mode 100644
new mode 100755
diff --git a/./src/arch/hrt/early_mem.c b/../../nrt/nautilus/src/arch/hrt/early_mem.c
old mode 100644
new mode 100755
diff --git a/./src/arch/hrt/hrt.c b/../../nrt/nautilus/src/arch/hrt/hrt.c
old mode 100644
new mode 100755
diff --git a/./src/arch/hrt/init.c b/../../nrt/nautilus/src/arch/hrt/init.c
old mode 100644
new mode 100755
diff --git a/./src/arch/hrt/main.c b/../../nrt/nautilus/src/arch/hrt/main.c
old mode 100644
new mode 100755
diff --git a/./src/arch/hrt/mwait.c b/../../nrt/nautilus/src/arch/hrt/mwait.c
old mode 100644
new mode 100755
diff --git a/./src/arch/hrt/numa.c b/../../nrt/nautilus/src/arch/hrt/numa.c
old mode 100644
new mode 100755
diff --git a/./src/arch/hrt/shutdown.c b/../../nrt/nautilus/src/arch/hrt/shutdown.c
old mode 100644
new mode 100755
diff --git a/./src/arch/hrt/smp.c b/../../nrt/nautilus/src/arch/hrt/smp.c
old mode 100644
new mode 100755
diff --git a/./src/arch/k1om/Makefile b/../../nrt/nautilus/src/arch/k1om/Makefile
old mode 100644
new mode 100755
diff --git a/./src/arch/k1om/asm/Makefile b/../../nrt/nautilus/src/arch/k1om/asm/Makefile
old mode 100644
new mode 100755
diff --git a/./src/arch/k1om/asm/boot.S b/../../nrt/nautilus/src/arch/k1om/asm/boot.S
old mode 100644
new mode 100755
diff --git a/./src/arch/k1om/early_mem.c b/../../nrt/nautilus/src/arch/k1om/early_mem.c
old mode 100644
new mode 100755
diff --git a/./src/arch/k1om/init.c b/../../nrt/nautilus/src/arch/k1om/init.c
old mode 100644
new mode 100755
diff --git a/./src/arch/k1om/main.c b/../../nrt/nautilus/src/arch/k1om/main.c
old mode 100644
new mode 100755
diff --git a/./src/arch/k1om/numa.c b/../../nrt/nautilus/src/arch/k1om/numa.c
old mode 100644
new mode 100755
diff --git a/./src/arch/k1om/sfi.c b/../../nrt/nautilus/src/arch/k1om/sfi.c
old mode 100644
new mode 100755
diff --git a/./src/arch/k1om/smp.c b/../../nrt/nautilus/src/arch/k1om/smp.c
old mode 100644
new mode 100755
diff --git a/./src/arch/k1om/xeon_phi.c b/../../nrt/nautilus/src/arch/k1om/xeon_phi.c
old mode 100644
new mode 100755
diff --git a/./src/arch/x64/Makefile b/../../nrt/nautilus/src/arch/x64/Makefile
old mode 100644
new mode 100755
diff --git a/./src/arch/x64/asm/Makefile b/../../nrt/nautilus/src/arch/x64/asm/Makefile
old mode 100644
new mode 100755
diff --git a/./src/arch/x64/asm/boot.S b/../../nrt/nautilus/src/arch/x64/asm/boot.S
old mode 100644
new mode 100755
diff --git a/./src/arch/x64/early_mem.c b/../../nrt/nautilus/src/arch/x64/early_mem.c
old mode 100644
new mode 100755
diff --git a/./src/arch/x64/init.c b/../../nrt/nautilus/src/arch/x64/init.c
old mode 100644
new mode 100755
index 6d00f48..3d3e087
--- a/./src/arch/x64/init.c
+++ b/../../nrt/nautilus/src/arch/x64/init.c
@@ -63,6 +63,10 @@
 #include "palacios.h"
 #endif
 
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+#include <nautilus/rt_scheduler.h>
+#endif
+
 
 extern spinlock_t printk_lock;
 
@@ -203,7 +207,7 @@ int start_shell()
 {
   nk_thread_id_t tid;
 
-  nk_thread_start(shell, 0, 0, 0, PAGE_SIZE, &tid, -1);
+  // nk_thread_start(shell, 0, 0, 0, PAGE_SIZE, &tid, -1);
   
   printk("Shell launched\n");
 
@@ -234,7 +238,7 @@ init (unsigned long mbd,
     
     detect_cpu();
 
-    serial_puts("Here");
+    serial_puts("Testing... \n 1. \n 2. \n 3. \n");
 
     /* setup the temporary boot-time allocator */
     mm_boot_init(mbd);
@@ -318,16 +322,27 @@ init (unsigned long mbd,
 
     /* interrupts on */
     sti();
+    calibrate_apic(naut->sys.cpus[0]->apic);
+    
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+    printk("BEGIN TESTING THE REAL-TIME SCHEDULER\n");
+    rt_start(1000000, 10000000);
+#endif
+    
 
-    nk_vc_init();
+    while (1) {
+        udelay(10000);
+        printk("Inside init\n");
+    }
 
-    start_shell();
+    // runtime_init();
+    // nk_vc_init();
 
-    runtime_init();
+    // start_shell();
 
+    // printk("Nautilus boot thread yielding (indefinitely)\n");
     
-    printk("Nautilus boot thread yielding (indefinitely)\n");
-
-    /* we don't come back from this */
+    // /* we don't come back from this */
     idle(NULL, NULL);
 }
+
diff --git a/./src/arch/x64/main.c b/../../nrt/nautilus/src/arch/x64/main.c
old mode 100644
new mode 100755
diff --git a/./src/arch/x64/mwait.c b/../../nrt/nautilus/src/arch/x64/mwait.c
old mode 100644
new mode 100755
diff --git a/./src/arch/x64/numa.c b/../../nrt/nautilus/src/arch/x64/numa.c
old mode 100644
new mode 100755
diff --git a/./src/arch/x64/shutdown.c b/../../nrt/nautilus/src/arch/x64/shutdown.c
old mode 100644
new mode 100755
diff --git a/./src/arch/x64/smp.c b/../../nrt/nautilus/src/arch/x64/smp.c
old mode 100644
new mode 100755
diff --git a/./src/asm/Makefile b/../../nrt/nautilus/src/asm/Makefile
old mode 100644
new mode 100755
diff --git a/./src/asm/excp_early.S b/../../nrt/nautilus/src/asm/excp_early.S
old mode 100644
new mode 100755
diff --git a/./src/asm/smpboot.S b/../../nrt/nautilus/src/asm/smpboot.S
old mode 100644
new mode 100755
diff --git a/./src/asm/thread_lowlevel.S b/../../nrt/nautilus/src/asm/thread_lowlevel.S
old mode 100644
new mode 100755
diff --git a/./src/cxx/Makefile b/../../nrt/nautilus/src/cxx/Makefile
old mode 100644
new mode 100755
diff --git a/./src/cxx/cxxglue.cc b/../../nrt/nautilus/src/cxx/cxxglue.cc
old mode 100644
new mode 100755
diff --git a/./src/cxx/cxxinit.c b/../../nrt/nautilus/src/cxx/cxxinit.c
old mode 100644
new mode 100755
diff --git a/./src/dev/Kconfig b/../../nrt/nautilus/src/dev/Kconfig
old mode 100644
new mode 100755
diff --git a/./src/dev/Makefile b/../../nrt/nautilus/src/dev/Makefile
old mode 100644
new mode 100755
diff --git a/./src/dev/apic.c b/../../nrt/nautilus/src/dev/apic.c
old mode 100644
new mode 100755
index dca223e..4409ca5
--- a/./src/dev/apic.c
+++ b/../../nrt/nautilus/src/dev/apic.c
@@ -43,6 +43,20 @@
 #define APIC_PRINT(fmt, args...) INFO_PRINT("APIC: " fmt, ##args)
 #define APIC_WARN(fmt, args...)  WARN_PRINT("APIC: " fmt, ##args)
 
+typedef struct apic_tsc {
+    uint64_t tsc_diff;
+    uint64_t apic_diff;
+    uint64_t num_trials;
+    uint64_t sum_scale;
+    uint64_t scale;
+    uint64_t avg;
+} apic_tsc;
+
+static inline uint64_t get_tsc();
+static inline apic_tsc* init_apic_tsc();
+static inline void info_dump(apic_tsc *info);
+static inline void apic_loop(struct apic_dev *apic, apic_tsc *info);
+
 
 static const char * apic_err_codes[8] = {
     "[Send Checksum Error]",
@@ -410,9 +424,9 @@ apic_timer_setup (struct apic_dev * apic, uint32_t quantum)
     apic_write(apic, APIC_REG_LVTT, APIC_TIMER_DISABLE);
 
     /* TODO need to fixup when frequency is way off */
-    //busfreq = APIC_TIMER_DIV * NAUT_CONFIG_HZ*(0xffffffff - apic_read(apic, APIC_REG_TMCCT) + 1);
-    busfreq = 1100000000;
-    APIC_DEBUG("Detected APIC 0x%x bus frequency as %u.%u MHz\n", apic->id, busfreq/1000000, busfreq%1000000);
+    busfreq = APIC_TIMER_DIV * NAUT_CONFIG_HZ * (0xffffffff - apic_read(apic, APIC_REG_TMCCT) + 1);
+    apic->frequency = busfreq;
+    APIC_DEBUG("Detected APIC 0x%x bus frequency as %u.%u MHz\n", apic->id, busfreq / 1000000, busfreq % 1000000);
     tmp = busfreq/(1000/quantum)/APIC_TIMER_DIV;
     APIC_DEBUG("Setting APIC timer Initial Count Reg to %u\n", tmp);
     apic_write(apic, APIC_REG_TMICT, (tmp < APIC_TIMER_DIV) ? APIC_TIMER_DIV : tmp);
@@ -795,3 +809,72 @@ apic_init (struct cpu * core)
     apic_dump(apic);
 }
 
+inline void apic_oneshot_write(struct apic_dev *apic, uint64_t time) {
+    apic_write(apic, APIC_REG_LVTT, APIC_TIMER_ONESHOT | APIC_DEL_MODE_FIXED | APIC_TIMER_INT_VEC);
+    apic_write(apic, APIC_REG_TMDCR, APIC_TIMER_DIVCODE);
+    uint32_t count = (apic->scale == 0) ? (time / 43) : (time / (apic->scale + 1));
+    apic_write(apic, APIC_REG_TMICT, count);
+}
+
+               
+               
+void apic_oneshot_test(struct apic_dev *apic) {
+    apic_oneshot_write(apic, 2700000000);
+}
+
+
+
+static inline apic_tsc* init_apic_tsc() {
+    apic_tsc *info = (apic_tsc *)malloc(sizeof(apic_tsc));
+    info->tsc_diff = 0;
+    info-> apic_diff = 0;
+    info->num_trials = 0;
+    info->scale = 0;
+    info->sum_scale = 0;
+    info->avg = 0;
+    return info;
+}
+
+static inline void info_dump(apic_tsc *info) {
+    APIC_DEBUG("TSC difference: %llu\n", info->tsc_diff);
+    APIC_DEBUG("APIC difference: %llu\n", info->apic_diff);
+    APIC_DEBUG("Scale: %llu\n", info->scale);
+    APIC_DEBUG("Average scale: %llu\n", info->avg);
+    APIC_DEBUG("Number of trials: %llu\n", info->num_trials);
+}
+
+void calibrate_apic(struct apic_dev *apic) {
+    apic_tsc *info = init_apic_tsc();
+     {
+        const int num_tests = 50;
+         int i = 0;
+         for (i = 0; i < num_tests; i++) {
+             apic_loop(apic, info);
+             info_dump(info);
+         }
+         apic->scale = info->avg;
+    }
+}
+
+static inline void apic_loop(struct apic_dev *apic, apic_tsc *info) {
+    apic_write(apic, APIC_REG_LVTT, APIC_TIMER_ONESHOT | APIC_DEL_MODE_FIXED | APIC_TIMER_INT_VEC);
+    apic_write(apic, APIC_REG_TMDCR, APIC_TIMER_DIVCODE);
+    apic_write(apic, APIC_REG_TMICT, 0xffffffff);
+    uint64_t start = get_tsc();
+    const int max_time = 1000000;
+    udelay(start % 1000000);
+    apic_write(apic, APIC_REG_LVTT, APIC_TIMER_DISABLE);
+    uint64_t end = get_tsc();
+    info->tsc_diff = (end - start);
+    info->apic_diff = (0xffffffff - apic_read(apic, APIC_REG_TMCCT) + 1);
+    info->scale = (info->tsc_diff / info->apic_diff);
+    info->sum_scale += info->scale;
+    info->num_trials++;
+    info->avg = info->sum_scale / info->num_trials;
+}
+
+static inline uint64_t get_tsc() {
+    uint64_t hi, lo;
+    __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi));
+    return ((hi << 32) | lo);
+}
diff --git a/./src/dev/hpet.c b/../../nrt/nautilus/src/dev/hpet.c
old mode 100644
new mode 100755
diff --git a/./src/dev/i8254.c b/../../nrt/nautilus/src/dev/i8254.c
old mode 100644
new mode 100755
diff --git a/./src/dev/ioapic.c b/../../nrt/nautilus/src/dev/ioapic.c
old mode 100644
new mode 100755
diff --git a/./src/dev/kbd.c b/../../nrt/nautilus/src/dev/kbd.c
old mode 100644
new mode 100755
diff --git a/./src/dev/pci.c b/../../nrt/nautilus/src/dev/pci.c
old mode 100644
new mode 100755
diff --git a/./src/dev/serial.c b/../../nrt/nautilus/src/dev/serial.c
old mode 100644
new mode 100755
diff --git a/./src/dev/timer.c b/../../nrt/nautilus/src/dev/timer.c
old mode 100644
new mode 100755
diff --git a/./src/dev/vga.c b/../../nrt/nautilus/src/dev/vga.c
old mode 100644
new mode 100755
diff --git a/./src/dev/virtio_pci.c b/../../nrt/nautilus/src/dev/virtio_pci.c
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/Makefile b/../../nrt/nautilus/src/legion_runtime/Makefile
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/accessor.h b/../../nrt/nautilus/src/legion_runtime/accessor.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/activemsg.cc b/../../nrt/nautilus/src/legion_runtime/activemsg.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/activemsg.h b/../../nrt/nautilus/src/legion_runtime/activemsg.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/alt_mappers.cc b/../../nrt/nautilus/src/legion_runtime/alt_mappers.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/alt_mappers.h b/../../nrt/nautilus/src/legion_runtime/alt_mappers.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/arrays.h b/../../nrt/nautilus/src/legion_runtime/arrays.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/atomics.h b/../../nrt/nautilus/src/legion_runtime/atomics.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/common.h b/../../nrt/nautilus/src/legion_runtime/common.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/default_mapper.cc b/../../nrt/nautilus/src/legion_runtime/default_mapper.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/default_mapper.h b/../../nrt/nautilus/src/legion_runtime/default_mapper.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/field_tree.h b/../../nrt/nautilus/src/legion_runtime/field_tree.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/garbage_collection.cc b/../../nrt/nautilus/src/legion_runtime/garbage_collection.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/garbage_collection.h b/../../nrt/nautilus/src/legion_runtime/garbage_collection.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/interval_tree.h b/../../nrt/nautilus/src/legion_runtime/interval_tree.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion.cc b/../../nrt/nautilus/src/legion_runtime/legion.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion.h b/../../nrt/nautilus/src/legion_runtime/legion.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_allocation.h b/../../nrt/nautilus/src/legion_runtime/legion_allocation.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_logging.cc b/../../nrt/nautilus/src/legion_runtime/legion_logging.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_logging.h b/../../nrt/nautilus/src/legion_runtime/legion_logging.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_ops.cc b/../../nrt/nautilus/src/legion_runtime/legion_ops.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_ops.h b/../../nrt/nautilus/src/legion_runtime/legion_ops.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_profiling.h b/../../nrt/nautilus/src/legion_runtime/legion_profiling.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_spy.cc b/../../nrt/nautilus/src/legion_runtime/legion_spy.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_spy.h b/../../nrt/nautilus/src/legion_runtime/legion_spy.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_tasks.cc b/../../nrt/nautilus/src/legion_runtime/legion_tasks.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_tasks.h b/../../nrt/nautilus/src/legion_runtime/legion_tasks.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_trace.cc b/../../nrt/nautilus/src/legion_runtime/legion_trace.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_trace.h b/../../nrt/nautilus/src/legion_runtime/legion_trace.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_types.h b/../../nrt/nautilus/src/legion_runtime/legion_types.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/legion_utilities.h b/../../nrt/nautilus/src/legion_runtime/legion_utilities.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/lowlevel.cc b/../../nrt/nautilus/src/legion_runtime/lowlevel.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/lowlevel.h b/../../nrt/nautilus/src/legion_runtime/lowlevel.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/lowlevel_dma.cc b/../../nrt/nautilus/src/legion_runtime/lowlevel_dma.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/lowlevel_dma.h b/../../nrt/nautilus/src/legion_runtime/lowlevel_dma.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/lowlevel_gpu.cc b/../../nrt/nautilus/src/legion_runtime/lowlevel_gpu.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/lowlevel_gpu.h b/../../nrt/nautilus/src/legion_runtime/lowlevel_gpu.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/lowlevel_impl.h b/../../nrt/nautilus/src/legion_runtime/lowlevel_impl.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/mapping_utilities.cc b/../../nrt/nautilus/src/legion_runtime/mapping_utilities.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/mapping_utilities.h b/../../nrt/nautilus/src/legion_runtime/mapping_utilities.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/naut_debug.h b/../../nrt/nautilus/src/legion_runtime/naut_debug.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/rectangle_set.h b/../../nrt/nautilus/src/legion_runtime/rectangle_set.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/region_tree.cc b/../../nrt/nautilus/src/legion_runtime/region_tree.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/region_tree.h b/../../nrt/nautilus/src/legion_runtime/region_tree.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/runtime.cc b/../../nrt/nautilus/src/legion_runtime/runtime.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/runtime.h b/../../nrt/nautilus/src/legion_runtime/runtime.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/runtime.mk b/../../nrt/nautilus/src/legion_runtime/runtime.mk
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/shared_lowlevel.cc b/../../nrt/nautilus/src/legion_runtime/shared_lowlevel.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/shim_mapper.cc b/../../nrt/nautilus/src/legion_runtime/shim_mapper.cc
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/shim_mapper.h b/../../nrt/nautilus/src/legion_runtime/shim_mapper.h
old mode 100644
new mode 100755
diff --git a/./src/legion_runtime/utilities.h b/../../nrt/nautilus/src/legion_runtime/utilities.h
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/src/nautilus/.DS_Store b/../../nrt/nautilus/src/nautilus/.DS_Store
new file mode 100755
index 0000000..5008ddf
Binary files /dev/null and b/../../nrt/nautilus/src/nautilus/.DS_Store differ
diff --git a/../../nrt/nautilus/src/nautilus/.rt_scheduler.c.swp b/../../nrt/nautilus/src/nautilus/.rt_scheduler.c.swp
new file mode 100644
index 0000000..66a8358
Binary files /dev/null and b/../../nrt/nautilus/src/nautilus/.rt_scheduler.c.swp differ
diff --git a/./src/nautilus/Makefile b/../../nrt/nautilus/src/nautilus/Makefile
old mode 100644
new mode 100755
index d5b6991..fc04f3a
--- a/./src/nautilus/Makefile
+++ b/../../nrt/nautilus/src/nautilus/Makefile
@@ -34,4 +34,5 @@ obj-y += \
 
 obj-$(NAUT_CONFIG_PROFILE) += instrument.o
 obj-$(NAUT_CONFIG_XEON_PHI) += sfi.o
+obj-$(NAUT_CONFIG_USE_RT_SCHEDULER) += rt_scheduler.o
 
diff --git a/./src/nautilus/acpi.c b/../../nrt/nautilus/src/nautilus/acpi.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/backtrace.c b/../../nrt/nautilus/src/nautilus/backtrace.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/barrier.c b/../../nrt/nautilus/src/nautilus/barrier.c
old mode 100644
new mode 100755
index be16ed0..b198303
--- a/./src/nautilus/barrier.c
+++ b/../../nrt/nautilus/src/nautilus/barrier.c
@@ -375,23 +375,23 @@ barrier_func2 (void * in, void ** out)
  * the machine
  *
  */
-void nk_barrier_test(void)
-{
-    nk_barrier_t * b;
-    b = malloc(sizeof(nk_barrier_t));
-    if (!b) {
-        ERROR_PRINT("could not allocate barrier\n");
-        return;
-    }
-
-    nk_barrier_init(b, 3);
-    nk_thread_start(barrier_func1, b, NULL, 1, TSTACK_DEFAULT, NULL, 1);
-    nk_thread_start(barrier_func2, b, NULL, 1, TSTACK_DEFAULT, NULL, 2);
-
-    nk_barrier_wait(b);
-
-    printk("Barrier test successful\n");
-    nk_barrier_destroy(b);
-    free(b);
-}
+//void nk_barrier_test(void)
+//{
+//    nk_barrier_t * b;
+//    b = malloc(sizeof(nk_barrier_t));
+//    if (!b) {
+//        ERROR_PRINT("could not allocate barrier\n");
+//        return;
+//    }
+//
+//    nk_barrier_init(b, 3);
+//    nk_thread_start(barrier_func1, b, NULL, 1, TSTACK_DEFAULT, NULL, 1);
+//    nk_thread_start(barrier_func2, b, NULL, 1, TSTACK_DEFAULT, NULL, 2);
+//
+//    nk_barrier_wait(b);
+//
+//    printk("Barrier test successful\n");
+//    nk_barrier_destroy(b);
+//    free(b);
+//}
 
diff --git a/./src/nautilus/condvar.c b/../../nrt/nautilus/src/nautilus/condvar.c
old mode 100644
new mode 100755
index 00a96c4..e89c5f8
--- a/./src/nautilus/condvar.c
+++ b/../../nrt/nautilus/src/nautilus/condvar.c
@@ -238,22 +238,22 @@ test3 (void * in, void ** out)
 }
 
 
-void 
-nk_condvar_test (void)
-{
-
-    nk_condvar_t * c = malloc(sizeof(nk_condvar_t));
-    if (!c) {
-        ERROR_PRINT("Could not allocate condvar\n");
-        return;
-    }
-
-    nk_condvar_init(c);
-
-    nk_thread_start(test1, c, NULL, 1, TSTACK_DEFAULT, NULL, 1);
-    nk_thread_start(test2, c, NULL, 1, TSTACK_DEFAULT, NULL, 2);
-    nk_thread_start(test3, c, NULL, 1, TSTACK_DEFAULT, NULL, 3);
-
-}
+//void 
+//nk_condvar_test (void)
+//{
+//
+//    nk_condvar_t * c = malloc(sizeof(nk_condvar_t));
+//    if (!c) {
+//        ERROR_PRINT("Could not allocate condvar\n");
+//        return;
+//    }
+//
+//    nk_condvar_init(c);
+//
+//    nk_thread_start(test1, c, NULL, 1, TSTACK_DEFAULT, NULL, 1);
+//    nk_thread_start(test2, c, NULL, 1, TSTACK_DEFAULT, NULL, 2);
+//    nk_thread_start(test3, c, NULL, 1, TSTACK_DEFAULT, NULL, 3);
+//
+//}
 
 
diff --git a/./src/nautilus/cpu.c b/../../nrt/nautilus/src/nautilus/cpu.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/cpuid.c b/../../nrt/nautilus/src/nautilus/cpuid.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/doprnt.c b/../../nrt/nautilus/src/nautilus/doprnt.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/fmtout.c b/../../nrt/nautilus/src/nautilus/fmtout.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/fpu.c b/../../nrt/nautilus/src/nautilus/fpu.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/hashtable.c b/../../nrt/nautilus/src/nautilus/hashtable.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/idle.c b/../../nrt/nautilus/src/nautilus/idle.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/idt.c b/../../nrt/nautilus/src/nautilus/idt.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/instrument.c b/../../nrt/nautilus/src/nautilus/instrument.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/irq.c b/../../nrt/nautilus/src/nautilus/irq.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/libccompat.c b/../../nrt/nautilus/src/nautilus/libccompat.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/mb_utils.c b/../../nrt/nautilus/src/nautilus/mb_utils.c
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/src/nautilus/mm/.buddy.c.swp b/../../nrt/nautilus/src/nautilus/mm/.buddy.c.swp
new file mode 100644
index 0000000..73ce12b
Binary files /dev/null and b/../../nrt/nautilus/src/nautilus/mm/.buddy.c.swp differ
diff --git a/./src/nautilus/mm/Makefile b/../../nrt/nautilus/src/nautilus/mm/Makefile
old mode 100644
new mode 100755
diff --git a/./src/nautilus/mm/boot_mm.c b/../../nrt/nautilus/src/nautilus/mm/boot_mm.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/mm/buddy.c b/../../nrt/nautilus/src/nautilus/mm/buddy.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/mm/kmem.c b/../../nrt/nautilus/src/nautilus/mm/kmem.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/msr.c b/../../nrt/nautilus/src/nautilus/msr.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/naut_string.c b/../../nrt/nautilus/src/nautilus/naut_string.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/nemo.c b/../../nrt/nautilus/src/nautilus/nemo.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/numa.c b/../../nrt/nautilus/src/nautilus/numa.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/paging.c b/../../nrt/nautilus/src/nautilus/paging.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/pmc.c b/../../nrt/nautilus/src/nautilus/pmc.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/printk.c b/../../nrt/nautilus/src/nautilus/printk.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/queue.c b/../../nrt/nautilus/src/nautilus/queue.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/random.c b/../../nrt/nautilus/src/nautilus/random.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/rbtree.c b/../../nrt/nautilus/src/nautilus/rbtree.c
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/src/nautilus/rt_scheduler.c b/../../nrt/nautilus/src/nautilus/rt_scheduler.c
new file mode 100755
index 0000000..cd2d87a
--- /dev/null
+++ b/../../nrt/nautilus/src/nautilus/rt_scheduler.c
@@ -0,0 +1,1771 @@
+
+//  rt_scheduler.c
+//  rt_scheduler_test
+//
+//  Created by Chris Beauchene on 2/15/16.
+//  Copyright  2016 EECS 395/495 Kernel Development. All rights reserved.
+//
+//
+
+
+
+#include <nautilus/nautilus.h>
+#include <nautilus/thread.h>
+#include <nautilus/rt_scheduler.h>
+#include <nautilus/irq.h>
+#include <nautilus/cpu.h>
+#include <nautilus/cpuid.h>
+#include <dev/apic.h>
+#include <dev/timer.h>
+
+
+#define INFO(fmt, args...) printk("RT SCHED: " fmt, ##args)
+#define RT_SCHED_PRINT(fmt, args...) printk("RT SCHED: " fmt, ##args)
+#define RT_SCHED_ERROR(fmt, args...) printk("RT SCHED ERROR: " fmt, ##args)
+
+#define RT_SCHED_DEBUG(fmt, args...)
+#ifdef NAUT_CONFIG_DEBUG_RT_SCHEDULER
+#undef RT_SCHED_DEBUG
+#define RT_SCHED_DEBUG(fmt, args...) printk("RT SCHED: " fmt, ##args)
+#endif
+
+#define parent(i) ((i) ? (((i) - 1) >> 1) : 0)
+#define left_child(i) (((i) << 1) + 1)
+#define right_child(i) (((i) << 1) + 2)
+
+#ifndef MIN
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+#endif
+
+#ifndef MAX
+#define MAX(x, y) (((x) >(y)) ? (x) : (y))
+#endif
+
+#define APERIODIC 0
+#define SPORADIC 1
+#define PERIODIC 2
+
+#define PERIODIC_UTIL 55000
+#define SPORADIC_UTIL 18000
+#define APERIODIC_UTIL 9000
+
+#define ARRIVED 0
+#define ADMITTED 1
+#define TOBE_REMOVED 2
+#define REMOVED 3
+#define SLEEPING 4
+#define DENIED 5
+
+#define RUNNABLE_QUEUE 0
+#define PENDING_QUEUE 1
+#define APERIODIC_QUEUE 2
+
+#define MAX_QUEUE 256
+
+#define QUANTUM 10000000
+
+
+#define PAD 8
+
+#define MALLOC(x) ({ void *p  = malloc((x)+2*PAD); if (!p) { panic("Failed to Allocate %d bytes\n",x); } memset(p,0,(x)+2*PAD); p+PAD; })
+#define FREE(x) do {free(x-PAD); x=0; } while (0)
+
+typedef struct rt_thread_sim {
+    rt_type type;
+    queue_type q_type;
+    rt_status status;
+    rt_constraints *constraints;
+
+    uint64_t start_time; 
+    uint64_t run_time;
+    uint64_t deadline;
+    uint64_t exit_time;
+
+} rt_thread_sim;
+
+typedef struct rt_queue_sim {
+    queue_type type;
+    uint64_t size, head, tail;
+    rt_thread_sim *threads[0];
+} rt_queue_sim;
+
+typedef struct rt_simulator {
+    rt_queue_sim *runnable;
+    rt_queue_sim *pending;
+    rt_queue_sim *aperiodic;
+} rt_simulator;
+
+static rt_simulator* init_simulator();
+
+static int check_deadlines(rt_thread *t);
+static inline void update_periodic(rt_thread *t);
+static void set_timer(rt_scheduler *scheduler, rt_thread *thread, uint64_t end_time, uint64_t slack);
+
+static rt_thread_sim* rt_need_resched_logic(rt_simulator *simulator, rt_thread_sim *thread, uint64_t time, int *failed, int *finished_max, rt_thread_sim *max);
+
+static uint64_t set_timer_logic(rt_simulator *simulator, rt_thread_sim *thread, uint64_t time);
+static void enqueue_thread_logic(rt_queue_sim *queue, rt_thread_sim *thread);
+static rt_thread_sim* dequeue_thread_logic(rt_queue_sim *queue);
+static inline void update_exit_logic(rt_thread_sim *t, uint64_t time);
+static inline void update_enter_logic(rt_thread_sim *t, uint64_t time);
+static int check_deadlines_logic(rt_thread_sim *t, uint64_t time);
+static inline void update_periodic_logic(rt_thread_sim *t, uint64_t time);
+static void copy_threads_sim(rt_simulator *simulator, rt_scheduler *scheduler, rt_thread *new, rt_thread *this);
+static void free_threads_sim(rt_simulator *simulator);
+
+static rt_thread_sim* max_periodic(rt_simulator *simulator);
+static rt_thread_sim* min_periodic(rt_simulator *simulator);
+
+static inline uint64_t get_min_per(rt_queue *runnable, rt_queue *queue, rt_thread *thread);
+static inline uint64_t get_avg_per(rt_queue *runnable, rt_queue *pending, rt_thread *thread);
+static inline uint64_t get_per_util(rt_queue *runnable, rt_queue *pending);
+static inline uint64_t get_spor_util(rt_queue *runnable);
+static inline uint64_t umin(uint64_t x, uint64_t y);
+
+static rt_list* rt_list_init();
+static rt_node* rt_node_init(rt_thread *t);
+
+static void sched_sim(void *scheduler);
+static int test_sum(void);
+
+rt_thread* rt_thread_init(int type,
+                          rt_constraints *constraints,
+                          uint64_t deadline,
+                          struct nk_thread *thread
+                          )
+{
+    rt_thread *t = (rt_thread *)MALLOC(sizeof(rt_thread));
+    t->type = type;
+    t->status = ARRIVED;
+    t->constraints = constraints;
+    t->start_time = 0;
+    t->run_time = 0;
+    t->deadline = 0;
+    t->parent = NULL;
+
+
+    t->holding = rt_list_init();
+    t->waiting = rt_list_init();
+    t->children = rt_list_init();
+
+    if (type == PERIODIC)
+    {
+        t->deadline = cur_time() + constraints->periodic.period;
+    } else if (type == SPORADIC)
+    {
+        t->deadline = cur_time() + deadline;
+    }
+    
+    thread->rt_thread = t;
+    t->thread = thread;
+    return t;
+}
+
+static rt_list* rt_list_init() {
+    rt_list *list = (rt_list *)MALLOC(sizeof(rt_list));
+    list->head = NULL;
+    list->tail = NULL;
+    return list;
+}
+
+static rt_node* rt_node_init(rt_thread *t) {
+    rt_node *node = (rt_node *)MALLOC(sizeof(rt_node));
+    node->thread = t;
+    node->next = NULL;
+    node->prev = NULL;
+    return node;
+}
+
+int rt_list_empty(rt_list *l) {
+    return (l->head == NULL);
+}
+
+void list_enqueue(rt_list *l, rt_thread *t) {
+    if (l == NULL) {
+        RT_SCHED_ERROR("RT_LIST IS UNINITIALIZED.\n");
+        return;
+    }
+
+    if (l->head == NULL) {
+        l->head = rt_node_init(t);
+        l->tail = l->head;
+        return;
+    }
+
+    rt_node *n = l->tail;
+    l->tail = rt_node_init(t);
+    l->tail->prev = n;
+    n->next = l->tail;
+}
+rt_thread* list_dequeue(rt_list *l) {
+    if (l == NULL) {
+        RT_SCHED_ERROR("RT_LIST IS UNINITIALIZED.\n");
+        return NULL;
+    }
+
+    if (l->head == NULL) {
+        return NULL;
+    }
+
+    rt_node *n = l->head;
+    l->head = n->next;
+    l->head->prev = NULL;
+    n->next = NULL;
+    n->prev = NULL;
+    return n->thread;
+}
+
+rt_thread* list_remove(rt_list *l, rt_thread *t) {
+    rt_node *n = l->head;
+    while (n != NULL) {
+        if (n->thread == t) {
+            rt_node *tmp = n->next;
+            if (n->next != NULL) {
+                n->next->prev = n->prev;
+            }
+            if (n->prev != NULL) {
+                n->prev->next = tmp;
+            }
+            n->next = NULL;
+            n->prev = NULL;
+            n->thread->status = REMOVED;
+            return n->thread;
+        }
+        n = n->next;
+    }
+    return NULL;
+}
+
+
+// B goes on A's waiting Q
+// A goes on B's holding Q
+
+void wait_on(rt_thread *A, rt_thread *B) {
+    list_enqueue(A->waiting, B);
+    list_enqueue(B->holding, A);
+}
+
+// Remove B from A's waiting Q
+// Remove A from B's holding Q
+
+void wake_up(rt_thread *A, rt_thread *B) {
+    list_remove(A->waiting, B);
+    list_remove(B->holding, A);
+
+    if (rt_list_empty(A->waiting)) {
+        struct sys_info *sys = per_cpu_get(system);
+        rt_scheduler *sched = sys->cpus[my_cpu_id()]->rt_sched;
+        if (A->status == TOBE_REMOVED || A->status == REMOVED) return;
+
+        list_remove(sched->sleeping, A);
+        if (A->status != TOBO_REMOVED && A->status != REMOVED) {
+            A->status = ARRIVED;
+            list_enqueue(sched->arrival, A);
+        }
+    }
+}
+
+void wake_up_all(rt_thread *A) {
+    rt_thread *woke = list_dequeue(A->holding);
+
+    while (woke != NULL) {
+        wake_up(woke, A);
+        woke = list_dequeue(A->holding);
+    }
+}
+
+rt_scheduler* rt_scheduler_init(rt_thread *main_thread)
+{
+    rt_scheduler* scheduler = (rt_scheduler *)MALLOC(sizeof(rt_scheduler));
+    rt_queue *runnable = (rt_queue *)MALLOC(sizeof(rt_queue) + MAX_QUEUE * sizeof(rt_thread *));
+    rt_queue *pending = (rt_queue *)MALLOC(sizeof(rt_queue) + MAX_QUEUE * sizeof(rt_thread *));
+    rt_queue *aperiodic = (rt_queue *)MALLOC(sizeof(rt_queue) + MAX_QUEUE * sizeof(rt_thread *));
+
+    tsc_info *info = (tsc_info *)MALLOC(sizeof(tsc_info));
+
+	scheduler->main_thread = main_thread;
+
+    if (!scheduler || !runnable || ! pending || !aperiodic || !info) {
+        RT_SCHED_ERROR("Could not allocate rt scheduler\n");
+        return NULL;
+    } else {
+#define ZERO(x) memset(x, 0, sizeof(*x))
+#define ZERO_QUEUE(x) memset(x, 0, sizeof(rt_queue) + MAX_QUEUE * sizeof(rt_thread *))
+
+		ZERO(scheduler);
+		ZERO(info);
+		ZERO_QUEUE(runnable);
+		ZERO_QUEUE(pending);
+		ZERO_QUEUE(aperiodic);
+		
+        runnable->type = RUNNABLE_QUEUE;
+        runnable->size = 0;
+        scheduler->runnable = runnable;
+        
+        pending->type = PENDING_QUEUE;
+        pending->size = 0;
+        scheduler->pending = pending;
+        
+        aperiodic->type = APERIODIC_QUEUE;
+        aperiodic->size = 0;
+        scheduler->aperiodic = aperiodic;
+		
+        rt_list *arrival = rt_list_init();
+        rt_list *exited = rt_list_init();
+        rt_list *sleeping = rt_list_init();
+
+        if (!arrival || !exited || !sleeping) {
+            RT_SCHED_ERROR("Could not allocate rt scheduler's list.\n");
+            return NULL;
+        } 
+
+		scheduler->arrival = arrival;
+        scheduler->exited = exited;
+        scheduler->sleeping = sleeping;
+        scheduler->tsc = info;
+
+    }
+    return scheduler;
+}
+
+static rt_simulator* init_simulator() {
+    rt_simulator* simulator = (rt_simulator *)MALLOC(sizeof(rt_simulator));
+    rt_queue_sim *runnable = (rt_queue_sim *)MALLOC(sizeof(rt_queue_sim) + MAX_QUEUE * sizeof(rt_thread_sim *));
+    rt_queue_sim *pending = (rt_queue_sim *)MALLOC(sizeof(rt_queue_sim) + MAX_QUEUE * sizeof(rt_thread_sim *));
+    rt_queue_sim *aperiodic = (rt_queue_sim *)MALLOC(sizeof(rt_queue_sim) + MAX_QUEUE * sizeof(rt_thread_sim *));
+
+    if (!simulator || !runnable || ! pending || !aperiodic) {
+        RT_SCHED_ERROR("Could not allocate rt simulator\n");
+        return NULL;
+    } else {
+        runnable->type = RUNNABLE_QUEUE;
+        runnable->size = 0;
+        simulator->runnable = runnable;
+        
+        pending->type = PENDING_QUEUE;
+        pending->size = 0;
+        simulator->pending = pending;
+        
+        aperiodic->type = APERIODIC_QUEUE;
+        aperiodic->size = 0;
+        simulator->aperiodic = aperiodic;
+    }
+    return simulator;
+}
+
+
+void enqueue_thread(rt_queue *queue, rt_thread *thread)
+{
+    if (queue->type == RUNNABLE_QUEUE)
+    {
+        if (queue->size == MAX_QUEUE)
+        {
+            RT_SCHED_ERROR("RUN QUEUE IS FULL!");
+            return;
+        }
+        
+        uint64_t pos = queue->size++;
+        queue->threads[pos] = thread;
+        while (queue->threads[parent(pos)]->deadline > thread->deadline && pos != parent(pos))
+        {
+            queue->threads[pos] = queue->threads[parent(pos)];
+            pos = parent(pos);
+        }
+        thread->q_type = RUNNABLE_QUEUE;
+        queue->threads[pos] = thread;
+        
+    } else if (queue->type == PENDING_QUEUE)
+    {
+        if (queue->size == MAX_QUEUE)
+        {
+            RT_SCHED_ERROR("PENDING QUEUE IS FULL!");
+            return;
+        }
+        
+        uint64_t pos = queue->size++;
+        queue->threads[pos] = thread;
+        while (queue->threads[parent(pos)]->deadline > thread->deadline && pos != parent(pos))
+        {
+            queue->threads[pos] = queue->threads[parent(pos)];
+            pos = parent(pos);
+        }
+        thread->q_type = PENDING_QUEUE;
+        queue->threads[pos] = thread;
+        
+    } else if (queue->type == APERIODIC_QUEUE)
+    {
+        if (queue->size == MAX_QUEUE) {
+            return;
+        }
+        
+        uint64_t pos = queue->size++;
+        queue->threads[pos] = thread;
+        while (queue->threads[parent(pos)]->constraints->aperiodic.priority > thread->constraints->aperiodic.priority && pos != parent(pos))
+        {
+            queue->threads[pos] = queue->threads[parent(pos)];
+            pos = parent(pos);
+        }
+        thread->q_type = APERIODIC_QUEUE;
+        queue->threads[pos] = thread;
+    } 
+}
+
+rt_thread* remove_thread(rt_thread *thread) {
+    rt_queue *queue = NULL;
+    queue_type type = thread->q_type;
+    struct sys_info *sys = per_cpu_get(system);
+    rt_scheduler *scheduler = sys->cpus[my_cpu_id()]->rt_sched;
+
+    if (type == RUNNABLE_QUEUE) {
+        queue = scheduler->runnable;
+
+        if (queue == NULL) {
+            RT_SCHED_ERROR("RUNNABLE QUEUE NOT FOUND\n");
+            return NULL;
+        }
+
+        if (queue->size < 1) {
+            RT_SCHED_ERROR("RUNNABLE QUEUE IS EMPTY. CAN'T REMOVE.\n");
+            return NULL;
+        }
+
+        rt_thread *target_thread, *last;
+        int i = 0, target_index = queue->size, now, child;
+        for (i = 0; i < queue->size; i++) {
+            if (thread == queue->threads[i]) {
+                target_index = i;
+                break;
+            }
+        }
+
+        if (target_index == queue->size) {
+            RT_SCHED_ERROR("THREAD NOT FOUND ON QUEUE\n");
+            return NULL;
+        }
+        target_thread = queue->threads[target_index];
+        last = queue->threads[--queue->size];
+
+        for (now = target_index; left_child(now) < queue->size; now = child)
+        {
+            child = left_child(now);
+            if (child < queue->size && queue->threads[right_child(now)]->deadline < queue->threads[left_child(now)]->deadline)
+            {
+                child = right_child(now);
+            }
+            
+            if (last->deadline > queue->threads[child]->deadline)
+            {
+                queue->threads[now] = queue->threads[child];
+            } else {
+                break;
+            }
+        }
+        
+        queue->threads[now] = last;
+        return thread;
+    } else if (type == PENDING_QUEUE) {
+        queue = scheduler->pending;
+
+        if (queue == NULL) {
+            RT_SCHED_ERROR("PENDING QUEUE NOT FOUND\n");
+            return NULL;
+        }
+
+        if (queue->size < 1) {
+            RT_SCHED_ERROR("PENDING QUEUE IS EMPTY. CAN'T REMOVE.\n");
+            return NULL;
+        }
+
+        rt_thread *target_thread, *last;
+        int i = 0, target_index = queue->size, now, child;
+        for (i = 0; i < queue->size; i++) {
+            if (thread == queue->threads[i]) {
+                target_index = i;
+                break;
+            }
+        }
+
+        if (target_index == queue->size) {
+            RT_SCHED_ERROR("THREAD NOT FOUND ON QUEUE\n");
+            return NULL;
+        }
+        target_thread = queue->threads[target_index];
+        last = queue->threads[--queue->size];
+
+        for (now = target_index; left_child(now) < queue->size; now = child)
+        {
+            child = left_child(now);
+            if (child < queue->size && queue->threads[right_child(now)]->deadline < queue->threads[left_child(now)]->deadline)
+            {
+                child = right_child(now);
+            }
+            
+            if (last->deadline > queue->threads[child]->deadline)
+            {
+                queue->threads[now] = queue->threads[child];
+            } else {
+                break;
+            }
+        }
+        
+        queue->threads[now] = last;
+        return thread;
+    }  else if (type == APERIODIC_QUEUE) {
+        queue = scheduler->aperiodic;
+
+        if (queue == NULL) {
+            RT_SCHED_ERROR("APERIODIC QUEUE NOT FOUND\n");
+            return NULL;
+        }
+
+        if (queue->size < 1) {
+            RT_SCHED_ERROR("APERIODIC QUEUE IS EMPTY. CAN'T REMOVE.\n");
+            return NULL;
+        }
+
+        rt_thread *target_thread, *last;
+        int i = 0, target_index = queue->size, now, child;
+        for (i = 0; i < queue->size; i++) {
+            if (thread == queue->threads[i]) {
+                target_index = i;
+                break;
+            }
+        }
+
+        if (target_index == queue->size) {
+            RT_SCHED_ERROR("THREAD NOT FOUND ON QUEUE\n");
+            return NULL;
+        }
+        target_thread = queue->threads[target_index];
+        last = queue->threads[--queue->size];
+
+        for (now = target_index; left_child(now) < queue->size; now = child)
+        {
+            child = left_child(now);
+            if (child < queue->size && queue->threads[right_child(now)]->constraints->aperiodic.priority < queue->threads[left_child(now)]->constraints->aperiodic.priority)
+            {
+                child = right_child(now);
+            }
+            
+            if (last->constraints->aperiodic.priority > queue->threads[child]->constraints->aperiodic.priority)
+            {
+                queue->threads[now] = queue->threads[child];
+            } else {
+                break;
+            }
+        }
+        
+        queue->threads[now] = last;
+        return thread;
+    }
+    return NULL;
+}
+
+rt_thread* dequeue_thread(rt_queue *queue)
+{
+    if (queue->type == RUNNABLE_QUEUE)
+    {
+        if (queue->size < 1)
+        {
+            RT_SCHED_ERROR("RUNNABLE QUEUE EMPTY! CAN'T DEQUEUE!\n");
+            return NULL;
+        }
+        
+        rt_thread *min, *last;
+        int now, child;
+        
+        min = queue->threads[0];
+        last = queue->threads[--queue->size];
+        
+        for (now = 0; left_child(now) < queue->size; now = child)
+        {
+            child = left_child(now);
+            if (child < queue->size && queue->threads[right_child(now)]->deadline < queue->threads[left_child(now)]->deadline)
+            {
+                child = right_child(now);
+            }
+            
+            if (last->deadline > queue->threads[child]->deadline)
+            {
+                queue->threads[now] = queue->threads[child];
+            } else {
+                break;
+            }
+        }
+        
+        queue->threads[now] = last;
+
+        if (min->status == TOBE_REMOVED) {
+            min->status = REMOVED;
+            return dequeue_thread(queue);
+        }
+        
+        return min;
+    } else if (queue->type == PENDING_QUEUE)
+    {
+        if (queue->size < 1)
+        {
+            RT_SCHED_ERROR("PENDING QUEUE EMPTY! CAN'T DEQUEUE!\n");
+            return NULL;
+        }
+        rt_thread *min, *last;
+        int now, child;
+        
+        min = queue->threads[0];
+        last = queue->threads[--queue->size];
+        
+        for (now = 0; left_child(now) < queue->size; now = child)
+        {
+            child = left_child(now);
+            if (child < queue->size && queue->threads[right_child(now)]->deadline < queue->threads[left_child(now)]->deadline)
+            {
+                child = right_child(now);
+            }
+            
+            if (last->deadline > queue->threads[child]->deadline)
+            {
+                queue->threads[now] = queue->threads[child];
+            } else {
+                break;
+            }
+        }
+        
+        queue->threads[now] = last;
+
+        if (min->status == TOBE_REMOVED) {
+            min->status = REMOVED;
+            return dequeue_thread(queue);
+        }
+        
+        return min;
+    } else if (queue->type == APERIODIC_QUEUE)
+    {
+        if (queue->size < 1)
+        {
+            RT_SCHED_ERROR("APERIODIC QUEUE EMPTY! CAN'T DEQUEUE!\n");
+            return NULL;
+        }
+        rt_thread *min, *last;
+        int now, child;
+        
+        min = queue->threads[0];
+        last = queue->threads[--queue->size];
+        
+        for (now = 0; left_child(now) < queue->size; now = child)
+        {
+            child = left_child(now);
+            if (child < queue->size && queue->threads[right_child(now)]->constraints->aperiodic.priority < queue->threads[left_child(now)]->constraints->aperiodic.priority)
+            {
+                child = right_child(now);
+            }
+            
+            if (last->constraints->aperiodic.priority > queue->threads[child]->constraints->aperiodic.priority)
+            {
+                queue->threads[now] = queue->threads[child];
+            } else {
+                break;
+            }
+        }
+        
+        queue->threads[now] = last;
+
+        if (min->status == TOBE_REMOVED) {
+            min->status = REMOVED;
+            return dequeue_thread(queue);
+        }
+        
+        return min;
+    }
+    return NULL;
+}
+
+static void enqueue_thread_logic(rt_queue_sim *queue, rt_thread_sim *thread)
+{
+    if (queue->type == RUNNABLE_QUEUE)
+    {
+        uint64_t pos = queue->size++;
+        queue->threads[pos] = thread;
+        while (queue->threads[parent(pos)]->deadline > thread->deadline && pos != parent(pos))
+        {
+            queue->threads[pos] = queue->threads[parent(pos)];
+            pos = parent(pos);
+        }
+        thread->q_type = RUNNABLE_QUEUE;
+        queue->threads[pos] = thread;
+        
+    } else if (queue->type == PENDING_QUEUE)
+    {
+        uint64_t pos = queue->size++;
+        queue->threads[pos] = thread;
+        while (queue->threads[parent(pos)]->deadline > thread->deadline && pos != parent(pos))
+        {
+            queue->threads[pos] = queue->threads[parent(pos)];
+            pos = parent(pos);
+        }
+        thread->q_type = PENDING_QUEUE;
+        queue->threads[pos] = thread;
+        
+    } else if (queue->type == APERIODIC_QUEUE)
+    {
+        uint64_t pos = queue->size++;
+        queue->threads[pos] = thread;
+        while (queue->threads[parent(pos)]->constraints->aperiodic.priority > thread->constraints->aperiodic.priority && pos != parent(pos))
+        {
+            queue->threads[pos] = queue->threads[parent(pos)];
+            pos = parent(pos);
+        }
+        thread->q_type = APERIODIC_QUEUE;
+        queue->threads[pos] = thread;
+    } 
+}
+
+static rt_thread_sim* dequeue_thread_logic(rt_queue_sim *queue)
+{
+    if (queue->type == RUNNABLE_QUEUE)
+    {
+        if (queue->size < 1)
+        {
+            RT_SCHED_ERROR("RUNNABLE QUEUE EMPTY! CAN'T DEQUEUE!\n");
+            return NULL;
+        }
+        
+        rt_thread_sim *min, *last;
+        int now, child;
+        
+        min = queue->threads[0];
+        last = queue->threads[--queue->size];
+        
+        for (now = 0; left_child(now) < queue->size; now = child)
+        {
+            child = left_child(now);
+            if (child < queue->size && queue->threads[right_child(now)]->deadline < queue->threads[left_child(now)]->deadline)
+            {
+                child = right_child(now);
+            }
+            
+            if (last->deadline > queue->threads[child]->deadline)
+            {
+                queue->threads[now] = queue->threads[child];
+            } else {
+                break;
+            }
+        }
+        
+        queue->threads[now] = last;
+        
+        return min;
+    } else if (queue->type == PENDING_QUEUE)
+    {
+        if (queue->size < 1)
+        {
+            RT_SCHED_ERROR("PENDING QUEUE EMPTY! CAN'T DEQUEUE!\n");
+            return NULL;
+        }
+        rt_thread_sim *min, *last;
+        int now, child;
+        
+        min = queue->threads[0];
+        last = queue->threads[--queue->size];
+        
+        for (now = 0; left_child(now) < queue->size; now = child)
+        {
+            child = left_child(now);
+            if (child < queue->size && queue->threads[right_child(now)]->deadline < queue->threads[left_child(now)]->deadline)
+            {
+                child = right_child(now);
+            }
+            
+            if (last->deadline > queue->threads[child]->deadline)
+            {
+                queue->threads[now] = queue->threads[child];
+            } else {
+                break;
+            }
+        }
+        
+        queue->threads[now] = last;
+        
+        return min;
+    } else if (queue->type == APERIODIC_QUEUE)
+    {
+        if (queue->size < 1)
+        {
+            RT_SCHED_ERROR("APERIODIC QUEUE EMPTY! CAN'T DEQUEUE!\n");
+            return NULL;
+        }
+
+        rt_thread_sim *min, *last;
+        int now, child;
+        
+        min = queue->threads[0];
+        last = queue->threads[--queue->size];
+        
+        for (now = 0; left_child(now) < queue->size; now = child)
+        {
+            child = left_child(now);
+            if (child < queue->size && queue->threads[right_child(now)]->constraints->aperiodic.priority < queue->threads[left_child(now)]->constraints->aperiodic.priority)
+            {
+                child = right_child(now);
+            }
+            
+            if (last->constraints->aperiodic.priority > queue->threads[child]->constraints->aperiodic.priority)
+            {
+                queue->threads[now] = queue->threads[child];
+            } else {
+                break;
+            }
+        }
+        
+        queue->threads[now] = last;
+        
+        return min;
+    } 
+    return NULL;
+}
+
+void rt_thread_dump(rt_thread *thread)
+{
+    
+    if (thread->type == PERIODIC)
+    {
+		printk("START TIME: %llu\t\tRUN TIME: %llu\t\tEXIT TIME: %llu\nDEADLINE: %llu\t\tCURRENT TIME: %llu\n", thread->start_time, thread->run_time, thread->exit_time, thread->deadline, cur_time() );
+    } else if (thread->type == SPORADIC)
+    {
+        RT_SCHED_DEBUG("Work: %llu\t\t", thread->constraints->sporadic.work);
+    }
+}
+
+
+static void set_timer(rt_scheduler *scheduler, rt_thread *current_thread, uint64_t end_time, uint64_t slack)
+{
+    scheduler->tsc->start_time = cur_time();
+    end_time = cur_time();
+    struct sys_info *sys = per_cpu_get(system);
+    struct apic_dev *apic = sys->cpus[my_cpu_id()]->apic;
+    if (scheduler->pending->size > 0 && current_thread) {
+        rt_thread *thread = scheduler->pending->threads[0];
+        uint64_t completion_time = 0;
+        if (current_thread->type == PERIODIC)
+        {
+            apic_oneshot_write(apic, umin(thread->deadline - end_time, (current_thread->constraints->periodic.slice - current_thread->run_time) + slack));
+            scheduler->tsc->set_time = umin(thread->deadline - end_time, (current_thread->constraints->periodic.slice - current_thread->run_time));
+        } else if (current_thread->type == SPORADIC)
+        {
+            apic_oneshot_write(apic, umin(thread->deadline - end_time, (current_thread->constraints->sporadic.work - current_thread->run_time) + slack));
+            scheduler->tsc->set_time = umin(thread->deadline - end_time, (current_thread->constraints->sporadic.work - current_thread->run_time) + slack);
+        } else
+        {
+            apic_oneshot_write(apic, umin(thread->deadline - end_time, QUANTUM));
+            scheduler->tsc->set_time = umin(thread->deadline - end_time, QUANTUM);
+        }
+    } else if (scheduler->pending->size == 0 && current_thread) {
+        if (current_thread->type == PERIODIC)
+        {
+            apic_oneshot_write(apic, (current_thread->constraints->periodic.slice - current_thread->run_time) + slack);
+            scheduler->tsc->set_time = (current_thread->constraints->periodic.slice - current_thread->run_time) + slack;
+        } else if (current_thread->type == SPORADIC)
+        {
+            apic_oneshot_write(apic, (current_thread->constraints->sporadic.work - current_thread->run_time) + slack);
+            scheduler->tsc->set_time = (current_thread->constraints->sporadic.work - current_thread->run_time) + slack;
+        }
+        else {
+            apic_oneshot_write(apic, QUANTUM);
+            scheduler->tsc->set_time = QUANTUM;
+        }
+    } else {
+        apic_oneshot_write(apic, QUANTUM);
+        scheduler->tsc->set_time = QUANTUM;
+    }
+	scheduler->tsc->end_time = end_time;
+}
+
+
+struct nk_thread *rt_need_resched()
+{
+    struct sys_info *sys = per_cpu_get(system);
+    rt_scheduler *scheduler = sys->cpus[my_cpu_id()]->rt_sched;
+    
+    struct nk_thread *c = get_cur_thread();
+    rt_thread *rt_c = c->rt_thread;
+    
+    
+    uint64_t end_time = scheduler->run_time + cur_time();
+    uint64_t slack = 0;
+    scheduler->tsc->end_time = cur_time();
+    
+    rt_thread *rt_n;
+    
+    while (scheduler->pending->size > 0)
+    {
+        if (scheduler->pending->threads[0]->deadline < end_time)
+        {
+            rt_thread *arrived_thread = dequeue_thread(scheduler->pending);
+            if (arrived_thread == NULL) {
+                continue;
+            }
+            update_periodic(arrived_thread);
+            enqueue_thread(scheduler->runnable, arrived_thread);
+            continue;
+        } else
+        {
+            break;
+        }
+    }
+    
+    switch (rt_c->type) {
+        case APERIODIC:
+            rt_c->constraints->aperiodic.priority = rt_c->run_time;
+            enqueue_thread(scheduler->aperiodic, rt_c);
+
+            if (scheduler->runnable->size > 0)
+            {
+                rt_n = dequeue_thread(scheduler->runnable);
+                if (rt_n != NULL) {
+                    set_timer(scheduler, rt_n, end_time, slack);
+                    return rt_n->thread;
+                }
+            }
+
+            rt_n = dequeue_thread(scheduler->aperiodic);
+            if (rt_n == NULL) {
+                    RT_SCHED_ERROR("APERIODIC QUEUE IS EMPTY.\n THE WORLD IS GOVERNED BY MADNESS.\n");
+                    panic("ATTEMPTING TO RUN A NULL RT_THREAD.\n");
+            }
+            set_timer(scheduler, rt_n, end_time, slack);
+            return rt_n->thread;
+            break;
+            
+        case SPORADIC:
+            if (rt_c->run_time >= rt_c->constraints->sporadic.work) {
+                check_deadlines(rt_c);
+
+                if (scheduler->runnable->size > 0) {
+                    rt_n = dequeue_thread(scheduler->runnable);
+                    if (rt_n != NULL) {
+                        set_timer(scheduler, rt_n, end_time, slack);
+                        return rt_n->thread;
+                    }
+                }
+                rt_n = dequeue_thread(scheduler->aperiodic);
+                if (rt_n == NULL) {
+                    RT_SCHED_ERROR("APERIODIC QUEUE IS EMPTY.\n THE WORLD IS GOVERNED BY MADNESS.\n");
+                    panic("ATTEMPTING TO RUN A NULL RT_THREAD.\n");
+                }
+                set_timer(scheduler, rt_n, end_time, slack);
+                return rt_n->thread;
+            } else {
+                if (scheduler->runnable->size > 0)
+                {
+                    if (rt_c->deadline > scheduler->runnable->threads[0]->deadline) {
+                        rt_n = dequeue_thread(scheduler->runnable);
+                        if (rt_n != NULL) {
+                            enqueue_thread(scheduler->runnable, rt_c);
+                            set_timer(scheduler, rt_n, end_time, slack);
+                            return rt_n->thread;
+                        }
+                    }
+                }
+            }
+            set_timer(scheduler, rt_c, end_time, slack);
+            return rt_c->thread;
+            break;
+            
+        case PERIODIC:
+            if (rt_c->run_time >= rt_c->constraints->periodic.slice) {
+                if (check_deadlines(rt_c)) {
+                    update_periodic(rt_c);
+                    enqueue_thread(scheduler->runnable, rt_c);
+                } else {
+                    enqueue_thread(scheduler->pending, rt_c);
+                }
+
+                if (scheduler->runnable->size > 0) {
+                    rt_n = dequeue_thread(scheduler->runnable);
+                    if (rt_n != NULL) {
+                        set_timer(scheduler, rt_n, end_time, slack);
+                        return rt_n->thread;
+                    }
+                }
+                rt_n = dequeue_thread(scheduler->aperiodic);
+                if (rt_n == NULL) {
+                    RT_SCHED_ERROR("APERIODIC QUEUE IS EMPTY.\n THE WORLD IS GOVERNED BY MADNESS.\n");
+                    panic("ATTEMPTING TO RUN A NULL RT_THREAD.\n");
+                }
+                set_timer(scheduler, rt_n, end_time, slack);
+                return rt_n->thread;
+            } else {
+                if (scheduler->runnable->size > 0)
+                {
+                    if (rt_c->deadline > scheduler->runnable->threads[0]->deadline) {
+                        rt_n = dequeue_thread(scheduler->runnable);
+                        if (rt_n != NULL) {
+                            enqueue_thread(scheduler->runnable, rt_c);
+                            set_timer(scheduler, rt_n, end_time, slack);
+                            return rt_n->thread;
+                        }
+                    }
+                }
+            }
+            set_timer(scheduler, rt_c, end_time, slack);
+            return rt_c->thread;
+            break;
+        default:
+            set_timer(scheduler, rt_c, end_time, slack);
+            return c;
+    }    
+}
+
+
+
+static int check_deadlines(rt_thread *t)
+{
+	
+    if (t->exit_time > t->deadline) {
+        RT_SCHED_ERROR("Missed Deadline = %llu\t\t Current Timer = %llu\n", t->deadline, t->exit_time);
+        RT_SCHED_ERROR("Difference =  %llu\n", t->exit_time - t->deadline);
+        rt_thread_dump(t);
+		return 1;
+    }
+    return 0;
+}
+
+static inline void update_periodic(rt_thread *t)
+{
+    if (t->type == PERIODIC)
+    {
+        t->deadline  = cur_time() + t->constraints->periodic.period;
+        t->run_time = 0;
+    }
+}
+
+uint64_t cur_time()
+{
+    return rdtsc();
+}
+
+
+int rt_admit(rt_scheduler *scheduler, rt_thread *thread)
+{
+    if (thread->type == PERIODIC)
+    {
+        uint64_t per_util = get_per_util(scheduler->runnable, scheduler->pending);
+
+        printk("UTIL FACTOR =  \t%llu\n", per_util);
+        printk("NEW UTIL FACTOR =  \t%llu\n", per_util + ((thread->constraints->periodic.slice * 100000) / thread->constraints->periodic.period));
+        
+        
+        if ((per_util + (thread->constraints->periodic.slice * 100000) / thread->constraints->periodic.period) > PERIODIC_UTIL) {
+            RT_SCHED_ERROR("PERIODIC: Admission denied utilization factor overflow!\n");
+            return 0;
+        }
+    } else if (thread->type == SPORADIC)
+    {
+        uint64_t spor_util = get_spor_util(scheduler->runnable);
+        
+        if (spor_util > SPORADIC_UTIL) {
+            RT_SCHED_DEBUG("SPORADIC: Admission denied utilization factor overflow!\n");
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+static inline uint64_t get_avg_per(rt_queue *runnable, rt_queue *pending, rt_thread *new_thread)
+{
+    uint64_t sum_period = 0;
+    uint64_t num_periodic = 0;
+    int i;
+    
+    for (i = 0; i < runnable->size; i++)
+    {
+        rt_thread *thread = runnable->threads[i];
+        if (thread->type == PERIODIC) {
+            sum_period += thread->constraints->periodic.period;
+            num_periodic++;
+        }
+    }
+    
+    for (i = 0; i < pending->size; i++)
+    {
+        rt_thread *thread = pending->threads[i];
+        if (thread->type == PERIODIC) {
+            sum_period += thread->constraints->periodic.period;
+            num_periodic++;
+        }
+    }
+    
+    if (new_thread->type == PERIODIC)
+    {
+        sum_period += new_thread->constraints->periodic.period;
+        num_periodic++;
+    }
+    
+    sum_period += QUANTUM;
+    num_periodic++;
+    return (sum_period / num_periodic);
+}
+
+static inline uint64_t get_min_per(rt_queue *runnable, rt_queue *pending, rt_thread *thread)
+{
+    uint64_t min_period = 0xFFFFFFFFFFFFFFFF;
+    int i;
+    for (i = 0; i < runnable->size; i++)
+    {
+        rt_thread *thread = runnable->threads[i];
+        if (thread->type == PERIODIC)
+        {
+            min_period = MIN(thread->constraints->periodic.period, min_period);
+        }
+    }
+    
+    for (i = 0; i < pending->size; i++)
+    {
+        rt_thread *thread = pending->threads[i];
+        if (thread->type == PERIODIC)
+        {
+            min_period = MIN(thread->constraints->periodic.period, min_period);
+        }
+    }
+    return min_period;
+}
+
+static inline uint64_t get_per_util(rt_queue *runnable, rt_queue *pending)
+{
+    uint64_t util = 0;
+    
+    int i;
+    for (i = 0; i < runnable->size; i++)
+    {
+        rt_thread *thread = runnable->threads[i];
+        if (thread->type == PERIODIC) {
+            util += (thread->constraints->periodic.slice * 100000) / thread->constraints->periodic.period;
+        }
+    }
+    
+    for (i = 0; i < pending->size; i++)
+    {
+        rt_thread *thread = pending->threads[i];
+        if (thread->type == PERIODIC) {
+            util += (thread->constraints->periodic.slice * 100000) / thread->constraints->periodic.period;
+        }
+    }
+    
+    return util;
+}
+
+static inline uint64_t get_spor_util(rt_queue *runnable)
+{
+    uint64_t util = 0;
+    
+    int i;
+    for (i = 0; i < runnable->size; i++)
+    {
+        rt_thread *thread = runnable->threads[i];
+        if (thread->type == SPORADIC)
+        {
+            util += (thread->constraints->sporadic.work * 100000) / (thread->deadline - cur_time());
+        }
+    }
+    return util;
+}
+
+static void test_real_time(void *in)
+{
+    while (1)
+    {
+      printk("Inside thread %d\n", (int)(uint64_t)in);
+        udelay(10000);
+    }
+}
+
+void rt_start(uint64_t sched_slice_time, uint64_t sched_period) {
+
+    nk_thread_id_t sched;
+
+    rt_constraints *c = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints p = {sched_period, sched_slice_time};
+    c->periodic = p;
+
+    nk_thread_start_sim((nk_thread_fun_t)sched_sim, NULL, NULL, 0, 0, &sched, my_cpu_id(), PERIODIC, c, 0);
+
+    nk_thread_id_t r;
+    nk_thread_id_t s;
+    nk_thread_id_t t;
+    nk_thread_id_t u;
+    nk_thread_id_t v;
+    nk_thread_id_t w;
+    nk_thread_id_t x;
+    nk_thread_id_t y;
+    
+    rt_constraints *constraints_first = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_first = {(100000000), (10000000)};
+    constraints_first->periodic = per_constr_first;
+    
+    rt_constraints *constraints_second = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_second = {(50000000), (5000000)};
+    constraints_second->periodic = per_constr_second;
+    
+    rt_constraints *constraints_third = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_third = {(2500000), (250000)};
+    constraints_third->periodic = per_constr_third;
+    
+    rt_constraints *constraints_fifth = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_fifth = {(50000000), (5000000)};
+    constraints_fifth->periodic = per_constr_fifth;
+    
+    rt_constraints *constraints_six = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_six = {(50000000), (5000000)};
+    constraints_six->periodic = per_constr_six;
+    
+    rt_constraints *constraints_seven = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_seven = {(500000000), (5000000)};
+    constraints_seven->periodic = per_constr_seven;
+    
+    rt_constraints *constraints_fourth = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct aperiodic_constraints aper_constr = {2};
+    constraints_fourth->aperiodic = aper_constr;
+    
+    rt_constraints *constraints_eighth = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_eighth = {(500000000000), (500000000)};
+    constraints_eighth->periodic = per_constr_eighth;
+
+    uint64_t first = 1, second = 2, third = 3, fourth = 4, five = 5, six = 6, seven = 7, eight = 8;
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)first, NULL, 0, 0, &r, my_cpu_id(), PERIODIC, constraints_first, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)second, NULL, 0, 0, &s, my_cpu_id(), PERIODIC, constraints_second, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)third, NULL, 0, 0, &t, my_cpu_id(), PERIODIC, constraints_third, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)five, NULL, 0, 0, &v, my_cpu_id(), PERIODIC, constraints_fifth, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)six, NULL, 0, 0, &w, my_cpu_id(), PERIODIC, constraints_six, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)seven, NULL, 0, 0, &x, my_cpu_id(), PERIODIC, constraints_seven, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)fourth, NULL, 0, 0, &u, my_cpu_id(), APERIODIC, constraints_fourth, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)eight, NULL, 0, 0, &y, my_cpu_id(), PERIODIC, constraints_eighth, 0);  
+  
+    printk("Joined test thread.\n");
+
+}
+
+static int test_sum(void) {
+    const int size = 100;
+    int sum = 0, i = 0;
+    nk_thread_t *me = get_cur_thread();
+    for (i = 0; i < size; i++) {
+        sum += i;
+        udelay(10000);
+        printk("INSIDE FUNCTION %x.\n", me->tid);
+    }
+
+    return sum;
+}
+
+
+static void sched_sim(void *scheduler) {
+
+	rt_simulator *sim = init_simulator();
+
+    struct sys_info *sys = per_cpu_get(system);
+    rt_scheduler *sched = sys->cpus[my_cpu_id()]->rt_sched;
+
+    while (1) {
+        rt_thread *new = list_dequeue(sched->arrival);
+        if (new != NULL) {
+            if (new->type == APERIODIC) {
+                enqueue_thread(sched->aperiodic, new);
+            } else {
+                uint64_t context_time = 1000;
+                uint64_t sched_time = sched->run_time;
+                printk("Sched time is %llu\n", sched_time);
+                uint64_t current_time = 0;
+
+                int finished_max = 0;
+                int failed = 0;
+
+                int admission_check = rt_admit(sched, new);
+                if (admission_check) {
+                    nk_thread_t *me = get_cur_thread();
+                    rt_thread *this = me->rt_thread;
+                    copy_threads_sim(sim, sched, new, this);
+
+                    rt_thread_sim *next = min_periodic(sim);
+                    rt_thread_sim *max = max_periodic(sim);
+                    update_enter_logic(next, current_time);
+                    current_time += set_timer_logic(sim, next, current_time);
+                    
+
+                    while (finished_max <= 1) {
+                        update_exit_logic(next, current_time);
+                        next = rt_need_resched_logic(sim, next, current_time, &failed, &finished_max, max);
+                        if (failed) break;
+                        current_time += (context_time + sched_time);
+                        update_enter_logic(next, current_time);
+                        current_time += set_timer_logic(sim, next, current_time);
+                    }
+
+                    if (failed) {
+                         RT_SCHED_ERROR("THREAD DENIED ENTRY.\n");
+                         new->status = DENIED;
+                    } else {
+                        printk("THREAD ADMITTED\n");
+                        new->status = ADMITTED;
+			new->deadline = cur_time() + new->constraints->periodic.period;
+                        enqueue_thread(sched->runnable, new);
+                    }
+
+                    free_threads_sim(sim);
+                }
+            }
+        }
+
+
+        rt_thread *d = list_dequeue(sched->exited);
+        while (d != NULL) {
+            rt_thread *e = NULL;
+
+            if (d->status == TOBE_REMOVED) {
+                e = remove_thread(d); 
+            } 
+
+            if (d->status == SLEEPING) {
+                e = list_remove(sched->sleeping, d);
+            }
+
+            if (d->status != REMOVED && e == NULL) {
+                RT_SCHED_ERROR("REMOVING THREAD INCORRECTLY.\n");
+            } else {
+                d->status = REMOVED;
+            }
+        }   
+    }
+}
+
+static rt_thread_sim* max_periodic(rt_simulator *simulator) {
+    rt_queue_sim *runnable = simulator->runnable;
+    rt_queue_sim *pending = simulator->pending;
+    rt_thread_sim *max_thread = NULL;  
+    uint64_t max_period = 0;
+    int i = 0;
+    for (i = 0; i < runnable->size; i++) {
+        rt_thread_sim *thread = runnable->threads[i];
+        if (thread->type == PERIODIC) {
+            if (thread->constraints->periodic.period > max_period) {
+                max_period = thread->constraints->periodic.period;
+                max_thread = thread;
+            }
+        }
+    }
+    
+    for (i = 0; i < pending->size; i++) {
+        rt_thread_sim *thread = pending->threads[i];
+        if (thread->type == PERIODIC) {
+            if (thread->constraints->periodic.period > max_period) {
+                max_period = thread->constraints->periodic.period;
+                max_thread = thread;
+            }
+        }
+    }
+    return max_thread;
+}
+
+static rt_thread_sim* min_periodic(rt_simulator *simulator) {
+    rt_queue_sim *runnable = simulator->runnable;
+    rt_queue_sim *pending = simulator->pending;
+    rt_thread_sim *min_thread = NULL;  
+    uint64_t min_period = 0xFFFFFFFFFFFFFFFF;
+    int i = 0;
+    for (i = 0; i < runnable->size; i++) {
+        rt_thread_sim *thread = runnable->threads[i];
+        if (thread->type == PERIODIC) {
+            if (thread->constraints->periodic.period < min_period) {
+                min_period = thread->constraints->periodic.period;
+                min_thread = thread;
+            }
+        }
+    }
+    
+    for (i = 0; i < pending->size; i++) {
+        rt_thread_sim *thread = pending->threads[i];
+        if (thread->type == PERIODIC) {
+            if (thread->constraints->periodic.period < min_period) {
+                min_period = thread->constraints->periodic.period;
+                min_thread = thread;
+            }
+        }
+    }
+    return min_thread;
+}
+
+static void copy_threads_sim(rt_simulator *simulator, rt_scheduler *scheduler, rt_thread *new, rt_thread *this) {
+    int i;
+
+    for (i = 0; i < scheduler->runnable->size; i++) {
+        rt_thread *s = scheduler->runnable->threads[i];
+        rt_thread_sim *d = (rt_thread_sim *)MALLOC(sizeof(rt_thread_sim));
+        d->type = s->type;
+        d->q_type = s->q_type;
+        d->status = ADMITTED;
+
+        rt_constraints *constraints = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+        if (d->type == PERIODIC) {
+            struct periodic_constraints constr = {(s->constraints->periodic.period), (s->constraints->periodic.slice)};
+            constraints->periodic = constr;
+        } else if (d->type == SPORADIC) {
+            struct sporadic_constraints constr = {(s->constraints->sporadic.work)};
+            constraints->sporadic = constr;
+        }
+        d->constraints = constraints;
+        d->start_time = 0;
+        d->run_time = 0;
+        d->deadline = constraints->periodic.period;
+        d->exit_time = 0;
+        enqueue_thread_logic(simulator->runnable, d);
+    }
+
+    printk("SCHEDULER APERIODIC SIZE IS %d\n", scheduler->aperiodic->size);
+    for (i = 0; i < scheduler->aperiodic->size; i++) {
+        rt_thread *s = scheduler->aperiodic->threads[i];
+        rt_thread_sim *d = (rt_thread_sim *)MALLOC(sizeof(rt_thread_sim));
+        d->type = s->type;
+        d->q_type = s->q_type;
+        d->status = ADMITTED;
+
+        rt_constraints *constraints = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+        struct aperiodic_constraints constr = {(s->constraints->aperiodic.priority)};
+        constraints->aperiodic = constr;
+
+        d->constraints = constraints;
+        d->start_time = 0;
+        d->run_time = 0;
+        d->deadline = 0;
+        d->exit_time = 0;
+        enqueue_thread_logic(simulator->aperiodic, d);
+    }
+
+
+    for (i = 0; i < scheduler->pending->size; i++) {
+        rt_thread *s = scheduler->pending->threads[i];
+        rt_thread_sim *d = (rt_thread_sim *)MALLOC(sizeof(rt_thread_sim));
+        d->type = s->type;
+        d->q_type = RUNNABLE_QUEUE;
+        d->status = ADMITTED;
+
+        rt_constraints *constraints = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+        if (d->type == PERIODIC) {
+            struct periodic_constraints constr = {(s->constraints->periodic.period), (s->constraints->periodic.slice)};
+            constraints->periodic = constr;
+        } else if (d->type == SPORADIC) {
+            struct sporadic_constraints constr = {(s->constraints->sporadic.work)};
+            constraints->sporadic = constr;
+        }
+
+        d->constraints = constraints;
+        d->start_time = 0;
+        d->run_time = 0;
+        if (d->type == PERIODIC) {
+           d->deadline = constraints->periodic.period; 
+       } else {
+            d->deadline = constraints->sporadic.work;
+       }
+        
+        d->exit_time = 0;
+
+        enqueue_thread_logic(simulator->runnable, d);
+    }
+
+    rt_thread_sim *new_sim = (rt_thread_sim *)MALLOC(sizeof(rt_thread_sim));
+    new_sim->type = new->type;
+    new_sim->q_type = RUNNABLE_QUEUE;
+    new_sim->status = ADMITTED;
+
+    rt_constraints *constraints = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    if (new->type == PERIODIC) {
+        struct periodic_constraints constr = {(new->constraints->periodic.period), (new->constraints->periodic.slice)};
+        constraints->periodic = constr;
+    } else if (new->type == SPORADIC) {
+        struct sporadic_constraints constr = {(new->constraints->sporadic.work)};
+        constraints->sporadic = constr;
+    }
+    new_sim->constraints = constraints;
+    new_sim->start_time = 0;
+    new_sim->run_time = 0;
+    new_sim->exit_time = 0;
+
+    if (new_sim->type == PERIODIC) {
+        new_sim->deadline = constraints->periodic.period; 
+    } else {
+        new_sim->deadline = constraints->sporadic.work;
+    }
+
+    enqueue_thread_logic(simulator->runnable, new_sim);
+
+    rt_thread_sim *sched_per = (rt_thread_sim *)MALLOC(sizeof(rt_thread_sim));
+    sched_per->type = this->type;
+    sched_per->q_type = RUNNABLE_QUEUE;
+    sched_per->status = ADMITTED;
+
+    rt_constraints *sched_con = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    if (this->type == PERIODIC) {
+        struct periodic_constraints constr = {(this->constraints->periodic.period), (this->constraints->periodic.slice)};
+        sched_con->periodic = constr;
+    } else if (this->type == SPORADIC) {
+        struct sporadic_constraints constr = {(this->constraints->sporadic.work)};
+        sched_con->sporadic = constr;
+    }
+    sched_per->constraints = sched_con;
+    sched_per->start_time = 0;
+    sched_per->run_time = 0;
+    sched_per->exit_time = 0;
+
+    if (sched_per->type == PERIODIC) {
+        sched_per->deadline = constraints->periodic.period; 
+    } else {
+        sched_per->deadline = constraints->sporadic.work;
+    }
+
+    enqueue_thread_logic(simulator->runnable, sched_per);
+}
+
+static void free_threads_sim(rt_simulator *simulator) {
+    int i = 0;
+    for (i = 0; i < simulator->runnable->size; i++) {
+        FREE(simulator->runnable->threads[i]->constraints);
+        FREE(simulator->runnable->threads[i]);
+    }
+    simulator->runnable->size = 0;
+
+    for (i = 0; i < simulator->aperiodic->size; i++) {
+        FREE(simulator->aperiodic->threads[i]->constraints);
+        FREE(simulator->aperiodic->threads[i]);
+    }
+    simulator->aperiodic->size = 0;
+
+    for (i = 0; i < simulator->pending->size; i++) {
+        FREE(simulator->pending->threads[i]->constraints);
+        FREE(simulator->pending->threads[i]);
+    }
+    simulator->pending->size = 0;
+}
+
+static rt_thread_sim* rt_need_resched_logic(rt_simulator *simulator, rt_thread_sim *thread, uint64_t time, int *failed, int *finished_max, rt_thread_sim *max)
+{
+    rt_thread_sim *next = NULL;
+
+    while (simulator->pending->size > 0)
+    {
+        if (simulator->pending->threads[0]->deadline < time)
+        {
+            rt_thread_sim *arrived_thread = dequeue_thread_logic(simulator->pending);
+            update_periodic_logic(arrived_thread, time);
+            enqueue_thread_logic(simulator->runnable, arrived_thread);
+            continue;
+        } else
+        {
+            break;
+        }
+    }
+    
+    switch (thread->type) {
+        case APERIODIC:
+            thread->constraints->aperiodic.priority = thread->run_time;
+            
+            if (simulator->runnable->size > 0)
+            {
+                enqueue_thread_logic(simulator->aperiodic, thread);
+                next = dequeue_thread_logic(simulator->runnable);
+                return next;
+            }
+
+            enqueue_thread_logic(simulator->aperiodic, thread);
+            next = dequeue_thread_logic(simulator->aperiodic);
+            return next;
+
+            break;
+            
+        case SPORADIC:
+            if (thread->run_time >= thread->constraints->sporadic.work) {
+                if (simulator->runnable->size > 0) {
+                    next = dequeue_thread_logic(simulator->runnable);
+                    return next;
+                }
+                next = dequeue_thread_logic(simulator->aperiodic);
+                return next;
+            } else {
+                if (simulator->runnable->size > 0)
+                {
+                    if (thread->deadline > simulator->runnable->threads[0]->deadline) {
+                        next = dequeue_thread_logic(simulator->runnable);
+                        enqueue_thread_logic(simulator->runnable, thread);
+                        return next;
+                    }
+                }
+            }
+
+            return thread;
+            break;
+            
+        case PERIODIC:
+            if (thread->run_time >= thread->constraints->periodic.slice) {
+                if (thread == max) {
+                    printk("INC MAX\n");
+                    (*finished_max)++;
+                }
+                if (check_deadlines_logic(thread, time)) {
+                    *failed = 1;
+                    update_periodic_logic(thread, time);
+                    enqueue_thread_logic(simulator->runnable, thread);
+                } else {
+                    enqueue_thread_logic(simulator->pending, thread);
+                }
+                if (simulator->runnable->size > 0) {
+                    next = dequeue_thread_logic(simulator->runnable);
+                    return next;
+                }
+                next = dequeue_thread_logic(simulator->aperiodic);
+                if (next == NULL) {
+                    return thread;
+                }
+                return next;
+            } else {
+                if (simulator->runnable->size > 0)
+                {
+                    if (thread->deadline > simulator->runnable->threads[0]->deadline) {
+                        next = dequeue_thread_logic(simulator->runnable);
+                        enqueue_thread_logic(simulator->runnable, thread);
+                        return next;
+                    }
+                }
+            }
+            return thread;
+        default:
+            return thread;
+    }    
+}
+
+static inline void update_exit_logic(rt_thread_sim *t, uint64_t time)
+{
+    t->exit_time = time;
+    t->run_time += (t->exit_time - t->start_time);
+}
+
+static inline void update_enter_logic(rt_thread_sim *t, uint64_t time)
+{
+    t->start_time = time;
+}
+
+static int check_deadlines_logic(rt_thread_sim *t, uint64_t time)
+{
+    if (time > t->deadline) {
+        printk("INSIDE CHECK DEADLINES LOGIC. TIME IS %llu AND DEADLINE IS %llu\n", time, t->deadline);
+        return 1;
+    }
+    return 0;
+}
+
+static inline void update_periodic_logic(rt_thread_sim *t, uint64_t time)
+{
+    if (t->type == PERIODIC)
+    {
+        t->deadline  = time + t->constraints->periodic.period;
+        t->run_time = 0;
+    }
+}
+
+static uint64_t set_timer_logic(rt_simulator *simulator, rt_thread_sim *thread, uint64_t time)
+{
+    if (simulator->pending->size > 0 && thread) {
+        rt_thread_sim *next = simulator->pending->threads[0];
+        if (thread->type == PERIODIC)
+        {
+            return umin(next->deadline - time, (thread->constraints->periodic.slice - thread->run_time));
+        } else
+        {
+            return umin(next->deadline - time, QUANTUM);
+        }
+    } else if (simulator->pending->size == 0 && thread) {
+        if (thread->type == PERIODIC)
+        {
+            return (thread->constraints->periodic.slice - thread->run_time);
+        } else {
+            return QUANTUM;
+        }
+    } else {
+        return QUANTUM;
+    }
+}
+
+
+
+void nk_rt_test()
+{
+    nk_thread_id_t r;
+    nk_thread_id_t s;
+    nk_thread_id_t t;
+    nk_thread_id_t u;
+    nk_thread_id_t v;
+    nk_thread_id_t w;
+    nk_thread_id_t x;
+    nk_thread_id_t y;
+    
+    
+    
+    rt_constraints *constraints_first = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_first = {(10000000000), (10000000)};
+    constraints_first->periodic = per_constr_first;
+    
+    rt_constraints *constraints_second = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_second = {(5000000000), (5000000)};
+    constraints_second->periodic = per_constr_second;
+    
+    rt_constraints *constraints_third = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_third = {(250000000), (250000)};
+    constraints_third->periodic = per_constr_third;
+    
+    rt_constraints *constraints_fifth = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_fifth = {(500000000), (5000000)};
+    constraints_fifth->periodic = per_constr_fifth;
+    
+    rt_constraints *constraints_six = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_six = {(5000000000), (5000000)};
+    constraints_six->periodic = per_constr_six;
+    
+    rt_constraints *constraints_seven = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_seven = {(5000000000), (5000000)};
+    constraints_seven->periodic = per_constr_seven;
+    
+    rt_constraints *constraints_fourth = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct aperiodic_constraints aper_constr = {2};
+    constraints_fourth->aperiodic = aper_constr;
+    
+    rt_constraints *constraints_eighth = (rt_constraints *)MALLOC(sizeof(rt_constraints));
+    struct periodic_constraints per_constr_eighth = {(500000000000), (500000000)};
+    constraints_eighth->periodic = per_constr_eighth;
+
+    uint64_t first = 1, second = 2, third = 3, fourth = 4, five = 5, six = 6, seven = 7, eight = 8;
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)first, NULL, 0, 0, &r, my_cpu_id(), PERIODIC, constraints_first, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)second, NULL, 0, 0, &s, my_cpu_id(), PERIODIC, constraints_second, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)third, NULL, 0, 0, &t, my_cpu_id(), PERIODIC, constraints_third, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)five, NULL, 0, 0, &v, my_cpu_id(), PERIODIC, constraints_fifth, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)six, NULL, 0, 0, &w, my_cpu_id(), PERIODIC, constraints_six, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)seven, NULL, 0, 0, &x, my_cpu_id(), PERIODIC, constraints_seven, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)fourth, NULL, 0, 0, &u, my_cpu_id(), APERIODIC, constraints_fourth, 0);
+    nk_thread_start((nk_thread_fun_t)test_real_time, (void *)eight, NULL, 0, 0, &y, my_cpu_id(), PERIODIC, constraints_eighth, 0);	
+}
+
+static inline uint64_t umin(uint64_t x, uint64_t y)
+{
+    return (x < y) ? x : y;
+}
+
+void rt_thread_exit(rt_thread *thread) {
+
+    while (thread->status == ARRIVED);
+
+    if (thread->status == DENIED) {
+        return;
+    }
+
+    if (thread->status != SLEEPING) {
+        thread->status = TOBE_REMOVED;
+    }
+    struct sys_info *sys = per_cpu_get(system);
+    rt_scheduler *sched = sys->cpus[my_cpu_id()]->rt_sched;
+    list_enqueue(sched->exited, thread);
+}
diff --git a/./src/nautilus/rwlock.c b/../../nrt/nautilus/src/nautilus/rwlock.c
old mode 100644
new mode 100755
index 5287ef4..f73e148
--- a/./src/nautilus/rwlock.c
+++ b/../../nrt/nautilus/src/nautilus/rwlock.c
@@ -177,21 +177,21 @@ writer (void * in, void ** out)
 }
 
 
-void
-nk_rwlock_test (void) 
-{
-    nk_rwlock_t * rl = NULL;
-    rl = malloc(sizeof(nk_rwlock_t));
-    if (!rl) {
-        ERROR_PRINT("Could not allocate rwlock\n");
-        return;
-    }
-
-    nk_rwlock_init(rl);
-
-    nk_thread_start(reader1, rl, NULL, 1, TSTACK_DEFAULT, NULL, 1);
-    nk_thread_start(reader2, rl, NULL, 1, TSTACK_DEFAULT, NULL, 2);
-    nk_thread_start(writer, rl, NULL, 1, TSTACK_DEFAULT, NULL, 3);
-
-}
+//void
+//nk_rwlock_test (void) 
+//{
+//    nk_rwlock_t * rl = NULL;
+//    rl = malloc(sizeof(nk_rwlock_t));
+//    if (!rl) {
+//        ERROR_PRINT("Could not allocate rwlock\n");
+//        return;
+//    }
+//
+//    nk_rwlock_init(rl);
+//
+//    nk_thread_start(reader1, rl, NULL, 1, TSTACK_DEFAULT, NULL, 1);
+//    nk_thread_start(reader2, rl, NULL, 1, TSTACK_DEFAULT, NULL, 2);
+//    nk_thread_start(writer, rl, NULL, 1, TSTACK_DEFAULT, NULL, 3);
+//
+//}
 
diff --git a/./src/nautilus/sfi.c b/../../nrt/nautilus/src/nautilus/sfi.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/smp.c b/../../nrt/nautilus/src/nautilus/smp.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/spinlock.c b/../../nrt/nautilus/src/nautilus/spinlock.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/thread.c b/../../nrt/nautilus/src/nautilus/thread.c
old mode 100644
new mode 100755
index 1a4e802..8d4a8d9
--- a/./src/nautilus/thread.c
+++ b/../../nrt/nautilus/src/nautilus/thread.c
@@ -1,17 +1,17 @@
-/* 
+/*
  * This file is part of the Nautilus AeroKernel developed
- * by the Hobbes and V3VEE Projects with funding from the 
- * United States National  Science Foundation and the Department of Energy.  
+ * by the Hobbes and V3VEE Projects with funding from the
+ * United States National  Science Foundation and the Department of Energy.
  *
  * The V3VEE Project is a joint project between Northwestern University
  * and the University of New Mexico.  The Hobbes Project is a collaboration
- * led by Sandia National Laboratories that includes several national 
+ * led by Sandia National Laboratories that includes several national
  * laboratories and universities. You can find out more at:
  * http://www.v3vee.org  and
  * http://xtack.sandia.gov/hobbes
  *
  * Copyright (c) 2015, Kyle C. Hale <kh@u.northwestern.edu>
- * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org> 
+ * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org>
  *                     The Hobbes Project <http://xstack.sandia.gov/hobbes>
  * All rights reserved.
  *
@@ -34,6 +34,10 @@
 #include <nautilus/errno.h>
 #include <nautilus/mm.h>
 
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+#include <nautilus/rt_scheduler.h>
+#endif
+
 
 extern uint8_t malloc_cpus_ready;
 
@@ -41,10 +45,24 @@ extern uint8_t malloc_cpus_ready;
 #undef  DEBUG_PRINT
 #define DEBUG_PRINT(fmt, args...)
 #endif
-#define SCHED_PRINT(fmt, args...) INFO_PRINT("SCHED: " fmt, ##args)
+
+
+#define SCHED_PRINT(fmt, args...) printk("SCHED: " fmt, ##args)
 #define SCHED_DEBUG(fmt, args...) DEBUG_PRINT("SCHED: " fmt, ##args)
 #define SCHED_WARN(fmt, args...)  WARN_PRINT("SCHED: " fmt, ##args)
 
+#define RT_SCHED_DEBUG(fmt, args...)
+#ifdef NAUT_CONFIG_DEBUG_RT_SCHEDULER
+#undef RT_SCHED_DEBUG
+#define RT_SCHED_DEBUG(fmt, args...) printk("SCHED: " fmt, ##args)
+#endif
+
+#define RT_THREAD_DEBUG(fmt, args...)
+#ifdef NAUT_CONFIG_DEBUG_RT_THREADS
+#undef RT_THREAD_DEBUG
+#define RT_THREAD_DEBUG(fmt, args...) printk("THREAD: " fmt, ##args)
+#endif
+
 static unsigned long next_tid = 0;
 
 static struct nk_sched_state * glob_sched_state;
@@ -54,17 +72,28 @@ extern void nk_thread_switch(nk_thread_t*);
 extern void nk_thread_entry(void *);
 static struct nk_tls tls_keys[TLS_MAX_KEYS];
 
+static inline void update_exit(rt_thread *t);
+static inline void update_enter(rt_thread *t);
+
+static inline void update_exit(rt_thread *t) {
+	t->exit_time = rdtsc();
+	t->run_time += (t->exit_time - t->start_time);
+}
+
+static inline void update_enter(rt_thread *t) {
+	t->start_time = rdtsc();
+}
 
 /****** SEE BELOW FOR EXTERNAL THREAD INTERFACE ********/
 
 
 nk_thread_queue_t*
-nk_thread_queue_create (void) 
+nk_thread_queue_create (void)
 {
     nk_thread_queue_t * q = NULL;
-
+    
     q = nk_queue_create();
-
+    
     if (!q) {
         ERROR_PRINT("Could not allocate thread queue\n");
         return NULL;
@@ -78,7 +107,7 @@ nk_thread_queue_create (void)
 /* NOTE: this does not delete the threads in the queue, just
  * their entries in the queue
  */
-void 
+void
 nk_thread_queue_destroy (nk_thread_queue_t * q)
 {
     // free any remaining entries
@@ -87,55 +116,55 @@ nk_thread_queue_destroy (nk_thread_queue_t * q)
 }
 
 
-inline void 
+inline void
 nk_enqueue_thread_on_runq (nk_thread_t * t, int cpu)
 {
     NK_PROFILE_ENTRY();
     nk_thread_queue_t * q = NULL;
     struct sys_info * sys = per_cpu_get(system);
-
+    
     /* TODO: these checks should only occur at creation time */
-    if (unlikely(cpu <= CPU_ANY || 
-        cpu >= sys->num_cpus)) {
-
+    if (unlikely(cpu <= CPU_ANY ||
+                 cpu >= sys->num_cpus)) {
+        
         q = per_cpu_get(run_q);
-
+        
     } else {
         q = sys->cpus[cpu]->run_q;
     }
-
+    
     /* bail if the run queue hasn't been created yet */
     ASSERT(q);
-
+    
     t->cur_run_q = q;
     t->status    = NK_THR_SUSPENDED;
-
+    
     nk_enqueue_entry_atomic(q, &(t->runq_node));
     NK_PROFILE_EXIT();
 }
 
-static inline void 
+
+static inline void
 enqueue_thread_on_waitq (nk_thread_t * waiter, nk_thread_queue_t * waitq)
 {
     ASSERT(waiter->status != NK_THR_WAITING);
-
     waiter->status = NK_THR_WAITING;
-
     nk_enqueue_entry_atomic(waitq, &(waiter->wait_node));
 }
 
+
 static inline nk_thread_t*
 dequeue_thread_from_waitq (nk_thread_t * waiter, nk_thread_queue_t * waitq)
 {
     nk_thread_t * t        = NULL;
     nk_queue_entry_t * elm = nk_dequeue_entry_atomic(waitq, &(waiter->wait_node));
-
+    
     t = container_of(elm, nk_thread_t, wait_node);
-
+    
     if (t) {
         t->status = NK_THR_SUSPENDED;
     }
-
+    
     return t;
 }
 
@@ -146,19 +175,19 @@ nk_dequeue_thread_from_runq (nk_thread_t * t)
     nk_thread_queue_t * q = t->cur_run_q;
     nk_queue_entry_t * elm = NULL;
     nk_thread_t * ret = NULL;
-
+    
     /* bail if the run queue doesn't exist */
     if (!q) {
         ERROR_PRINT("Attempt to dequeue thread not on run queue (cpu=%u)\n", my_cpu_id());
         return NULL;
     }
-
+    
     elm = nk_dequeue_entry_atomic(q, &(t->runq_node));
     ret = container_of(elm, nk_thread_t, runq_node);
-
+    
     t->status    = NK_THR_SUSPENDED;
     t->cur_run_q = NULL;
-
+    
     return ret;
 }
 
@@ -168,7 +197,7 @@ enqueue_thread_on_tlist (nk_thread_t * t)
 {
     nk_thread_queue_t * q = glob_sched_state->thread_list;
     nk_enqueue_entry_atomic(q, &(t->thr_list_node));
-
+    
     glob_sched_state->num_threads++;
 }
 
@@ -178,13 +207,13 @@ dequeue_thread_from_tlist (nk_thread_t * t)
 {
     nk_queue_entry_t * elm = NULL;
     nk_thread_t * ret = NULL;
-
+    
     nk_thread_queue_t * q = glob_sched_state->thread_list;
     elm = nk_dequeue_entry_atomic(q, &(t->thr_list_node));
     ret = container_of(elm, nk_thread_t, thr_list_node);
-
+    
     glob_sched_state->num_threads--;
-
+    
     return ret;
 }
 
@@ -202,37 +231,45 @@ dequeue_thread_from_tlist (nk_thread_t * t)
 static int
 thread_detach (nk_thread_t * t)
 {
+    #ifndef NAUT_CONFIG_USE_RT_SCHEDULER
     ASSERT(t->refcount > 0);
-
+    
     /* remove me from my parent's child list */
     list_del(&(t->child_node));
-
+    
     if (--t->refcount == 0) {
         nk_thread_destroy(t);
     }
 
+    #else
+        rt_thread *rt = t->rt_thread;
+        ASSERT(rt->parent != NULL);
+        list_remove(rt->parent->children, rt);
+        nk_thread_destroy(t);   
+    #endif
+    
     return 0;
 }
 
 
 
 
-static void 
-tls_exit (void) 
+static void
+tls_exit (void)
 {
     nk_thread_t * t = get_cur_thread();
     unsigned i, j;
     uint8_t called = 0;
-
+    
     for (i = 0; i < MIN_DESTRUCT_ITER; i++) {
         for (j = 0 ; j < TLS_MAX_KEYS; j++) {
-            void * val = (void*)t->tls[j]; 
+            void * val = (void*)t->tls[j];
             if (val && tls_keys[j].destructor) {
                 called = 1;
                 t->tls[j] = NULL;
                 tls_keys[j].destructor(val);
             }
-
+            
             if (!called) {
                 break;
             }
@@ -258,52 +295,52 @@ get_runnable_thread (uint32_t cpu)
     nk_queue_entry_t * elm   = NULL;
     struct sys_info * sys = per_cpu_get(system);
     uint8_t flags;
-
+    
     if (unlikely(cpu >= sys->num_cpus || !sys->cpus[cpu])) {
         ERROR_PRINT("Attempt to get thread on invalid CPU (%u)\n", cpu);
         return NULL;
     }
-
+    
     runq = sys->cpus[cpu]->run_q;
-
+    
     ASSERT(runq);
-
+    
     if (nk_queue_empty(runq)) {
         return NULL;
     }
-
+    
     flags = spin_lock_irq_save(&runq->lock);
-
+    
     elm = nk_dequeue_first(runq);
-
+    
     ASSERT(elm);
-
+    
     runnable = container_of(elm, nk_thread_t, runq_node);
-
-    if (!get_cur_thread()->is_idle && 
-         get_cur_thread()->status == NK_THR_RUNNING) {
-
+    
+    if (!get_cur_thread()->is_idle &&
+        get_cur_thread()->status == NK_THR_RUNNING) {
+        
         /* the next thing is an idle thread, but do we have something else to run? */
         if (runnable->is_idle)  {
-
+            
             if (!nk_queue_empty(runq)) {
-
+                
                 nk_thread_t * idle = runnable;
                 elm = nk_dequeue_first(runq);
-
+                
                 ASSERT(elm);
-
+                
                 runnable = container_of(elm, nk_thread_t, runq_node);
-
+                
                 ASSERT(runnable);
-
-
+                
+                
                 idle->status    = NK_THR_SUSPENDED;
                 nk_enqueue_entry(runq, &(idle->runq_node));
-
+                
                 //nk_enqueue_thread_on_runq(idle, cpu);
-
-
+                
+                
             } else  {
                 /* we put the idle thread back when it is the only thing on the queue */
                 runnable->status = NK_THR_SUSPENDED;
@@ -311,19 +348,19 @@ get_runnable_thread (uint32_t cpu)
                 //nk_enqueue_thread_on_runq(runnable, cpu);
                 runnable  = NULL;
             }
-
+            
         } else {
             /* all good, we switch to runnable */
         }
-
+        
     } else {
         /* if we're the idle thread, we *ALWAYS* run the next thing */
     }
-
+    
     if (runnable) {
         runnable->status = NK_THR_RUNNING;
     }
-
+    
     spin_unlock_irq_restore(&runq->lock, flags);
     //irq_enable_restore(flags);
     return runnable;
@@ -331,7 +368,7 @@ get_runnable_thread (uint32_t cpu)
 
 
 static inline nk_thread_t * __always_inline
-get_runnable_thread_myq (void) 
+get_runnable_thread_myq (void)
 {
     cpu_id_t id = my_cpu_id();
     return get_runnable_thread(id);
@@ -339,18 +376,18 @@ get_runnable_thread_myq (void)
 
 
 static int
-thread_init (nk_thread_t * t, 
-             void * stack, 
-             uint8_t is_detached, 
-             int cpu, 
+thread_init (nk_thread_t * t,
+             void * stack,
+             uint8_t is_detached,
+             int cpu,
              nk_thread_t * parent)
 {
-
+    
     if (!t) {
         ERROR_PRINT("Given NULL thread pointer...\n");
         return -EINVAL;
     }
-
+    
     t->stack      = stack;
     t->rsp        = (uint64_t)stack + t->stack_size - sizeof(uint64_t);
     t->tid        = atomic_inc(next_tid) + 1;
@@ -358,20 +395,20 @@ thread_init (nk_thread_t * t,
     t->parent     = parent;
     t->bound_cpu  = cpu;
     t->fpu_state_offset = offsetof(struct nk_thread, fpu_state);
-
+    
     INIT_LIST_HEAD(&(t->children));
-
+    
     /* I go on my parent's child list */
     if (parent) {
         list_add_tail(&(t->child_node), &(parent->children));
     }
-
+    
     t->waitq = nk_thread_queue_create();
     if (!t->waitq) {
         ERROR_PRINT("Could not create thread's wait queue\n");
         return -EINVAL;
     }
-
+    
     return 0;
 }
 
@@ -386,7 +423,7 @@ thread_cleanup (void)
 
 /*
  * utility function for setting up
- * a thread's stack 
+ * a thread's stack
  */
 static inline void
 thread_push (nk_thread_t * t, uint64_t x)
@@ -399,14 +436,14 @@ thread_push (nk_thread_t * t, uint64_t x)
 static void
 thread_setup_init_stack (nk_thread_t * t, nk_thread_fun_t fun, void * arg)
 {
-
+    
 #define RSP_STACK_OFFSET   8
 #define GPR_RDI_OFFSET     48
 #define GPR_RAX_OFFSET     8
 #define GPR_SAVE_SIZE      120
 #define STACK_SAVE_SIZE    64
 #define THREAD_SETUP_SIZE  (STACK_SAVE_SIZE + GPR_SAVE_SIZE)
-
+    
     /*
      * if this is a thread fork, this part is taken care of
      * in _thread_fork(). There is no function!
@@ -415,7 +452,7 @@ thread_setup_init_stack (nk_thread_t * t, nk_thread_fun_t fun, void * arg)
         thread_push(t, (uint64_t)&thread_cleanup);
         thread_push(t, (uint64_t)fun);
     }
-
+    
     thread_push(t, (uint64_t)KERNEL_SS);                 // SS
     thread_push(t, (uint64_t)(t->rsp+RSP_STACK_OFFSET)); // rsp
     thread_push(t, (uint64_t)0UL);                       // rflags
@@ -423,23 +460,23 @@ thread_setup_init_stack (nk_thread_t * t, nk_thread_fun_t fun, void * arg)
     thread_push(t, (uint64_t)&nk_thread_entry);
     thread_push(t, 0);                                   // dummy error code
     thread_push(t, 0);                                   // intr no
-
+    
     /*
-     * if we have a function, it needs an input argument 
+     * if we have a function, it needs an input argument
      * so we overwrite its RDI
-     */  
+     */
     if (fun) {
-        *(uint64_t*)(t->rsp-GPR_RDI_OFFSET) = (uint64_t)arg; 
+        *(uint64_t*)(t->rsp-GPR_RDI_OFFSET) = (uint64_t)arg;
     }
-
-    /* 
+    
+    /*
      * if this is a thread fork, we return 0 to the child
      * via RAX - note that _fork_return will not restore RAX
      */
     if (!fun) {
         *(uint64_t*)(t->rsp-GPR_RAX_OFFSET) = 0;
     }
-
+    
     t->rsp -= GPR_SAVE_SIZE;                             // account for the GPRS;
 }
 
@@ -450,11 +487,11 @@ thread_setup_init_stack (nk_thread_t * t, nk_thread_fun_t fun, void * arg)
 
 
 
-/* 
+/*
  * nk_thread_create
  *
- * creates a thread. 
- * its stack wil not be initialized with any intial data, 
+ * creates a thread.
+ * its stack wil not be initialized with any intial data,
  * and it will go on the thread list, but it wont be runnable
  *
  * @fun: the function to run
@@ -469,8 +506,9 @@ thread_setup_init_stack (nk_thread_t * t, nk_thread_fun_t fun, void * arg)
  * return: on error returns -EINVAL, returns 0 on success
  *
  */
+
 int
-nk_thread_create (nk_thread_fun_t fun, 
+nk_thread_create (nk_thread_fun_t fun,
                   void * input,
                   void ** output,
                   uint8_t is_detached,
@@ -480,22 +518,22 @@ nk_thread_create (nk_thread_fun_t fun,
 {
     nk_thread_t * t = NULL;
     void * stack    = NULL;
-
+    
     if (cpu == CPU_ANY) {
         cpu = my_cpu_id();
     }
-
+    
 #ifndef NAUT_CONFIG_THREAD_OPTIMIZE
     ASSERT(cpu < per_cpu_get(system)->num_cpus);
-
+    
     if (cpu >= per_cpu_get(system)->num_cpus) {
         ERROR_PRINT("thread create received invalid CPU id (%u)\n", cpu);
         return -EINVAL;
     }
 #endif
-
+    
     t = malloc(sizeof(nk_thread_t));
-
+    
 #ifndef NAUT_CONFIG_THREAD_OPTIMIZE
     ASSERT(t);
     if (!t) {
@@ -504,8 +542,8 @@ nk_thread_create (nk_thread_fun_t fun,
     }
     memset(t, 0, sizeof(nk_thread_t));
 #endif
-
-
+    
+    
 #ifndef NAUT_CONFIG_THREAD_OPTIMIZE
     if (stack_size) {
         stack         = (void*)malloc(stack_size);
@@ -518,14 +556,14 @@ nk_thread_create (nk_thread_fun_t fun,
     stack         = malloc(PAGE_SIZE_4KB);
     t->stack_size = PAGE_SIZE_4KB;
 #endif
-
+    
     ASSERT(stack);
-
+    
     if (thread_init(t, stack, is_detached, cpu, get_cur_thread()) < 0) {
         ERROR_PRINT("Could not initialize thread\n");
         goto out_err1;
     }
-
+    
     t->status = NK_THR_INIT;
     
     t->fun = fun;
@@ -533,15 +571,15 @@ nk_thread_create (nk_thread_fun_t fun,
     t->output = output;
     
     enqueue_thread_on_tlist(t);
-
+    
     if (tid) {
         *tid = (nk_thread_id_t)t;
     }
-
+    
     SCHED_DEBUG("Thread create creating new thread with t=%p, tid=%lu\n", t, t->tid);
-
+    
     return 0;
-
+    
 out_err1:
     free(stack);
     free(t);
@@ -549,10 +587,10 @@ out_err1:
 }
 
 
-/* 
+/*
  * nk_thread_start
  *
- * creates a thread and puts it on the specified cpu's run 
+ * creates a thread and puts it on the specified cpu's run
  * queue
  *
  * @fun: the function to run
@@ -562,94 +600,140 @@ out_err1:
  *               die immediately when it exits)
  * @stack_size: size of the thread's stack. 0 => let us decide
  * @tid: the opaque pointer passed to the user (output variable)
- * @cpu: cpu on which to bind the thread. CPU_ANY means any CPU 
+ * @cpu: cpu on which to bind the thread. CPU_ANY means any CPU
  *
  *
  * on error, returns -EINVAL, otherwise 0
  */
+
+#ifndef NAUT_CONFIG_USE_RT_SCHEDULER
 int
-nk_thread_start (nk_thread_fun_t fun, 
+nk_thread_start (nk_thread_fun_t fun,
                  void * input,
                  void ** output,
                  uint8_t is_detached,
                  nk_stack_size_t stack_size,
                  nk_thread_id_t * tid,
                  int cpu)
+#else
+int
+nk_thread_start (nk_thread_fun_t fun,
+                 void *input,
+                 void **output,
+                 uint8_t is_detached,
+                 nk_stack_size_t stack_size,
+                 nk_thread_id_t *tid,
+                 int cpu,
+                 int rt_type,
+                 rt_constraints *rt_constraints,
+                 uint64_t rt_deadline)
+
+#endif
 {
     nk_thread_id_t newtid   = NULL;
     nk_thread_t * newthread = NULL;
-
+    
     /* put it on the current CPU */
     if (cpu == CPU_ANY) {
         cpu = my_cpu_id();
     }
-
+    
     if (nk_thread_create(fun, input, output, is_detached, stack_size, &newtid, cpu) < 0) {
         ERROR_PRINT("Could not create thread\n");
         return -1;
     }
-
+    
     newthread = (nk_thread_t*)newtid;
-
+    
     if (tid) {
         *tid = newtid;
     }
-
+    
     thread_setup_init_stack(newthread, fun, input);
 
-    nk_enqueue_thread_on_runq(newthread, cpu);
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+    rt_thread *rt = rt_thread_init(rt_type, rt_constraints, rt_deadline, newthread);
+    nk_thread_t *parent = get_cur_thread();
+    if (parent != NULL) {
+        rt->parent = parent->rt_thread;
+
+        // Put myself on the parent's child list
+        if (parent->rt_thread != NULL) {
+            list_enqueue(parent->rt_thread->children, rt);
+        } else {
+            printk("THE CURRENT THREAD HAS NO REAL-TIME THREAD.\n");
+        }
+    } else {
+        rt->parent = NULL;
+    }
+
+    struct sys_info *sys = per_cpu_get(system);
+    if (sys->cpus[cpu]->rt_sched)
+    {
+        if (rt_type == APERIODIC) {
+            enqueue_thread(sys->cpus[cpu]->rt_sched->aperiodic, rt);
+        } else {
+            list_enqueue(sys->cpus[cpu]->rt_sched->arrival, rt);
+        }
+    }
 
+    nk_schedule();
+#else
+    nk_enqueue_thread_on_runq(newthread, cpu);
+#endif
+    
+    
 #ifdef NAUT_CONFIG_DEBUG_THREADS
     if (cpu == CPU_ANY) {
-        SCHED_DEBUG("Started thread (%p, tid=%u) on [ANY CPU]\n", newthread, newthread->tid); 
+        SCHED_DEBUG("Started thread (%p, tid=%u) on [ANY CPU]\n", newthread, newthread->tid);
     } else {
-        SCHED_DEBUG("Started thread (%p, tid=%u) on cpu %u\n", newthread, newthread->tid, cpu); 
+        SCHED_DEBUG("Started thread (%p, tid=%u) on cpu %u\n", newthread, newthread->tid, cpu);
     }
 #endif
-
+    
 #ifdef NAUT_CONFIG_KICK_SCHEDULE
     // kick it
     if (cpu != my_cpu_id()) {
         apic_ipi(per_cpu_get(apic),
-                nk_get_nautilus_info()->sys.cpus[cpu]->lapic_id,
-                APIC_NULL_KICK_VEC);
+                 nk_get_nautilus_info()->sys.cpus[cpu]->lapic_id,
+                 APIC_NULL_KICK_VEC);
     }
 #endif
-
+    
     return 0;
 }
 
 int nk_thread_run(nk_thread_id_t t)
 {
-  nk_thread_t * newthread = (nk_thread_t*)t;
-  printk("Trying to execute thread %p (tid %lu)", newthread,newthread->tid);
-  
-  printk("RUN: Function: %llu\n", newthread->fun);
-  printk("RUN: Bound_CPU: %llu\n", newthread->bound_cpu);
-  
-  thread_setup_init_stack(newthread, newthread->fun, newthread->input);
-  
-  nk_enqueue_thread_on_runq(newthread, newthread->bound_cpu);
-
+    nk_thread_t * newthread = (nk_thread_t*)t;
+    printk("Trying to execute thread %p (tid %lu)", newthread,newthread->tid);
+    
+    printk("RUN: Function: %llu\n", newthread->fun);
+    printk("RUN: Bound_CPU: %llu\n", newthread->bound_cpu);
+    
+    thread_setup_init_stack(newthread, newthread->fun, newthread->input);
+    
+    nk_enqueue_thread_on_runq(newthread, newthread->bound_cpu);
+    
 #ifdef NAUT_CONFIG_DEBUG_THREADS
-  if (newthread->bound_cpu == CPU_ANY) {
-    SCHED_DEBUG("Running thread (%p, tid=%u) on [ANY CPU]\n", newthread, newthread->tid); 
-  } else {
-    SCHED_DEBUG("Newthread thread (%p, tid=%u) on cpu %u\n", newthread, newthread->tid, newthread->bound_cpu); 
-  }
+    if (newthread->bound_cpu == CPU_ANY) {
+        SCHED_DEBUG("Running thread (%p, tid=%u) on [ANY CPU]\n", newthread, newthread->tid);
+    } else {
+        SCHED_DEBUG("Newthread thread (%p, tid=%u) on cpu %u\n", newthread, newthread->tid, newthread->bound_cpu);
+    }
 #endif
-  
+    
 #ifdef NAUT_CONFIG_KICK_SCHEDULE
-  // kick it
-  // this really should not fire on CPU_ANY....
-  if (newthread->bound_cpu != my_cpu_id()) {
-    apic_ipi(per_cpu_get(apic),
-	     nk_get_nautilus_info()->sys.cpus[newthread->bound_cpu]->lapic_id,
-	     APIC_NULL_KICK_VEC);
-  }
+    // kick it
+    // this really should not fire on CPU_ANY....
+    if (newthread->bound_cpu != my_cpu_id()) {
+        apic_ipi(per_cpu_get(apic),
+                 nk_get_nautilus_info()->sys.cpus[newthread->bound_cpu]->lapic_id,
+                 APIC_NULL_KICK_VEC);
+    }
 #endif
-
-  return 0;
+    
+    return 0;
 }
 
 
@@ -659,11 +743,17 @@ int nk_thread_run(nk_thread_id_t t)
  * wake all threads that are waiting on me
  *
  */
-void 
+void
 nk_wake_waiters (void)
 {
     nk_thread_t * me  = get_cur_thread();
-    nk_thread_queue_wake_all(me->waitq);
+
+    #ifndef NAUT_CONFIG_USE_RT_SCHEDULER
+        nk_thread_queue_wake_all(me->waitq);
+    #else
+        rt_thread *rt = me->rt_thread;
+        wake_up_all(rt);
+    #endif
 }
 
 
@@ -674,43 +764,61 @@ nk_wake_waiters (void)
  *
  * @retval: the value to return to the parent
  *
- * If there is someone waiting on this thread, this 
+ * If there is someone waiting on this thread, this
  * function will wake them up. This will also call
  * any destructors for thread local storage
  *
  */
 void
-nk_thread_exit (void * retval) 
+nk_thread_exit (void * retval)
+#ifndef NAUT_CONFIG_USE_RT_SCHEDULER
 {
     nk_thread_t * me = get_cur_thread();
-
+    
     /* clear any thread local storage that may have been allocated */
     tls_exit();
     
     while (__sync_lock_test_and_set(&me->lock, 1));
-
+    
     /* wait for my children to finish */
     nk_join_all_children(NULL);
-
+    
     me->output      = retval;
     me->status      = NK_THR_EXITED;
-
+    
     /* wake up everyone who is waiting on me */
     nk_wake_waiters();
-
+    
     me->refcount--;
-
+    
     SCHED_DEBUG("Thread %p (tid=%u) exiting, joining with children\n", me, me->tid);
-
+    
     __sync_lock_release(&me->lock);
-
+    
     cli();
-
+    
     nk_schedule();
-
+    
     /* we should never get here! */
     panic("Should never get here!\n");
 }
+#else
+{
+    nk_thread_t * me = get_cur_thread();
+    rt_thread *rt = me->rt_thread;
+
+    tls_exit();
+    nk_join_all_children(NULL);
+    me->output      = retval;
+    me->status      = NK_THR_EXITED;
+    nk_wake_waiters();
+
+    rt_thread_exit(rt);
+    while (rt->status != REMOVED);
+    nk_schedule();
+
+}
+#endif
 
 
 /*
@@ -722,37 +830,46 @@ nk_thread_exit (void * retval)
  * @t: the thread to destroy
  *
  */
-void 
+void
 nk_thread_destroy (nk_thread_id_t t)
 {
     nk_thread_t * thethread = (nk_thread_t*)t;
-
+    
     SCHED_DEBUG("Destroying thread (%p, tid=%lu)\n", (void*)thethread, thethread->tid);
 
-    ASSERT(!irqs_enabled());
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+    nk_thread_exit(thethread);
+#endif
 
+#ifndef NAUT_CONFIG_USE_RT_SCHEDULER
+    ASSERT(!irqs_enabled());
+#endif
+    
     nk_dequeue_thread_from_runq(thethread);
     dequeue_thread_from_tlist(thethread);
-
+    
     /* remove it from any wait queues */
     nk_dequeue_entry(&(thethread->wait_node));
-
-    /* remove its own wait queue 
+    
+    /* remove its own wait queue
      * (waiters should already have been notified */
     nk_thread_queue_destroy(thethread->waitq);
+    
 
     free(thethread->stack);
     free(thethread);
+
 }
 
 
+
 /*
  * nk_join
  *
  * join (wait) on the given thread
  *
  * t: the thread to wait on
- * retval: where the waited-on thread should 
+ * retval: where the waited-on thread should
  *         put its output
  *
  * returns  -EINVAL on error, 0 on success
@@ -760,16 +877,17 @@ nk_thread_destroy (nk_thread_id_t t)
  */
 int
 nk_join (nk_thread_id_t t, void ** retval)
+#ifndef NAUT_CONFIG_USE_RT_SCHEDULER
 {
     nk_thread_t *thethread = (nk_thread_t*)t;
     uint8_t flags;
-
+    
     ASSERT(thethread->parent == get_cur_thread());
-
+    
     flags = irq_disable_save();
-
+    
     while (__sync_lock_test_and_set(&thethread->lock, 1));
-
+    
     if (thethread->status == NK_THR_EXITED) {
         if (thethread->output) {
             *retval = thethread->output;
@@ -784,49 +902,71 @@ nk_join (nk_thread_id_t t, void ** retval)
             while (__sync_lock_test_and_set(&thethread->lock, 1));
         }
     }
-
+    
     if (retval) {
         *retval = thethread->output;
     }
-
+    
 out:
     __sync_lock_release(&thethread->lock);
     thread_detach(thethread);
     irq_enable_restore(flags);
     return 0;
 }
+#else
+{
+    nk_thread_t *thethread = (nk_thread_t *)t;
+    if (thethread->status == NK_THR_EXITED) {
+        if (thethread->output) {
+            *retval = thethread->output;
+        }
+        goto out;
+    } else {
+        while (*(volatile int*)&thethread->status != NK_THR_EXITED) {
+    
+        }
+    }
+    if (retval) {
+        *retval = thethread->output;
+    }
+out:
+    thread_detach(thethread);
+    return 0;
+}
+#endif
 
 
-/* 
+/*
  * nk_join_all_children
  *
  * Join all threads that the current thread
  * has either forked or spawned
  *
- * @func: this function will be called with each 
+ * @func: this function will be called with each
  *        output value generated by this threads
  *        children
  *
  *  returns -EINVAL on error, 0 on success
  *
  */
-int 
-nk_join_all_children (int (*func)(void * res)) 
+int
+nk_join_all_children (int (*func)(void * res))
 {
     nk_thread_t * elm = NULL;
     nk_thread_t * tmp = NULL;
     nk_thread_t * me         = get_cur_thread();
     void * res               = NULL;
     int ret                  = 0;
-
+    
+    #ifndef NAUT_CONFIG_USE_RT_SCHEDULER
     list_for_each_entry_safe(elm, tmp, &(me->children), child_node) {
-
+        
         if (nk_join(elm, &res) < 0) {
             ERROR_PRINT("Could not join child thread (t=%p)\n", elm);
             ret = -1;
             continue;
         }
-
+        
         if (func) {
             if (func(res) < 0) {
                 ERROR_PRINT("Could not invoke destructo for child thread (t=%p)\n", elm);
@@ -834,37 +974,69 @@ nk_join_all_children (int (*func)(void * res))
                 continue;
             }
         }
-
+        
     }
+    #else
+    rt_thread *rt = me->rt_thread;
+    rt_thread *n = list_dequeue(rt->children);
 
+    while (n != NULL) {
+         if (nk_join(n->thread, &res) < 0) {
+            ERROR_PRINT("Could not join child thread (t=%p)\n", elm);
+            ret = -1;
+            n = list_dequeue(rt->children);
+            continue;
+        }
+
+        if (func) {
+            if (func(res) < 0) {
+                ERROR_PRINT("Could not invoke destructo for child thread (t=%p)\n", elm);
+                ret = -1;
+                n = list_dequeue(rt->children);
+                continue;
+            }
+        }
+    } 
+    #endif
+    
     return ret;
 }
 
 
-/* 
+
+/*
  * nk_wait
  *
- * Go to sleep on a thread's wait queue. 
+ * Go to sleep on a thread's wait queue.
  *
  * @t : the thread to wait on
  *
  */
 void
 nk_wait (nk_thread_id_t t)
+#ifndef NAUT_CONFIG_USE_RT_SCHEDULER
 {
     nk_thread_t * cur    = get_cur_thread();
     nk_thread_t * waiton = (nk_thread_t*)t;
-
+    
     nk_thread_queue_t * wq = waiton->waitq;
-
-    /* make sure we're not putting ourselves on our 
+    
+    /* make sure we're not putting ourselves on our
      * own waitq */
     ASSERT(!irqs_enabled());
     ASSERT(wq != cur->waitq);
-
+    
     enqueue_thread_on_waitq(cur, wq);
     nk_schedule();
 }
+#else
+{   
+    nk_thread_t * cur = get_cur_thread();
+    rt_thread *rt = cur->rt_thread;
+    sleep_on_queue(rt);
+    nk_schedule();
+}
+#endif
 
 
 /*
@@ -874,43 +1046,56 @@ nk_wait (nk_thread_id_t t)
  *
  * TODO: do not replicate nk_schedule functionality
  */
-void 
+void
 nk_yield (void)
+#ifndef NAUT_CONFIG_USE_RT_SCHEDULER
 {
     nk_thread_t * runme = NULL;
     nk_thread_t * me    = get_cur_thread();
     uint8_t flags       = irq_disable_save();
-
     if (nk_queue_empty(per_cpu_get(run_q))) {
         irq_enable_restore(flags);
         return;
     }
-    /* only put myself on the run queue if there 
+    /* only put myself on the run queue if there
      * is something else to run */
     if ((runme = get_runnable_thread_myq())) {
-
+        
         nk_enqueue_thread_on_runq(me, me->bound_cpu);
-
 #ifdef NAUT_CONFIG_ENABLE_STACK_CHECK
         if (me->rsp <= (uint64_t)(me->stack)) {
-            panic("This thread (%p, tid=%u) has run off the end of its stack! (start=%p, rsp=%p, start size=%lx)\n", 
-                    (void*)me,
-                    me->tid,
-                    me->stack,
-                    (void*)me->rsp,
-                    me->stack_size);
+            panic("This thread (%p, tid=%u) has run off the end of its stack! (start=%p, rsp=%p, start size=%lx)\n",
+                  (void*)me,
+                  me->tid,
+                  me->stack,
+                  (void*)me->rsp,
+                  me->stack_size);
         }
 #endif /* !NAUT_CONFIG_ENABLE_STACK_CHECK */
-
         nk_thread_switch(runme);
-
+        
     }
-
     irq_enable_restore(flags);
 }
+#else
+{
+
+    struct sys_info *sys = per_cpu_get(system);
+    rt_scheduler *sched = sys->cpus[my_cpu_id()]->rt_sched;
+    nk_thread_t * me = get_cur_thread();
+    rt_thread *rt = me->rt_thread;
+
+    rt_thread_exit(rt);
+    while (rt->status != REMOVED);
+
+    rt->type = ARRIVED;
+    list_enqueue(sched->arrival, rt);
+    nk_schedule();
+}
+#endif
 
 
-/* 
+/*
  * nk_set_thread_fork_output
  *
  * @result: the output to set
@@ -930,9 +1115,10 @@ nk_set_thread_fork_output (void * result)
  * Goes to sleep on the given queue
  *
  * @q: the thread queue to sleep on
- * 
+ *
  */
-int 
+
+int
 nk_thread_queue_sleep (nk_thread_queue_t * q)
 {
     nk_thread_t * t = get_cur_thread();
@@ -945,7 +1131,25 @@ nk_thread_queue_sleep (nk_thread_queue_t * q)
 }
 
 
-/* 
+
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+int sleep_on_queue(rt_thread *sleep) {
+    struct sys_info *sys = per_cpu_get(system);
+    rt_scheduler *sched = sys->cpus[my_cpu_id()]->rt_sched;
+
+    nk_thread_t *t = get_cur_thread();
+    nk_thread_exit(t);
+    t->rt_thread->status = SLEEPING;
+    list_enqueue(sched->sleeping, t->rt_thread);
+    wait_on(t->rt_thread, sleep);
+    nk_schedule();
+    return 0;
+}
+#endif
+
+
+
+/*
  * nk_thread_queue_wake_one
  *
  * wake one thread waiting on this queue
@@ -955,48 +1159,48 @@ nk_thread_queue_sleep (nk_thread_queue_t * q)
  * returns -EINVAL on error, 0 on success
  *
  */
-int 
+int
 nk_thread_queue_wake_one (nk_thread_queue_t * q)
 {
     nk_queue_entry_t * elm = NULL;
     nk_thread_t * t = NULL;
     uint8_t flags = irq_disable_save();
-
+    
     SCHED_DEBUG("Thread queue wake one (q=%p)\n", (void*)q);
-
+    
     ASSERT(q);
-
+    
     elm = nk_dequeue_first_atomic(q);
-
+    
     /* no one is sleeping on this queue */
     if (!elm) {
         SCHED_DEBUG("No waiters on wait queue\n");
         goto out;
     }
-
+    
     t = container_of(elm, nk_thread_t, wait_node);
-
+    
     ASSERT(t);
     ASSERT(t->status == NK_THR_WAITING);
-
+    
     nk_enqueue_thread_on_runq(t, t->bound_cpu);
-
+    
 #ifdef NAUT_CONFIG_KICK_SCHEDULE
     // kick it
     if (t->bound_cpu != my_cpu_id()) {
         apic_ipi(per_cpu_get(apic),
-                nk_get_nautilus_info()->sys.cpus[t->bound_cpu]->lapic_id,
-                APIC_NULL_KICK_VEC);
+                 nk_get_nautilus_info()->sys.cpus[t->bound_cpu]->lapic_id,
+                 APIC_NULL_KICK_VEC);
     }
 #endif
-
+    
 out:
     irq_enable_restore(flags);
     return 0;
 }
 
 
-/* 
+/*
  * nk_thread_queue_wake_all
  *
  * wake all threads waiting on this queue
@@ -1012,37 +1216,37 @@ nk_thread_queue_wake_all (nk_thread_queue_t * q)
     nk_queue_entry_t * elm = NULL;
     nk_thread_t * t = NULL;
     uint8_t flags;
-
+    
     SCHED_DEBUG("Waking all waiters on thread queue (q=%p)\n", (void*)q);
-
+    
     ASSERT(q);
-
+    
     flags = spin_lock_irq_save(&q->lock);
-
+    
     while ((elm = nk_dequeue_first(q))) {
         t = container_of(elm, nk_thread_t, wait_node);
-
+        
         ASSERT(t);
         ASSERT(t->status == NK_THR_WAITING);
-
+        
         nk_enqueue_thread_on_runq(t, t->bound_cpu);
-
+        
 #ifdef NAUT_CONFIG_KICK_SCHEDULE
         if (t->bound_cpu != my_cpu_id()) {
             apic_ipi(per_cpu_get(apic),
-                    nk_get_nautilus_info()->sys.cpus[t->bound_cpu]->lapic_id,
-                    APIC_NULL_KICK_VEC);
+                     nk_get_nautilus_info()->sys.cpus[t->bound_cpu]->lapic_id,
+                     APIC_NULL_KICK_VEC);
         }
 #endif
-
+        
     }
-
+    
     spin_unlock_irq_restore(&q->lock, flags);
     return 0;
 }
 
 
-/* 
+/*
  * nk_tls_key_create
  *
  * create thread local storage
@@ -1058,21 +1262,21 @@ int
 nk_tls_key_create (nk_tls_key_t * key, void (*destructor)(void*))
 {
     int i;
-
+    
     for (i = 0; i < TLS_MAX_KEYS; i++) {
         unsigned sn = tls_keys[i].seq_num;
-
+        
         if (TLS_KEY_AVAIL(sn) && TLS_KEY_USABLE(sn) &&
             atomic_cmpswap(tls_keys[i].seq_num, sn, sn+1) == sn) {
-
+            
             tls_keys[i].destructor = destructor;
             *key = i;
-
+            
             /* we're done */
             return 0;
         }
     }
-
+    
     return -EAGAIN;
 }
 
@@ -1085,23 +1289,23 @@ nk_tls_key_create (nk_tls_key_t * key, void (*destructor)(void*))
  * returns -EINVAL on error, 0 on success
  *
  */
-int 
+int
 nk_tls_key_delete (nk_tls_key_t key)
 {
     if (likely(key < TLS_MAX_KEYS)) {
         unsigned sn = tls_keys[key].seq_num;
-
+        
         if (likely(!TLS_KEY_AVAIL(sn)) &&
             atomic_cmpswap(tls_keys[key].seq_num, sn, sn+1) == sn) {
             return 0;
         }
     }
-
+    
     return -EINVAL;
 }
 
 
-/* 
+/*
  * nk_tls_get
  *
  * get the value stored for this key for this
@@ -1113,20 +1317,20 @@ nk_tls_key_delete (nk_tls_key_t key)
  *
  */
 void*
-nk_tls_get (nk_tls_key_t key) 
+nk_tls_get (nk_tls_key_t key)
 {
     nk_thread_t * t;
-
+    
     if (unlikely(key >= TLS_MAX_KEYS)) {
         return NULL;
     }
-
+    
     t = get_cur_thread();
     return (void*)t->tls[key];
 }
 
 
-/* 
+/*
  * nk_tls_set
  *
  * @key: the key to use for index lookup
@@ -1135,17 +1339,17 @@ nk_tls_get (nk_tls_key_t key)
  * returns -EINVAL on error, 0 on success
  *
  */
-int 
+int
 nk_tls_set (nk_tls_key_t key, const void * val)
 {
     nk_thread_t * t;
     unsigned sn;
-
-    if (key >= TLS_MAX_KEYS || 
+    
+    if (key >= TLS_MAX_KEYS ||
         TLS_KEY_AVAIL((sn = tls_keys[key].seq_num))) {
         return -EINVAL;
     }
-
+    
     t = get_cur_thread();
     t->tls[key] = val;
     return 0;
@@ -1160,21 +1364,21 @@ nk_tls_set (nk_tls_key_t key, const void * val)
  *
  */
 nk_thread_id_t
-nk_get_tid (void) 
+nk_get_tid (void)
 {
     nk_thread_t * t = (nk_thread_t*)get_cur_thread();
     return (nk_thread_id_t)t;
 }
 
 
-/* 
+/*
  * nk_get_parent_tid
  *
  * get this thread's parent tid
  *
  */
 nk_thread_id_t
-nk_get_parent_tid (void) 
+nk_get_parent_tid (void)
 {
     nk_thread_t * t = (nk_thread_t*)get_cur_thread();
     if (t && t->parent) {
@@ -1189,10 +1393,6 @@ nk_get_parent_tid (void)
 
 /********** END EXTERNAL INTERFACE **************/
 
-
-
-
-
 // push the child stack down by this much just in case
 // we only have one caller frame to mangle
 // the launcher function needs to put a new return address
@@ -1203,13 +1403,13 @@ nk_get_parent_tid (void)
 #define STACK_SIZE_MIN    (4096 * 16)
 #define LAUNCHER_STACK_SIZE STACK_SIZE_MIN
 
-/* 
+/*
  * note that this isn't called directly. It is vectored
  * into from an assembly stub
  *
  * On success, pareant gets child's tid, child gets 0
  */
-nk_thread_id_t 
+nk_thread_id_t
 __thread_fork (void)
 {
     nk_thread_id_t  tid;
@@ -1217,32 +1417,32 @@ __thread_fork (void)
     nk_stack_size_t size, alloc_size;
     uint64_t     rbp1_offset_from_ret0_addr;
     void         *child_stack;
-
-#ifdef NAUT_CONFIG_THREAD_OPTIMIZE 
+    
+#ifdef NAUT_CONFIG_THREAD_OPTIMIZE
     SCHED_WARN("Thread fork may function incorrectly with aggressive threading optimizations\n");
 #endif
-
+    
     void *rbp0      = __builtin_frame_address(0);                   // current rbp, *rbp0 = rbp1
     void *rbp1      = __builtin_frame_address(1);                   // caller rbp, *rbp1 = rbp2  (forker's frame)
     void *rbp_tos   = __builtin_frame_address(STACK_CLONE_DEPTH);   // should scan backward to avoid having this be zero or crazy
     void *ret0_addr = rbp0 + 8;
-
-
+    
+    
     // we're being called with a stack not as deep as STACK_CLONE_DEPTH...
     // fail back to a single frame...
-    if (rbp_tos == 0 || rbp_tos < rbp1) { 
+    if (rbp_tos == 0 || rbp_tos < rbp1) {
         rbp_tos = rbp1;
     }
-
+    
     // from last byte of tos_rbp to the last byte of the stack on return from this function (return address of wrapper
     // the "launch pad" is added so that in the case where there is no stack frame above the caller
     // we still have the space to fake one.
-    size = (rbp_tos + 8) - ret0_addr + LAUNCHPAD;   
-
+    size = (rbp_tos + 8) - ret0_addr + LAUNCHPAD;
+    
     rbp1_offset_from_ret0_addr = rbp1 - ret0_addr;
-
+    
     alloc_size = (size > STACK_SIZE_MIN) ? size : STACK_SIZE_MIN;    // at least enough to grow to STACK_SIZE_MIN
-
+    
     if (nk_thread_create(NULL,        // no function pointer, we'll set rip explicity in just a sec...
                          NULL,        // no input args, it's not a function
                          NULL,        // no output args
@@ -1250,77 +1450,126 @@ __thread_fork (void)
                          TSTACK_2MB,  // stack size
                          &tid,        // give me a thread id
                          CPU_ANY)     // not bound to any particular CPU
-            < 0) {
+        < 0) {
         ERROR_PRINT("Could not fork thread\n");
         return 0;
     }
-
+    
     t = (nk_thread_t*)tid;
-
+    
     child_stack = t->stack;
-
+    
     // this is at the top of the stack, just in case something goes wrong
     thread_push(t, (uint64_t)&thread_cleanup);
-
+    
     // Copy stack frames of caller and up to stack max
     // this should copy from 1st byte of my_rbp to last byte of tos_rbp
     // notice that leaves ret
     memcpy(child_stack + alloc_size - size, ret0_addr, size - LAUNCHPAD);
     t->rsp = (uint64_t)(child_stack + alloc_size - size);
-
+    
     void **rbp2_ptr = (void**)(t->rsp + rbp1_offset_from_ret0_addr);
     void **ret2_ptr = rbp2_ptr+1;
-
+    
     // rbp2 we don't care about
     *rbp2_ptr = 0x0ULL;
-
+    
     // fix up the return address to point to our thread cleanup function
     *ret2_ptr = &thread_cleanup;
-
+    
     // now we need to setup the interrupt stack etc.
     // we provide null for thread func to indicate this is a fork
-    thread_setup_init_stack(t, NULL, NULL); 
-
+    thread_setup_init_stack(t, NULL, NULL);
+    
+    
     // put it on the run queue
-    nk_enqueue_thread_on_runq(t, t->bound_cpu);
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+    uint8_t flags = irq_disable_save();
+    nk_thread_t *me = get_cur_thread();
+    irq_enable_restore(flags);
+
+    int cpu = t->bound_cpu;
+    if (me->rt_thread == NULL) {
+        RT_THREAD_DEBUG("REAL-TIME FORK FAILED.\n");
+        return 0;
+    }
+
+    rt_thread *rt_parent = me->rt_thread;
+    rt_thread *rt = rt_thread_init(rt_parent->type, rt_parent->constraints, rt_parent->deadline, tid);
+    rt->parent = rt_parent;
+    if (rt_parent != NULL) {
+        list_enqueue(rt_parent->children, rt);
+    } else {
+        printk("THE CURRENT THREAD HAS NO REAL-TIME THREAD.\n");
+    }
+
+    struct sys_info *sys = per_cpu_get(system);
+    if (sys->cpus[cpu]->rt_sched)
+    {
+        if (rt->type == APERIODIC) {
+            enqueue_thread(sys->cpus[cpu]->rt_sched->aperiodic, rt);
+        } else {
+            list_enqueue(sys->cpus[cpu]->rt_sched->arrival, rt);  
+        }
+    }
 
+#else 
+    nk_enqueue_thread_on_runq(t, t->bound_cpu);
+#endif
     // return child's tid to parent
     return tid;
 }
 
 
 nk_thread_t*
-nk_need_resched (void) 
+nk_need_resched (void)
+#ifndef NAUT_CONFIG_USE_RT_SCHEDULER
 {
     nk_thread_t * p;
     nk_thread_t * c;
-
     ASSERT(!irqs_enabled());
-
+    
     c = get_cur_thread();
     p = get_runnable_thread_myq();
-
+    
     if (p) {
         nk_enqueue_thread_on_runq(c, c->bound_cpu);
     }
-
+    
     return p;
 }
+#else
+{
+    uint64_t start_time = rdtsc();
+    ASSERT(!irqs_enabled());
+	nk_thread_t * current = get_cur_thread();
+    update_exit(current->rt_thread);
+	nk_thread_t * thread = rt_need_resched();
+    struct sys_info *sys = per_cpu_get(system);
+	rt_scheduler *sched = sys->cpus[thread->bound_cpu]->rt_sched; 
+    uint64_t end_time = rdtsc();
+	sched->run_time = sched->run_time > (end_time - start_time) ? sched->run_time : (end_time - start_time);
+    while (rdtsc() < sched->tsc->end_time); 
+	update_enter(thread->rt_thread);
+	return thread;
+}
+#endif
 
 
-/* 
+/*
  * schedule
  *
  * pick a thread to run
  *
  */
 void
-nk_schedule (void) 
+nk_schedule (void)
+#ifndef NAUT_CONFIG_USE_RT_SCHEDULER
 {
     nk_thread_t * runme = NULL;
-
+    
     ASSERT(!irqs_enabled());
-
+    
     while (unlikely(!(runme = get_runnable_thread_myq()))) {
         SCHED_DEBUG("Core %u sleeping, nothing on the ready queue\n", my_cpu_id());
 #ifdef NAUT_CONFIG_HALT_WHILE_IDLE
@@ -1328,27 +1577,42 @@ nk_schedule (void)
         halt();
 #endif
     }
-
-
+    
 #ifdef NAUT_CONFIG_ENABLE_STACK_CHECK
     // before we switch, make sure we're not
     // stomping around past our given stack...
     nk_thread_t * me  = get_cur_thread();
-
+    
     // we've overrun our stack...
     if (me->rsp <= (uint64_t)(me->stack)) {
-        panic("This thread (%p, tid=%u) has run off the end of its stack! (start=%p, rsp=%p, start size=%lx)\n", 
-                (void*)me,
-                me->tid,
-                me->stack,
-                (void*)me->rsp,
-                me->stack_size);
+        panic("This thread (%p, tid=%u) has run off the end of its stack! (start=%p, rsp=%p, start size=%lx)\n",
+              (void*)me,
+              me->tid,
+              me->stack,
+              (void*)me->rsp,
+              me->stack_size);
     }
 #endif /* !NAUT_CONFIG_ENABLE_STACK_CHECK */
-
-
+    
+    
     nk_thread_switch(runme);
 }
+#else
+{
+    uint8_t flags = irq_disable_save();
+    nk_thread_t *runme = nk_need_resched();
+    if (!runme)
+    {
+        RT_THREAD_DEBUG("WE CAN PUT LOW POWER SAVING MODE HERE");
+        panic("NO THREAD TO SWITCH TO");
+    }
+    else
+    {
+        nk_thread_switch(runme);
+        irq_enable_restore(flags);
+    }
+}
+#endif
 
 
 /*
@@ -1356,8 +1620,7 @@ nk_schedule (void)
  *
  * scheduler init routine for APs once they
  * have booted up
- *
- */
+  */
 int
 nk_sched_init_ap (void)
 {
@@ -1366,61 +1629,66 @@ nk_sched_init_ap (void)
     cpu_id_t id = my_cpu_id();
     struct cpu * my_cpu = get_cpu();
     uint8_t flags;
-
+    
     flags = irq_disable_save();
-
+    
     SCHED_DEBUG("Initializing CPU %u\n", id);
-
+    
     my_cpu->run_q = nk_thread_queue_create();
-
+    
     if (!my_cpu->run_q) {
         ERROR_PRINT("Could not create run queue for CPU %u)\n", id);
         goto out_err;
     }
-
+    
     me = malloc(sizeof(nk_thread_t));
     if (!me) {
         ERROR_PRINT("Could not allocate thread for CPU (%u)\n", id);
         goto out_err1;
     }
     memset(me, 0, sizeof(nk_thread_t));
-
-    my_stack = malloc(PAGE_SIZE); 
+    
+    my_stack = malloc(PAGE_SIZE);
     if (!my_stack) {
         ERROR_PRINT("Couldn't allocate new stack for CPU (%u)\n", id);
         goto out_err2;
     }
     memset(my_stack, 0, PAGE_SIZE);
-
+    
     /* we have no parent thread... */
-
+    
     me->stack_size = PAGE_SIZE;
     if (thread_init(me, my_stack, 1, id, NULL) != 0) {
         ERROR_PRINT("Could not init start thread on core %u\n", id);
         goto out_err3;
     }
     me->status = NK_THR_RUNNING;
-
+    
     me->waitq = nk_thread_queue_create();
     if (!me->waitq) {
         ERROR_PRINT("Could not create waitq for thread on cpu %u\n", id);
         goto out_err3;
     }
-
+    
+    
     // set my current thread
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+    my_cpu->rt_sched = rt_scheduler_init(rt_thread_init(APERIODIC, NULL, 0, me));
+    //enqueue_thread(my_cpu->rt_sched->aperiodic, my_cpu->rt_sched->main_thread);
+#endif
+    
     put_cur_thread(me);
-
     enqueue_thread_on_tlist(me);
-
+    
     // start another idle thread
-#ifdef NAUT_CONFIG_USE_IDLE_THREADS
+#if defined(NAUT_CONFIG_USE_IDLE_THREADS) && !defined(NAUT_CONFIG_USE_RT_SCHEDULER)
     SCHED_DEBUG("Starting idle thread for cpu %d\n", id);
     nk_thread_start(idle, NULL, NULL, 0, TSTACK_DEFAULT, NULL, id);
 #endif
-
+    
     irq_enable_restore(flags);
     return 0;
-
+    
 out_err3:
     free(me->stack);
 out_err2:
@@ -1433,46 +1701,46 @@ out_err:
 }
 
 
-/* 
+/*
  * sched_init
  *
  * entry point into the scheduler at bootup
  *
  */
 int
-nk_sched_init (void) 
+nk_sched_init (void)
 {
     struct nk_sched_state * sched = NULL;
     struct cpu * my_cpu = nk_get_nautilus_info()->sys.cpus[nk_get_nautilus_info()->sys.bsp_id];
     nk_thread_t * main = NULL;
     void * my_stack = NULL;
     int flags;
-
+    
     flags = irq_disable_save();
-
+    
     SCHED_PRINT("Initializing scheduler\n");
-
+    
     sched = malloc(sizeof(struct nk_sched_state));
     if (!sched) {
         ERROR_PRINT("Could not allocate scheduler state\n");
         goto out_err0;
     }
     memset(sched, 0, sizeof(struct nk_sched_state));
-
+    
     my_cpu->run_q = nk_thread_queue_create();
     if (!my_cpu->run_q) {
         ERROR_PRINT("Could not create run queue\n");
         goto out_err1;
     }
-
+    
     sched->thread_list = nk_thread_queue_create();
     if (!sched->thread_list) {
         ERROR_PRINT("Could not create thread list\n");
         goto out_err2;
     }
-
+    
     glob_sched_state = sched;
-
+    
     // first we need to add our current thread as the current thread
     main  = malloc(sizeof(nk_thread_t));
     if (!main) {
@@ -1487,9 +1755,9 @@ nk_sched_init (void)
         goto out_err4;
     }
     memset(my_stack, 0, PAGE_SIZE);
-
+    
     main->stack_size = PAGE_SIZE;
-
+    
     thread_init(main, my_stack, 1, 0, NULL);
     main->status = NK_THR_RUNNING;
     main->waitq = nk_thread_queue_create();
@@ -1497,20 +1765,23 @@ nk_sched_init (void)
         ERROR_PRINT("Could not create main thread's wait queue\n");
         goto out_err5;
     }
-
+    
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+    my_cpu->rt_sched = rt_scheduler_init(rt_thread_init(APERIODIC, NULL, 0, main));
+#endif
+    
     put_cur_thread(main);
-
     enqueue_thread_on_tlist(main);
-
-#ifdef NAUT_CONFIG_USE_IDLE_THREADS
-    // the idle thread
+    
+#if defined(NAUT_CONFIG_USE_IDLE_THREADS) && !defined(NAUT_CONFIG_USE_RT_SCHEDULER)
+    SCHED_DEBUG("Starting idle thread for cpu %d\n", my_cpu->id);
     nk_thread_start(idle, NULL, NULL, 0, TSTACK_DEFAULT, NULL, my_cpu->id);
 #endif
-
+    
     irq_enable_restore(flags);
-
+    
     return 0;
-
+    
 out_err5:
     free(main->stack);
 out_err4:
@@ -1519,7 +1790,7 @@ out_err3:
     free(sched->thread_list);
 out_err2:
     free(my_cpu->run_q);
-out_err1: 
+out_err1:
     free(sched);
 out_err0:
     sti();
@@ -1529,44 +1800,44 @@ out_err0:
 
 
 
-static void 
+static void
 tls_dummy (void * in, void ** out)
 {
     unsigned i;
     nk_tls_key_t * keys = NULL;
-
+    
     //printk("Beginning test of thread local storage...\n");
     keys = malloc(sizeof(nk_tls_key_t)*TLS_MAX_KEYS);
     if (!keys) {
         ERROR_PRINT("could not allocate keys\n");
         return;
     }
-
+    
     for (i = 0; i < TLS_MAX_KEYS; i++) {
         if (nk_tls_key_create(&keys[i], NULL) != 0) {
             ERROR_PRINT("Could not create TLS key (%u)\n", i);
             goto out_err;
         }
-
+        
         if (nk_tls_set(keys[i], (const void *)(i + 100L)) != 0) {
             ERROR_PRINT("Could not set TLS key (%u)\n", i);
             goto out_err;
         }
-
+        
     }
-
+    
     for (i = 0; i < TLS_MAX_KEYS; i++) {
         if (nk_tls_get(keys[i]) != (void*)(i + 100L)) {
             ERROR_PRINT("Mismatched TLS val! Got %p, should be %p\n", nk_tls_get(keys[i]), (void*)(i+100L));
             goto out_err;
         }
-
+        
         if (nk_tls_key_delete(keys[i]) != 0) {
             ERROR_PRINT("Could not delete TLS key %u\n", i);
             goto out_err;
         }
     }
-
+    
     if (nk_tls_key_create(&keys[0], NULL) != 0) {
         ERROR_PRINT("2nd key create failed\n");
         goto out_err;
@@ -1576,18 +1847,94 @@ tls_dummy (void * in, void ** out)
         ERROR_PRINT("2nd key delete failed\n");
         goto out_err;
     }
-
+    
     printk("Thread local storage test succeeded\n");
-
+    
 out_err:
     free(keys);
 }
 
+int
+nk_thread_start_sim (nk_thread_fun_t fun,
+                 void *input,
+                 void **output,
+                 uint8_t is_detached,
+                 nk_stack_size_t stack_size,
+                 nk_thread_id_t *tid,
+                 int cpu,
+                 int rt_type,
+                 rt_constraints *rt_constraints,
+                 uint64_t rt_deadline)
 
-void 
-nk_tls_test (void)
 {
-    nk_thread_start(tls_dummy, NULL, NULL, 1, TSTACK_DEFAULT, NULL, 1);
+    nk_thread_id_t newtid   = NULL;
+    nk_thread_t * newthread = NULL;
+    
+    /* put it on the current CPU */
+    if (cpu == CPU_ANY) {
+        cpu = my_cpu_id();
+    }
+    
+    if (nk_thread_create(fun, input, output, is_detached, stack_size, &newtid, cpu) < 0) {
+        ERROR_PRINT("Could not create thread\n");
+        return -1;
+    }
+    
+    newthread = (nk_thread_t*)newtid;
+    
+    if (tid) {
+        *tid = newtid;
+    }
+    
+    thread_setup_init_stack(newthread, fun, input);
+
+
+
+#ifdef NAUT_CONFIG_USE_RT_SCHEDULER
+    rt_thread *rt = rt_thread_init(rt_type, rt_constraints, rt_deadline, newthread);
+    struct sys_info *sys = per_cpu_get(system);
+    nk_thread_t *parent = get_cur_thread();
+    if (parent != NULL) {
+        rt->parent = parent->rt_thread;
+
+        // Put myself on the parent's child list
+        if (parent->rt_thread != NULL) {
+            list_enqueue(parent->rt_thread->children, rt);
+        } else {
+            printk("THE CURRENT THREAD HAS NO REAL-TIME THREAD.\n");
+        }
+    } else {
+        rt->parent = NULL;
+    }
+
+    if (sys->cpus[cpu]->rt_sched) {
+        rt->status = ADMITTED;
+        enqueue_thread(sys->cpus[cpu]->rt_sched->runnable, rt);
+    }
+    nk_schedule();
+#else
+    nk_enqueue_thread_on_runq(newthread, cpu);
+#endif
+    
+    
+#ifdef NAUT_CONFIG_DEBUG_THREADS
+    if (cpu == CPU_ANY) {
+        SCHED_DEBUG("Started thread (%p, tid=%u) on [ANY CPU]\n", newthread, newthread->tid);
+    } else {
+        SCHED_DEBUG("Started thread (%p, tid=%u) on cpu %u\n", newthread, newthread->tid, cpu);
+    }
+#endif
+    
+#ifdef NAUT_CONFIG_KICK_SCHEDULE
+    // kick it
+    if (cpu != my_cpu_id()) {
+        apic_ipi(per_cpu_get(apic),
+                 nk_get_nautilus_info()->sys.cpus[cpu]->lapic_id,
+                 APIC_NULL_KICK_VEC);
+    }
+#endif
+    
+    return 0;
 }
 
 
diff --git a/./src/nautilus/ticketlock.c b/../../nrt/nautilus/src/nautilus/ticketlock.c
old mode 100644
new mode 100755
diff --git a/./src/nautilus/vc.c b/../../nrt/nautilus/src/nautilus/vc.c
old mode 100644
new mode 100755
index 35293d7..ec8efa8
--- a/./src/nautilus/vc.c
+++ b/../../nrt/nautilus/src/nautilus/vc.c
@@ -908,7 +908,9 @@ int nk_switch_to_vc_list()
 static int start_list()
 {
 
-  nk_thread_start(list, 0, 0, 0, PAGE_SIZE, &list_tid, -1);
+  
+  // nk_thread_start(list, 0, 0, 0, PAGE_SIZE, &list_tid, -1);
+
   
   INFO("List launched\n");
 
diff --git a/./src/test/Makefile b/../../nrt/nautilus/src/test/Makefile
old mode 100644
new mode 100755
diff --git a/./src/test/benchmark.c b/../../nrt/nautilus/src/test/benchmark.c
old mode 100644
new mode 100755
diff --git a/./src/test/benchmark.h b/../../nrt/nautilus/src/test/benchmark.h
old mode 100644
new mode 100755
diff --git a/./src/test/circuit.cc b/../../nrt/nautilus/src/test/circuit.cc
old mode 100644
new mode 100755
diff --git a/./src/test/circuit.h b/../../nrt/nautilus/src/test/circuit.h
old mode 100644
new mode 100755
diff --git a/./src/test/circuit_cpu.cc b/../../nrt/nautilus/src/test/circuit_cpu.cc
old mode 100644
new mode 100755
diff --git a/./src/test/circuit_mapper.cc b/../../nrt/nautilus/src/test/circuit_mapper.cc
old mode 100644
new mode 100755
diff --git a/./src/test/circuit_mapper.h b/../../nrt/nautilus/src/test/circuit_mapper.h
old mode 100644
new mode 100755
diff --git a/./src/test/custom_mapper.cc b/../../nrt/nautilus/src/test/custom_mapper.cc
old mode 100644
new mode 100755
diff --git a/./src/test/global_vars.cc b/../../nrt/nautilus/src/test/global_vars.cc
old mode 100644
new mode 100755
diff --git a/./src/test/hello_world.cc b/../../nrt/nautilus/src/test/hello_world.cc
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/Makefile b/../../nrt/nautilus/src/test/hpcg/Makefile
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/cg-data.h b/../../nrt/nautilus/src/test/hpcg/cg-data.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/cg-mapper.h b/../../nrt/nautilus/src/test/hpcg/cg-mapper.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/cg.h b/../../nrt/nautilus/src/test/hpcg/cg.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/comp-dotprod.h b/../../nrt/nautilus/src/test/hpcg/comp-dotprod.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/comp-mg.h b/../../nrt/nautilus/src/test/hpcg/comp-mg.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/comp-prolongation.h b/../../nrt/nautilus/src/test/hpcg/comp-prolongation.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/comp-restriction.h b/../../nrt/nautilus/src/test/hpcg/comp-restriction.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/comp-spmv.h b/../../nrt/nautilus/src/test/hpcg/comp-spmv.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/comp-symgs.h b/../../nrt/nautilus/src/test/hpcg/comp-symgs.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/comp-waxpby.h b/../../nrt/nautilus/src/test/hpcg/comp-waxpby.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/dotprod-accumulate.h b/../../nrt/nautilus/src/test/hpcg/dotprod-accumulate.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/geometry.h b/../../nrt/nautilus/src/test/hpcg/geometry.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/hpcg-main.c.bak b/../../nrt/nautilus/src/test/hpcg/hpcg-main.c.bak
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/hpcg-main.cc b/../../nrt/nautilus/src/test/hpcg/hpcg-main.cc
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/hpcg-problem-generator.h b/../../nrt/nautilus/src/test/hpcg/hpcg-problem-generator.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/hpcg-problem.c.bak b/../../nrt/nautilus/src/test/hpcg/hpcg-problem.c.bak
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/hpcg-problem.cc b/../../nrt/nautilus/src/test/hpcg/hpcg-problem.cc
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/hpcg-problem.h b/../../nrt/nautilus/src/test/hpcg/hpcg-problem.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/lgncg.c.bak b/../../nrt/nautilus/src/test/hpcg/lgncg.c.bak
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/lgncg.cc b/../../nrt/nautilus/src/test/hpcg/lgncg.cc
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/lgncg.h b/../../nrt/nautilus/src/test/hpcg/lgncg.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/mg-data.h b/../../nrt/nautilus/src/test/hpcg/mg-data.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/setup-halo.h b/../../nrt/nautilus/src/test/hpcg/setup-halo.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/sparsemat.h b/../../nrt/nautilus/src/test/hpcg/sparsemat.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/tids.h b/../../nrt/nautilus/src/test/hpcg/tids.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/utils.h b/../../nrt/nautilus/src/test/hpcg/utils.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/vec-zero.h b/../../nrt/nautilus/src/test/hpcg/vec-zero.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/veccp.h b/../../nrt/nautilus/src/test/hpcg/veccp.h
old mode 100644
new mode 100755
diff --git a/./src/test/hpcg/vector.h b/../../nrt/nautilus/src/test/hpcg/vector.h
old mode 100644
new mode 100755
diff --git a/./src/test/index_tasks.cc b/../../nrt/nautilus/src/test/index_tasks.cc
old mode 100644
new mode 100755
diff --git a/./src/test/ipi.c b/../../nrt/nautilus/src/test/ipi.c
old mode 100644
new mode 100755
diff --git a/./src/test/logical_regions.cc b/../../nrt/nautilus/src/test/logical_regions.cc
old mode 100644
new mode 100755
diff --git a/./src/test/multiple_partitions.cc b/../../nrt/nautilus/src/test/multiple_partitions.cc
old mode 100644
new mode 100755
diff --git a/./src/test/partitioning.cc b/../../nrt/nautilus/src/test/partitioning.cc
old mode 100644
new mode 100755
diff --git a/./src/test/physical_regions.cc b/../../nrt/nautilus/src/test/physical_regions.cc
old mode 100644
new mode 100755
diff --git a/./src/test/privileges.cc b/../../nrt/nautilus/src/test/privileges.cc
old mode 100644
new mode 100755
diff --git a/./src/test/saxpy_array.cc b/../../nrt/nautilus/src/test/saxpy_array.cc
old mode 100644
new mode 100755
diff --git a/./src/test/tasks_and_futures.cc b/../../nrt/nautilus/src/test/tasks_and_futures.cc
old mode 100644
new mode 100755
diff --git a/./src/test/test_legion.c b/../../nrt/nautilus/src/test/test_legion.c
old mode 100644
new mode 100755
diff --git a/../../nrt/nautilus/test b/../../nrt/nautilus/test
new file mode 100755
index 0000000..7aa67e6
--- /dev/null
+++ b/../../nrt/nautilus/test
@@ -0,0 +1,3 @@
+
+make clean && make isoimage && scp nautilus.bin nautilus.iso root@v-test-r415-2.cs.northwestern.edu:/boot &&ssh root@v-test-r415-2.cs.northwestern.edu ./reboot_to_nautilus
+
diff --git a/./xeon_phi/linux_usr/Makefile b/../../nrt/nautilus/xeon_phi/linux_usr/Makefile
old mode 100644
new mode 100755
diff --git a/./xeon_phi/linux_usr/README b/../../nrt/nautilus/xeon_phi/linux_usr/README
old mode 100644
new mode 100755
diff --git a/./xeon_phi/linux_usr/phi_console.c b/../../nrt/nautilus/xeon_phi/linux_usr/phi_console.c
old mode 100644
new mode 100755
